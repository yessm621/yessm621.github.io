---
title: "스프링 AOP 개념과 주요 용어 (with 프록시)"
categories:
  - Spring
tags:
  - AOP
toc: true
toc_sticky: true
---

# 개요

AOP(Aspect-Oriendted Prograimming)는 관점 지향 프로그래밍이란 뜻으로 주로 코드의 횡단 관심사를 처리하기 위해 사용된다. (예. 로깅, 트랜잭션 관리 등)

AOP를 이해하기 위해선 프록시 개념을 먼저 이해해야 한다. 횡단 관심사를 구현하기 위해 프록시를 점진적으로 어떻게 발전시켰는지 그 과정을 알아보고 마지막에 스프링 AOP 개념과 주요 용어에 대해 알아보자.

![1](https://github.com/yessm621/yessm621.github.io/assets/79130276/360922a8-5763-4173-a7db-3c1a7a7ed37e)

<br>

# 프록시

## 프록시(Proxy)

클라이언트와 서버 개념에서 일반적으로 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받는다. 이것을 직접 호출이라 한다.

그런데 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 어떤 대리자를 통해서 대신 **간접적**으로 서버에 요청할 수 있다. 여기서 대리자를 영어로 `프록시(Proxy)`라 한다.

![2](https://github.com/yessm621/yessm621.github.io/assets/79130276/f77ed417-e1d2-4dc5-9f65-a1653a45e519)

### 프록시의 역할 - 대체 가능

클라이언트는 서버에게 요청한 것인지 프록시에게 요청한 것인지 몰라야 한다. 따라서, 프록시와 서버는 같은 인터페이스를 사용해야 한다.

아래 그림의 클래스 의존관계를 보면 클라이언트는 ServerInterface에 의존하고 있다. 그리고 프록시와 서버가 ServerInterface를 사용한다.

![3](https://github.com/yessm621/yessm621.github.io/assets/79130276/536e2c0a-6d57-4a8e-8e46-968fb2c178a1)

런타임 시점(애플리케이션 실행 시점)에 DI를 사용하면 Server에서 Proxy로 의존관계를 변경해도 클라이언트 코드 변경되지 않는다. 이처럼 프록시는 대체 가능해야 하고 실제 서버 처럼 동작할 수 있어야 한다.

### 프록시의 주요 기능

프록시의 주요 기능은 크게 2가지로 나눌 수 있다.

1. 접근 제어
    - 권한에 따른 접근 차단
    - 캐싱: 클라이언트가 프록시를 사용하다가 실제 요청이 있을 때 데이터를 조회하는 기능
    - 지연 로딩
2. 부가 기능 추가
    - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
    - 예) 로그 남기기

## 프록시 패턴과 데코레이터 패턴

프록시를 사용하는 디자인 패턴은 `프록시 패턴`과 `데코레이터 패턴`이 있다. 이 둘은 **의도에 따라 구분**될 뿐, 클래스 의존 관계는 거의 동일하다.

- 프록시 패턴: 접근 제어가 목적 (캐싱)
- 데코레이터 패턴: 새로운 기능 추가가 목적

![4](https://github.com/yessm621/yessm621.github.io/assets/79130276/1e8b744c-d975-421f-adca-aaac76eb2007)

![5](https://github.com/yessm621/yessm621.github.io/assets/79130276/dae4030d-40fe-42ac-adb5-3e381369ab5d)

> **참고** 프록시와 프록시 패턴은 다른 것이다.
> 

## 인터페이스 기반 프록시와 클래스 기반 프록시

인터페이스가 있는 경우, 인터페이스가 없고 클래스만 있는 경우. 두 경우 모두 프록시를 적용할 수 있다. 하지만 각자 단점이 존재한다.

- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다. 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다.
- 인터페이스 기반 프록시의 단점은 인터페이스가 필요하다는 그 자체이다.
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
    - 부모 클래스의 생성자를 호출해야 한다.
    - 클래스에 final 키워드가 붙으면 상속이 불가능하다. (자바 기본)
    - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

<br>

# 동적 프록시 기술

프록시를 사용해서 인터페이스 기반 프록시와 클래스 기반 프록시를 만들 수 있다. 그런데 문제는 프록시 클래스를 너무 많이 만들어야 한다.

로그 추적기라는 기능을 만들고 있다고 가정하자. 이때 로그 추적기를 적용해야 하는 대상 클래스가 100개라면 프록시 클래스도 100개 생성해야 한다. 동적 프록시 기술은 이와 같은 문제를 해결해준다.

자바는 `JDK 동적 프록시` 기술이나 `CGLIB`를 활용해 프록시 객체를 동적으로 만들어낼 수 있다. 즉, 프록시 클래스를 계속 만들지 않아도 된다. 프록시를 적용할 코드를 하나만 만들어두고 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.

## JDK 동적 프록시

JDK 동적 프록시는 인터페이스가 있는 경우에 사용하는 동적 프록시 기술이다.

> **참고** JDK 동적 프록시를 사용할 때 중요한 개념이 바로 리플렉션이다. 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.
> 

### JDK 동적 프록시 특징

- 인터페이스가 필수
- InvocationHandler 인터페이스를 사용해서 구현

![6](https://github.com/yessm621/yessm621.github.io/assets/79130276/c0ee3108-0ed6-4ba4-b5af-a46290399f6e)

![7](https://github.com/yessm621/yessm621.github.io/assets/79130276/58ad2984-7d66-461f-8550-6260905e1b69)

## CGLIB

CGLIB는 바이트 코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.

### CGLIB 특징

- 인터페이스 없이 구체 클래스만 가지고 동적 프록시 생성
- MethodInterceptor 인터페이스를 사용해서 구현
- 클래스 기반 프록시와 마찬가지로 상속을 사용하기 때문에 몇가지 제약이 있다.
    - 부모 클래스의 생성자를 체크해야 한다. → CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
    - 클래스에 final 키워드가 붙으면 상속이 불가능하다. → CGLIB에서는 예외가 발생한다.
    - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. → CGLIB에서는 프록시 로직이 동작하지 않는다.

![8](https://github.com/yessm621/yessm621.github.io/assets/79130276/367a6c5f-abde-4796-87b2-a7f83e688fc7)

하지만 동적 프록시에도 단점이 있다.

- 인터페이스가 있는 경우에는 `JDK 동적 프록시`를 적용하고, 그렇지 않은 경우에는 `CGLIB`를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해서 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

<br>

# 프록시 팩토리

## 프록시 팩토리

스프링은 동적 프록시를 통합해서 편리하게 만들어주는 `프록시 팩토리(ProxyFactory)`라는 기능을 제공한다.

이전에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGLIB를 사용해야 했다면, 이제는 이 프록시 팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다. 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 그리고 이 설정을 변경할 수도 있다.

![9](https://github.com/yessm621/yessm621.github.io/assets/79130276/afea8d4b-d8b9-4ab1-8efd-aedcb42f5514)


또한, JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각 만들 필요없이 `Advice`를 만들면 된다. 프록시 팩토리를 사용하면 Advice를 호출하는 전용 InvocationHandler, MethodInterceptor를 내부에서 사용한다.

![10](https://github.com/yessm621/yessm621.github.io/assets/79130276/22d86cad-c654-4b34-973b-b71c33c066cb)

스프링은 `Pointcut`을 사용해 특정 조건에 부합할 때 프록시 부가 기능이 적용되도록 한다.

## Pointcut, Advice, Advisor

다음 용어는 스프링 AOP에서 자주 보게될 용어이다. 확실하게 알아두는 것이 좋다.

- **포인트컷**(Pointcut): 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링 한다.
- **어드바이스**(Advice): 프록시가 호출하는 부가 기능이다. 단순하게 프록시 로직이라 생각하면 된다.
- **어드바이저**(Advisor): 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 **포인트컷1 + 어드바이스1**이다.

다음과 같이 기억하면 외우기 쉽다.

- 조언(Advice)을 어디(Pointcut)에 할 것인가?
- 조언자(Advisor)는 어디(Pointcut)에 조언(Advice)을 해야할지 알고 있다.

### 정리

- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.
- 어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
- 둘을 합치면 어드바이저가 된다. 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다.

![11](https://github.com/yessm621/yessm621.github.io/assets/79130276/e569f802-9348-4900-bfd2-ca6a16e5ec1e)

![12](https://github.com/yessm621/yessm621.github.io/assets/79130276/e3aed06c-ff14-4666-bc71-f3fbdb6e0c85)


- 하나의 프록시에 여러 어드바이저를 적용할 수 있다.

![13](https://github.com/yessm621/yessm621.github.io/assets/79130276/0889f524-d179-4e52-8930-c440d14732e0)

프록시 팩토리와 Advice, Pointcut 개념을 사용해 프록시를 적용하는 방법에 대해 알아보았다. 하지만 프록시 팩토리도 너무 많은 설정정보를 작성해야 한다. 또한 컴포넌트 스캔으로  스프링 빈을 등록하는 방식에는 프록시 팩토리를 적용할 수 없다.

<br>

# 자동 프록시 생성기(빈 후처리기)

## 빈 후처리기(BeanPostProcessor)

스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용하면 된다. 빈 후처리기는 이름 그대로 빈을 생성한 후에 무언가를 처리하는 용도로 사용한다.

빈 후처리기는 객체를 조작할 수도 있고, 완전히 다른 객체로 바꿔치기 하는 것도 가능하다.

![14](https://github.com/yessm621/yessm621.github.io/assets/79130276/f2847eaf-878b-4035-aea7-e46881f5fb8d)

![15](https://github.com/yessm621/yessm621.github.io/assets/79130276/4358782a-707e-413e-a3b6-0b08b3c60c15)

빈 후처리기를 사용해서 실제 객체 대신 프록시를 스프링 빈으로 등록하는 것도 가능하다. 이렇게 하면 수동으로 등록하는 빈은 물론이고, 컴포넌트 스캔을 사용하는 빈까지 모두 프록시를 적용할 수 있다. 더 나아가서 설정 파일에 있는 수 많은 프록시 생성 코드도 한번에 제거할 수 있다.

![16](https://github.com/yessm621/yessm621.github.io/assets/79130276/e8bd194e-e7e7-478b-aeda-6e270dd8e28d)

## 자동 프록시 생성기 - AutoProxyCreator

`자동 프록시 생성기`는 스프링이 제공하는 빈 후처리기이다. 이름 그대로 자동으로 프록시를 생성해주는 빈 후처리기이다. 

- 이 빈 후처리기는 스프링 빈으로 등록된 Advisor들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용해준다.
- Advisor 안에는 Pointcut과 Advice가 이미 모두 포함되어 있다. 따라서 Advisor만 알고 있으면 그 안에 있는 Pointcut으로 어떤 스프링 빈에 프록시를 적용해야 할지 알 수 있다. 그리고 Advice로 부가 기능을 적용하면 된다.

**자동 프록시 생성기의 작동 과정을 알아보자.**

![17](https://github.com/yessm621/yessm621.github.io/assets/79130276/5320539d-0c5a-4101-9b3f-fd5745cf86b6)

1. **생성:** 스프링이 스프링 빈 대상이 되는 객체를 생성한다. (@Bean, 컴포넌트 스캔 모두 포함)
2. **전달:** 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. **모든 Advisor 빈 조회:** 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 Advisor를 조회한다.
4. 프**록시 적용 대상 체크:** 앞서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 **조건이 하나라도 만족하면 프록시 적용 대상**이 된다.
5. **프록시 생성:** 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
6. **빈 등록:** 반환된 객체는 스프링 빈으로 등록된다.