---
title: "IP와 TCP"
categories:
  - Http
tags:
  - Web
toc: true
toc_sticky: true
---

## IP

클라이언트와 서버의 통신은 복잡한 **인터넷 망**(중간 **노드**라는 서버들)을 거쳐서 데이터를 전송한다. 먼저 IP에 대해 알아보자.

> **참고** 노드
<br>
여기서의 노드란 네트워크를 중간에서 연결해주는 서버(라우터)를 의미한다.
> 

`IP`란 Internet Protocol(인터넷 프로토콜)의 줄임말로 IP 프로토콜이라고도 한다. 복잡한 인터넷 망에서 클라이언트와 서버가 통신하려면 최소한의 **규칙**이 있어야 하는데 그게 IP이다.

클라이언트가 서버에게 지정한 주소로 **메시지를 전달**할 수 있으려면 클라이언트와 서버에 `IP 주소`를 부여해야 한다.

![1](https://user-images.githubusercontent.com/79130276/209615227-deb5e9c4-19fb-4d79-841e-0c7caed7c3eb.png)

IP는 지정한 **IP 주소**(IP Address)에 데이터를 전달하고 **패킷**(Packet)이라는 통신 단위로 데이터를 전달한다.

> **참고** 패킷
<br>
네트워크에서 데이터를 주고 받을 때 데이터를 일정 묶음으로 나눠놓은 것이다.
데이터는 작은 패킷으로 나뉘어 네트워크로 전송된다. 이 패킷에는 헤어가 있어서 헤더에 발신자 정보와 수령자 정보 등이 포함된다.
> 

> **참고**
<br>
> **패킷 교환방식의 장점**
<br>
> 1. 네트워크 리소스 점유 시간이 적다.
> 2. 클라이언트에서 서버로 이동하는 경로가 고정되어 있지 않다.
>     - 패킷마다 어떤 경로를 통해 전달될지가 결정되어 있지 않기 때문에 경로상에 장애가 발생해도 다른 경로를 통해 전송하게 되므로 안정성이 높다.
> 3. 나누어진 패킷은 순서(넘버링)가 매겨져 중간에 유실된 패킷에 대한 재요청이 가능하여 전체 내용을 재전송하지 않아도 된다. (syn, ack 신호 교환이 각 패킷에 모두 적용된다)
> 
> **패킷 교환방식의 단점**
<br>
> 모든 패킷에 대한 syn, ack 확인과정이 추가되는 것, 모든 패킷에 헤더가 붙어야 한다는 것에 따른 오버헤드가 발생할 수 있다.
> 

### IP 패킷 정보

IP 패킷 정보에는 출발지 IP, 목적지 IP, 전송 데이터, 기타 등이 있다.

> **참고**
<br>
요청(클라이언트 → 서버) 패킷과 응답(서버 → 클라이언트) 패킷의 전달 경로는 서로 다를 수 있다.
> 

### IP 프로토콜의 한계

1. 비연결성: 클라이언트는 서버가 어떤 상태인지 모른다. 따라서, 서버가 서비스 **불능 상태**여도 일단 패킷을 전송하고 사라진다.
2. 비신뢰성: 패킷을 보내는 중간에 노드(서버)가 꺼지거나 문제가 생기면 패킷이 유실되는데, 클라이언트는 패킷이 사라진지 모른다. 또한, 메시지가 너무 크면 패킷을 끊어서 보내는데 패킷이 순서대로 오지 않을 수 있다. 예) 클라이언트 1:Hello, 2:World → 서버 1:World, 2:Hello
3. 프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 2개 이상이면 구분이 불가능하다.  예) 같은 IP에서 음악을 실행하고 게임을 하고 있으면 구분할 수 없다.

> **참고** IP 패킷의 순서
<br>
네트워크 계층 헤더의 프래그먼트 오프셋 등을 이용해 패킷의 순서를 알 수 있다. 수신측은 이 헤더정보를 통해 데이터의 순서나, 추가 데이터가 있는지 등을 파악할 수 있다.
> 

이러한 IP 프로토콜의 한계를 극복하기 위해 TCP를 사용한다.

## TCP, UDP

### TCP

TCP란 Transmission Control Protocol의 줄임말로 전송 제어 프로토콜이라고 한다.

`TCP`는 패킷소실을 방지해주고, 패킷 순서를 보장해준다. 또한, TCP엔 PORT가 있어서 같은 IP에서 다른 애플리케이션을 실행해도 구분할 수 있다. 

### TCP/IP 패킷 정보

- IP 내용: 출발지 IP, 목적지 IP, 기타
- TCP 내용: 출발지 PORT, 목적지 PORT, 전송제어 정보, 순서 정보, 검증 정보
- TCP = IP + PORT (IP가 한 아파트라면 PORT는 동, 호수이다.)

![1-1](https://user-images.githubusercontent.com/79130276/209615223-4d04118f-0c3f-4506-96e5-d4b86fc049b7.png)

> **참고** PORT
<br>
PORT는 클라이언트에서 한번에 둘 이상의 서버와 연결할 때 구분하기 위해 사용한다.
포트는 0~65535 할당 가능하다. 그 중 0~1023까지는 잘 알려진 포트이므로 사용하지 않는 것이 좋다. 
예) FTP - 20, 21 / TELNET - 23 / HTTP - 80 / HTTPS - 443
> 

> **참고** localhost:8080
<br>
웹은 기본적으로 80포트를 사용하는 것이 관례이다. 그래서 HTTP 요청이면서 별도의 포트를 지정하지 않을 경우 80번 포트로 접속을 시도한다. 그러나, 사용자가 직접 포트 번호를 지정할 경우 그 포트로 바로 접속을 시도한다. 80에서 8080으로 포워딩하는 구조는 아니다.
> 

### TCP 특징

TCP엔 전송제어 정보, 순서 정보, 검증 정보가 있기 때문에 아래의 연결지향, 데이터 전달 보증, 순서 보장이 가능하다. 

1. 연결지향 - `TCP 3way handshake`(가상 연결): 서버와 클라이언트가 연결이 되어있는지 확인한다.
2. 데이터 전달 보증: 클라이언트에서 데이터를 전달하고 서버가 데이터를 받으면 서버가 데이터를 잘 받았다고 클라이언트에게 응답 메시지를 전달해준다. 따라서, 패킷이 누락 되면 클라이언트가 알 수 있다.
3. 순서 보장: 패킷을 보냈는데 순서가 틀리면 다 버리고 다시 보낸다. 예) 패킷 1, 2, 3 을 보냈는데 전송 도착이 1, 3, 2라고 하면 2번째 패킷부터 순서가 틀렸기 때문에 2번부터 다시 받음
4. 신뢰할 수 있는 프로토콜
5. 현재는 대부분 TCP 사용

**TCP 3way handshake**

`TCP 3way handshake`는 가상 연결로 물리적 연결이 아닌 **논리적 연결**이다. 클라이언트랑 서버랑 `SYN - ACK`을 보내면서 연결이 되어있나보다 생각하는 것이다.

TCP/IP 프로토콜로 연결하는 과정은 다음과 같다. (SYN: 접속 요청, ACK: 요청 수락)

1. 클라이언트에서 서버로 `SYN` 보냄
2. 서버에서 클라이언트로 `SYN+ACK` 보냄
3. 클라이언트에서 서버로 `ACK` 보냄
4. 연결이 완료되며 클라이언트에서 서버로 데이터 전송

1,2,3: connect 과정이고 이 과정 중 하나라도 실패하면 connection이 연결되지 않는다. 4번에서 데이터를 전송한다고 하였지만 요즘엔 최적화되어 3번 ACK를 전송하면서 데이터도 같이 전송한다.

![2](https://user-images.githubusercontent.com/79130276/209615233-64d13c9c-3cbc-4709-99a2-698062259280.png)

> **참고**
<br>
TCP/IP 패킷은 크게 헤더 부분과 데이터 부분으로 나눌 수 있다.
3 way handshake에서 TCP/IP 패킷을 전송한다고 했는데 실제론 헤더 부분을 전송하는 것이다. 이 헤더 부분에 SYN, ACK등을 포함해서 보낼 수 있다. 3단계나 4단계에서 헤더 + 데이터 부분이 함께 전송된다.
> 

> **참고**
<br>
데이터 전달이 종료되고 난 후 연결을 해제할 때는 4 way handshake 과정을 거친다.
> 

## UDP

UDP란 User Datagram Protocol의 줄임말로 사용자 데이터그램 프로토콜이라고 한다.

TCP와 달리 UDP는 패킷 소실 방지, 패킷 순서 보장을 해주는 것은 아니라 크게 도움이 되진 않지만, 그래도 문제를 해결해주는 정보를 가지고 있다. UDP는 TCP와 마찬가지로 PORT가 있다.

### UDP 특징

UDP는 기능이 거의 없다. (연결지향 - TCP 3way handshake X, 데이터 전달 보증 X, 순서 보장 X) 데이터 전달 및 순서가 보장되지 않지만, **단순하고 빠르**다. IP와 거의 같고 PORT, 체크섬 정도만 추가된다. 

최근 HTTP 3스펙이 나오면서 TCP 프로토콜의 3 Way Handshake 과정의 번거로움을 없애고자 UDP를 사용하면서 UDP가 떠오르고 있다.

> **참고** 체크섬
<br>
이 메세지가 맞는지 검증하는 용도, 네트워크를 통해 전달된 값이 변경되었는지를 검사하는 값으로 무결성을 제공함
> 

> **참고** TCP와 UDP
<br>
애플리케이션으로 통신을 구현할 때 TCP와 UDP 중 선택해서 사용할 수 있다. 다만, 웹 개발은 브라우저라고 하는 애플리케이션 위에서 동작하는 애플리케이션을 만드는 일이다. 따라서, 통신 프로토콜을 선택하거나 하는 자유도가 많이 떨어진다.
서버와 브라우저가 서로 통신하며 HTTP 최신 규격을 사용할지 여부를 결정하게 되고, 이 규격에 따라 TCP만 사용할지 UDP도 사용할지가 결정된다.
HTTP 최신규격인 HTTP/3 는 UDP를 이용한 데이터 전송을 주력으로 통신속도 향상을 꾀하는 것이 주된 목적이고 구글이 주도적으로 표준을 정립하고 있다.
> 

## DNS (Domain Name System)

IP는 기억하기 어렵고 변경될 수 있다. 따라서, IP주소를 **도메인** 명으로 변환하여 사용한다. 이때 `DNS`란 전화번호부처럼 도메인 명과 IP를 매칭하여 등록해 놓은 것을 의미한다.

![3](https://user-images.githubusercontent.com/79130276/209615235-02a3b805-c01c-4b96-a4a4-9b4b1f9f1c5f.png)

## 인터넷 프로토콜 스택의 4계층

아래 그림은 브라우저의 인터넷을 사용할 때 이용되는 프로토콜 스택의 4계층이다. 브라우저라는 응용 애플리케이션이 실제 네트워킹을 하기 위한 구조라고 이해하자.

![4](https://user-images.githubusercontent.com/79130276/209615242-f2d39b6a-ddc4-45ea-ae4f-610bce7ed8dd.png)

### [예제] 채팅 프로그램

![5](https://user-images.githubusercontent.com/79130276/209615244-878f01d1-cf42-427b-a359-4f4d6cb013f0.png)

Hello, world! 라는 메시지를 전송하고 싶다면, 

1. Hello, world! 메시지 생성
2. SOCKET 라이브러리를 사용해서 OS 계층에 메시지를 넘긴다.
3. OS 계층의 TCP가 메시지에 TCP의 정보 씌운다.
4. TCP 정보에 IP정보를 씌운다.
    - IP 패킷 안에 TCP 데이터 포함하고 있고 그 안에 메시지가 있다.
5. 네트워크 인터페이스를 통해 LAN 카드로 IP 패킷을 서버에 보낸다. (Ethernet frame이 포함되서 나간다.)

> **참고** 이더넷 프레임 (Ethernet frame)
<br>
랜카드에 등록된 맥주소 같은 물리적인 정보들이 포함되어 있다.
> 

## Reference.

[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-웹-네트워크)