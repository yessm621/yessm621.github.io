---
title:  "스프링 MVC2"
# last_modified_at: 2022-06-29T15:05:00
# last_modified_at: 2022-07-02T01:20:00
# last_modified_at: 2022-07-03T15:50:00
last_modified_at: 2022-07-03T23:50:00
categories: 
  - Spring
tags:
  - Java
  - Spring
toc: true
toc_label: "Index"
toc_sticky: true
---

# 스프링 MVC - 구조이해

## 1. 스프링 MVC 전체 구조

직접 만든 MVC 프레임워크와 스프링 MVC를 비교

<br>

![Untitled](https://user-images.githubusercontent.com/79130276/176859966-5d807a7d-8335-42b4-9d0b-cd1bf892a57b.png)

![Untitled2](https://user-images.githubusercontent.com/79130276/176859957-38ae158b-4a24-44ee-beb0-2358cd1d98ac.png)

<br>

**직접 만든 프레임워크 → 스프링 MVC 비교**

- FrontController → DispatcherServlet
- handlerMappingMap → HandlerMapping
- MyHandlerAdapter → HandlerAdapter
- ModelView → ModelAndView
- viewResolver → ViewResolver
- MyView → View

<br>

### 1.1 DispatcherServlet 구조

- 스프링 MVC도 프론트 컨트롤러 패턴으로 구현됨
- 스프링 MVC의 프론트 컨트롤러가 `디스패처 서블릿`
- 디스패처 서블릿이 스프링 MVC의 핵심

<br>

**DispatcherServlet 서블릿 등록**

- DispatcherServlet도 부모 클래스에서 **HttpServlet을 상속** 받아서 사용하고, `서블릿으로 동작`함
    - DispatcherServlet → FrameworkServlet → HttpServletBean → HttpServlet
- 스프링 부트는 DispacherServlet을 서블릿으로 자동으로 등록하면서 **모든 경로**(urlPatterns=”/”)에 대해 매핑함 (참고. 더 자세한 경로가 우선순위가 높음)

<br>

**요청 흐름**

1. 서블릿 호출됨 → HttpServlet이 제공하는 service()가 호출됨
2. 스프링 MVC는 DispatcherServlet 의 부모인 FrameworkServlet 에서 service() 를 오버라이드
함
3. FrameworkServlet.service() 를 시작으로 여러 메서드가 호출되면서 `DispacherServlet.doDispatch()` 가 호출

<br>

**DispacherServlet의 핵심은 doDispatch()!**

<br>

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {

    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    ModelAndView mv = null;

    // 1. 핸들러 조회
    mappedHandler = getHandler(processedRequest);
    if (mappedHandler == null) {
        noHandlerFound(processedRequest, response);
        return;
    }

    // 2. 핸들러 어댑터 조회 - 핸들러를 처리할 수 있는 어댑터
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

    // 3. 핸들러 어댑터 실행 -> 4. 핸들러 어댑터를 통해 핸들러 실행 -> 5. ModelAndView 반환
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);

}

private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
			HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

    // 뷰 렌더링 호출
    render(mv, request, response);

}

protected void render(ModelAndView mv, HttpServletRequest request,
    HttpServletResponse response) throws Exception {

    View view;
    String viewName = mv.getViewName();

    // 6. 뷰 리졸버를 통해서 뷰 찾기, 7. View 반환
    view = resolveViewName(viewName, mv.getModelInternal(), locale, request);

    // 8. 뷰 렌더링
    view.render(mv.getModelInternal(), request, response);
}
```

<br>

![Untitled3](https://user-images.githubusercontent.com/79130276/176859933-e6fedf18-e3ca-42b9-982a-a2e651dfb11a.png)

**동작 순서**

1. 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회함
2. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회
3. 핸들러 어댑터 실행
4. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행함
5. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 **변환**해서 반환
6. viewResolver 호출: 뷰 리졸버를 찾고 실행
    - JSP의 경우 InternalResourceViewResolver가 자동 등록되고 사용됨
7. View 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고 렌더링 역할을 담당하는 뷰 객체를 반환
    - JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다
8. 뷰 렌더링: 뷰를 통해서 뷰를 렌더링

<br>

**인터페이스 살펴보기**

- 스프링 MVC의 강점은 **DispatcherServlet** 코드의 변경 없이 원하는 기능을 변경, 확장할 수 있다는 점. (대부분을 확장 가능할 수 있게 인터페이스로 제공)
- 인터페이스들만 구현해서 DispatcherServlet에 등록하면 커스텀 컨트롤러를 만들 수도 있다 (물론 쉽지 않다..;;)

<br>

**주요 인터페이스 목록**

- 핸들러 매핑: org.springframework.web.servlet.HandlerMapping
- 핸들러 어댑터: org.springframework.web.servlet.HandlerAdapter
- 뷰 리졸버: org.springframework.web.servlet.ViewResolver
- 뷰: org.springframework.web.servlet.View

<br>

**정리**

스프링 MVC는 코드 분량이 매우 많고 복잡해서 내부 구조를 다 파악하는 것은 쉽지 않다. 그러나, 걱정하지 않아도 된다. 웹 애플리케이션을 만들 때 필요한 기능은 대부분 이미 구현되어 있음.

그래도 핵심 동작 방식은 알아둬야 문제가 발생했을 때 쉽게 파악하고 해결이 가능함. 또한, 확장 포인트가 필요할 때 어떤 부분을 확장할지 감을 잡을 수 있음.

<br>

`핸들러 매핑`과 `핸들러 어댑터`의 개념이 중요!

<br>

## 2. 핸들러 매핑과 핸들러 어댑터

### 2.1 Controller 인터페이스

과거의 Controller

```java
// org.springframework.web.servlet.mvc.Controller
public interface Controller {
	ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;
}
```

<br>

> **참고** Controller 인터페이스와 @Controller는 전혀 다름
> 

<br>

```java
package hello.servlet.web.springmvc.old;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component("/springmvc/old-controller")
public class OldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return null;
    }
}
```

- @Component: 이 컨트롤러는 /springmvc/old-controller라는 이름의 스프링 빈으로 등록됨
- **빈의 이름으로 URL을 매핑**

<br>

> **컴포넌트 스캔**
빈으로 등록 될 준비를 마친 클래스들을 스캔하여, 빈으로 등록해주는 것. 즉, 스프링 빈을 등록할 때 사용
@ComponentScan: 어느 지점부터 컴포넌트를 찾으라고 알려주는 역할
@Component: 실제로 찾아서 빈으로 등록할 클래스를 의미
> 

<br>

![Untitled4](https://user-images.githubusercontent.com/79130276/176874174-43d4b210-a818-412b-89ef-d678416c1422.png)

<br>

**컨트롤러가 호출**되려면 다음 2가지가 필요

- `HandlerMapping(핸들러 매핑)`
    - 핸들러 매핑에서 컨트롤러를 찾을 수 있어야 함
    - 예) 스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요함
- `HandlerAdapter(핸들러 어댑터)`
    - 핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요
    - 예) Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 함

<br>

스프링은 핸들러 매핑과 핸들러 어댑터를 대부분 구현해둠

<br>

**스프링 부트가 자동 등록하는 핸들러 매핑과 핸들러 어댑터**

(실제로는 더 많지만, 주요 핸들러 매핑과 핸들러 어댑터만 소개)

**HandlerMapping**

```
0 = RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다.
```

**HandlerAdapter**

```
0 = RequestMappingHandlerAdapter : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리
2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리
```

<br>

핸들러 매핑, 핸들러 어댑터 모두 순서대로 찾고 없으면 다음 순서로 넘어감

<br>

1. 핸들러 매핑으로 핸들러 조회
    - HandlerMapping을 순서대로 실행해서, 핸들러를 찾음
    - 이 경우, 빈 이름으로 핸들러를 찾아야 하기 때문에 이름 그대로 빈 이름으로 핸들러를 찾아주는 BeanNameUrlHandlerMapping가 실행에 성공하고 핸들러인 OldController를 반환함
2. 핸들러 어댑터 조회
    - HandlerAdapter의 supports()를 순서대로 호출
    - SimpleControllerHandlerAdapter가 Controller 인터페이스를 지원하므로 대상이 됨
3. 핸들러 어댑터 실행
    - 디스패처 서블릿이 조회한 SimpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨줌
    - SimpleControllerHandlerAdapter는 핸들러인 OldController를 내부에서 실행하고, 그 결과를 반환

<br>

**정리 - OldController 핸들러매핑, 어댑터**

OldController를 실행하면서 사용된 객체

- HandlerMapping = BeanNameUrlHandlerMapping
- HandlerAdapter = SimpleControllerHandlerAdapter

<br>

### 2.2 HttpRequestHandler

HttpRequestHandler는 **서블릿과 가장 유사한 형태**의 핸들러

<br>

```java
public interface HttpRequestHandler {
	void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}
```

<br>

```java
package hello.servlet.web.springmvc.old;

import org.springframework.stereotype.Component;
import org.springframework.web.HttpRequestHandler;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component("/springmvc/request-handler")
public class MyHttpRequestHandler implements HttpRequestHandler {
    @Override
    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("MyHttpRequestHandler.handleRequest");
    }
}
```

<br>

1. 핸들러 매핑으로 핸들러 조회
    - HandlerMapping을 순서대로 실행해서, 핸들러를 찾음
    - 이 경우, 빈 이름으로 핸들러를 찾아야 하기 때문에 이름 그대로 빈 이름으로 핸들러를 찾아주는 BeanNameUrlHandlerMapping가 실행에 성공하고 핸들러인 MyHttpRequestHandler를 반환함
2. 핸들러 어댑터 조회
    - HandlerAdapter의 supports()를 순서대로 호출
    - HttpRequestHandlerAdapter가 HttpRequestHandler 인터페이스를 지원하므로 대상이 됨
3. 핸들러 어댑터 실행
    - 디스패처 서블릿이 조회한 HttpRequestHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨줌
    - HttpRequestHandlerAdapter는 핸들러인 MyHttpRequestHandler를 내부에서 실행하고, 그 결과를 반환

<br>

**정리 - MyHttpRequestHandler 핸들러매핑, 어댑터**

MyHttpRequestHandler를 실행하면서 사용된 객체

- HandlerMapping = BeanNameUrlHandlerMapping
- HandlerAdapter = HttpRequestHandlerAdapter

<br>

**@RequestMapping**

가장 우선순위가 높은 핸들러 매핑과 핸들러 어댑터는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter 이다.

`@RequestMapping` → 현재 스프링에서 주로 사용하는 애노테이션 기반의 컨트롤러를 지원하는 매핑과 어댑터 (실무에서 99.9% 사용)

<br>

## 3. 뷰 리졸버

View를 사용할 수 있도록 다음 코드를 추가했다.

<br>

OldController.java

```java
return new ModelAndView("new-form")
```

<br>

위의 코드만 추가한 상태에서 클라이언트가 http://localhost:8080/springmvc/old-controller 를 호출하면 컨트롤러는 정상 호출되지만, 웹 브라우저에는 Whitelabel Error Page가 나옴

뷰 리졸버를 추가하자

<br>

application.properties

```
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

<br>

**뷰 리졸버 - InternalResourceViewResolver**
스프링 부트는 `InternalResourceViewResolver` 라는 **뷰 리졸버**를 자동으로 등록함

이때, application.properties 에 등록한 spring.mvc.view.prefix , spring.mvc.view.suffix 설정
정보를 사용

<br>

### 3.1 뷰 리졸버 동작 방식

**스프링 부트가 자동 등록하는 뷰 리졸버**

```
1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성
기능에 사용)
2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.
```

<br>

1. 핸들러 어댑터 호출
    
    : 핸들러 어댑터를 통해 new-form이라는 논리 뷰 이름을 획득
    
2. ViewResolver 호출
    - new-form이라는 뷰 이름으로 viewResolver를 순서대로 호출
    - BeanNameViewResolver는 new-form이라는 이름의 스프링 빈으로 등록된 뷰를 찾아야 하는데 없다
    - 그 다음 순위인 InternalResourceViewResolver가 호출됨
3. InternalResourceViewResolver
    
    : 이 뷰 리졸버는 InternalResourceView를 반환
    
4. 뷰 - InternalResourceView
    
    : InternalResourceView는 JSP처럼 포워드 forward()를 호출해서 처리할 수 있는 경우에 사용
    
5. view.render()
    
    view.render()가 호출되고 InternalResourceView는 forward()를 사용해서 JSP를 실행함
    
<br>

> **참고**
InternalResourceViewResolver 는 만약 JSTL 라이브러리가 있으면 InternalResourceView 를
상속받은 JstlView 를 반환한다. JstlView 는 JSTL 태그 사용시 약간의 부가 기능이 추가된다
>

## 4. 스프링 MVC - 시작하기

현재 스프링이 제공하는 컨트롤러는 `애노테이션 기반`으로 동작, 매우 **유연**하고 **실용적**

<br>

**@RequestMapping**

- RequestMappingHandlerMapping
- RequestMappingHandlerAdapter

<br>

`@RequestMapping`를 사용하여 유연하고 실용적인 컨트롤러 생성

<br>

가장 우선순위가 높은 핸들러 매핑과 핸들러 어댑터는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter

@RequestMapping의 앞글자를 따서 만든 이름. 현재 스프링에서 주로 사용하는 애노테이션 기반의 컨트롤러를 지원하는 핸들러 매핑과 어댑터. (**실무에서 99.9% 이 방식의 컨트롤러를 사용**)

<br>

**SpringMemberFormControllerV1 - 회원 등록 폼**

```java
package hello.servlet.web.springmvc.v1;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class SpringMemberFormControllerV1 {

    @RequestMapping("/springmvc/v1/members/new-form")
    public ModelAndView process() {
        return new ModelAndView("new-form");
    }
}
```

<br>

**@Controller**

- 스프링이 자동으로 스프링 빈으로 등록함 (내부에 @Component 애노테이션이 있어 컴포넌트 스캔의 대상이 됨)
- 스프링 MVC에서 애노테이션 기반 컨트롤러로 인식
    - RequestMappingHandlerMapping에서 핸들러 정보로 인식하고 꺼낼 수 있는 대상이 됨

<br>

**@RequestMapping**: 요청 정보를 매핑. 해당 URL이 호출되면 이 메서드가 호출됨. 애노테이션을 기반으로 동작하기 때문에 메서드 이름은 임의로 지으면 됨

<br>

**ModelAndView**: 모델과 뷰 정보를 담아서 반환

<br>

RequestMappingHandlerMapping은 스프링 빈 중에서 @RequestMapping 또는 @Controller가 클래스 레벨에 붙어 있는 경우에 매핑 정보로 인식함

다음 코드도 @Controller를 붙였을 때와 동일하게 동작함

```java
package hello.servlet.web.springmvc.v1;

import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

//@Controller
@Component
@RequestMapping
public class SpringMemberFormControllerV1 {

    @RequestMapping("/springmvc/v1/members/new-form")
    public ModelAndView process() {
        return new ModelAndView("new-form");
    }
}
```

@Component: 컴포넌트 스캔을 통해 스프링 빈으로 등록

<br>

물론 컴포넌트 스캔 없이 스프링 빈으로 직접 등록해도 됨 (위의 코드와 동일하게 실행됨)

```java
// ServletApplication
//스프링 빈 직접 등록
@Bean
SpringMemberFormControllerV1 springMemberFormControllerV1() {
    return new SpringMemberFormControllerV1();
}
```

<br>

**SpringMemberSaveControllerV1 - 회원 저장 폼**

```java
package hello.servlet.web.springmvc.v1;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
public class SpringMemberSaveControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/springmvc/v1/members/save")
    public ModelAndView process(HttpServletRequest request, HttpServletResponse response) {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        ModelAndView mv = new ModelAndView("save-result");
        mv.addObject("member", member);

        return mv;
    }
}
```

**mv.addObject(”member”, member)**

스프링이 제공하는 ModelAndView를 통해 Model 데이터를 추가할 때는 addObject()를 사용. 이 데이터는 이후 뷰를 렌더링할 때 사용

<br>

**SpringMemberListControllerV1 - 회원 목록**

```java
package hello.servlet.web.springmvc.v1;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import java.util.List;

@Controller
public class SpringMemberListControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/springmvc/v1/members")
    public ModelAndView process() {

        List<Member> members = memberRepository.findAll();
        ModelAndView mv = new ModelAndView("members");
        mv.addObject("members", members);

        return mv;
    }
}
```

<br>

## 5. 스프링 MVC - 컨트롤러 통합

@RequestMapping은 클래스 단위가 아닌 메서드 단위에 적용되었으므로 컨트롤러 클래스를 유연하게 하나로 **통합** 할 수 있음

<br>

또한, /springmvc/v2/members이 중복되므로 클래스 레벨에 @RequestMapping("/springmvc/v2/members") 정의함으로써 중복을 제거할 수 있다

( 클래스 레벨과 메서드 레벨과 **조합**됨)

```java
package hello.servlet.web.springmvc.v2;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;

@Controller
@RequestMapping("/springmvc/v2/members")
public class SpringMemberControllerV2 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/new-form")
    public ModelAndView newForm() {
        return new ModelAndView("new-form");
    }

    @RequestMapping("/save")
    public ModelAndView save(HttpServletRequest request, HttpServletResponse response) {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        ModelAndView mv = new ModelAndView("save-result");
        mv.addObject("member", member);

        return mv;
    }

    @RequestMapping
    public ModelAndView members() {

        List<Member> members = memberRepository.findAll();
        ModelAndView mv = new ModelAndView("members");
        mv.addObject("members", members);

        return mv;
    }
}
```

<br>

## 6. 스프링 MVC - 실용적인 방식

실무에서 주로 사용하는 방식

```java
package hello.servlet.web.springmvc.v3;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
@RequestMapping("/springmvc/v3/members")
public class SpringMemberControllerV3 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @GetMapping("/new-form")
    public String newForm() {
        return "new-form";
    }

    @PostMapping("/save")
    public String save(@RequestParam("username") String username,
                       @RequestParam("age") int age,
                       Model model) {

        Member member = new Member(username, age);
        memberRepository.save(member);

        model.addAttribute("member", member);

        return "save-result";
    }

    @GetMapping
    public String members(Model model) {

        List<Member> members = memberRepository.findAll();

        model.addAttribute("members", members);

        return "members";
    }
}
```

**Model 파라미터**

save(), members()를 보면 Model을 파라미터로 받는 것을 확인 할 수 있음

<br>

**ViewName 직접 반환**

뷰의 논리 이름을 반환

<br>

**@RequestParam 사용**

스프링은 HTTP 요청 파라미터를 @RequestParam으로 받을 수 있음

@RequestParam("username") 은 request.getParameter("username") 와 거의 같은 코드

물론, GET 쿼리 파라미터, POST Form 방식을 모두 지원

<br>

**@RequestMapping → @GetMapping, @PostMapping**

@RequestMapping 은 URL만 매칭하는 것이 아니라, HTTP Method도 함께 구분할 수 있다.
예를 들어서 URL이 /new-form 이고, HTTP Method가 GET인 경우를 모두 만족하는 매핑을 하려면
다음과 같이 처리

```java
@RequestMapping(value = "/new-form", method = RequestMethod.GET)
```

<br>

`@GetMapping`, `@PostMapping`으로 더 편리하게 사용 가능

<br>

# 스프링 MVC - 기본 기능

<br>

> **프로젝트 생성시 참고**
Packaging는 War가 아닌 **Jar**를 선택.
JSP를 사용하지 않기 때문에 Jar를 사용하는 것이 좋음. (스프링 부트 사용 시 이 방식을 사용)
Jar를 사용하면 항상 내장 서버(톰캣 등)를 사용하고, webapp 경로도 사용하지 않음
내장 서버 사용에 최적화 되어 있는 기능.
War를 사용하면 내장 서버도 사용가능 하지만, 주로 외부 서버에 배포하는 목적으로 사용함
> 

<br>

## 1. 로깅

운영 시스템에서는 System.out.println()같은 시스템 콘솔 사용하지 않고 별도의 `로깅 라이브러리`를 사용해서 로그를 출력함

<br>

**로깅 라이브러리**

스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리(spring-boot-starter-logging) 포함

<br>

스프링 부트가 사용하는 기본 로깅 라이브러리

- SLF4J
- Logback

<br>

로그 라이브러리는 Logback, Log4J, Log4J2 등등 수 많은 라이브러리가 존재

그것을 통합해 인터페이스로 제공하는 것이 `SLF4J 라이브러리`

SLF4J는 인터페이스고, 그 구현체로 Logback 같은 로그 라이브러리를 선택

실무에서는 스프링 부트가 기본으로 제공하는 Logback을 대부분 사용

<br>

**로그 선언**

- private Logger log = LoggerFactory.getLogger(getClass());
- private static final Logger log = LoggerFactory.getLogger(Xxx.class)
- @Slf4j : 롬복 사용 가능

<br>

**로그 호출**

- log.info(”hello”)
- System.out.println(”hello)

<br>

시스템 콘솔로 직접 출력하는 것보다 `로그`를 사용하는게 좋다. 실무에서는 항상 **로그를 사용**해야 함.

```java
package hello.springmvc.basic;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

//@Slf4j
@RestController
public class LogTestController {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest() {
        String name = "Spring";

        log.trace("trace log={}", name);
        log.debug("debug log={}", name);
        log.info(" info log={}", name);
        log.warn(" warn log={}", name);
        log.error("error log={}", name);

        // 로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X
        log.debug("String concat log=" + name);

        return "ok";
    }
}
```

**@RestController**

- @Controller는 반환값이 String이면 뷰 이름으로 인식됨. 따라서, **뷰를 찾고 뷰가 랜더링** 된다
- `@RestController`는 반환 값으로 뷰를 찾는 것이 아닌, **HTTP 메시지 바디에 바로 입력**됨. 따라서, 실행 결과로 ok 메세지를 받는다. @ResponseBody와 관련이 있음

<br>

**테스트**

- 로그가 출력되는 포맷 확인
    - 시간, 로그레벨, 프로세스ID, 쓰레드명, 클래스명, 로그 메시지
- 로그 레벨 설정을 변경해서 출력 결과 확인
    - LEVEL: TRACE > DEBUG > INFO > WARN > ERROR
    - 개발 서버는 `debug` 출력
    - 운영 서버는 `info` 출력
- @Slf4j로 변경: 다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자는 편리하게 log 라고 사용.
    
    ```java
    private static final org.slf4j.Logger log = 
    org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class);
    ```

<br>

**로그레벨 설정**

application.properties

```
#전체 로그 레벨 설정(기본 info(debug))
logging.level.root=info

#hello.springmvc 패키지와 그 하위 로그 레벨 설정
logging.level.hello.springmvc=debug
```

<br>

**올바른 로그 사용법**

- log.debug(”data=”+data)
    - 로그 출력 레벨을 info로 설정해도 해당 코드에 있는 “data=”+data가 실행되어버림 (메모리 사용, cpu사용)
- `log.debug(”data={}”, data)`
    - 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않음. 따라서, 앞과 같은 의미없는 연산이 발생하지 않는다

<br>

**로그 사용시 장점**

- 쓰레드 정보, 클래스 이름 같은 부가 정보를 볼 수 있고, 출력 모양을 조정할 수 있음
- 개발 서버와 운영 서버 각각 상황에 맞게 로그 레벨을 조절할 수 있음 → **설정파일**을 통해
- 시스템 아웃 콘솔에만 출력하는 것이 아닌 파일, 네트워크 등 로그를 별도의 위치에 남길 수 있음. 특히, 파일로 남길 때 일별, 특정 용량에 따라 로그 분할 가능함
- 성능도 System.out 보다 좋음. (내부 버퍼링, 멀티 쓰레드 등) 실무에서는 꼭 `로그`를 사용!

<br>

## 2. 요청 매핑

<br>

```java
package hello.springmvc.basic.requestmapping;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MappingController {

    private Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/hello-basic")
    public String helloBasic() {
        log.info("helloBasic");
        return "ok";
    }
}
```

**@RestController**

- 반환값으로 뷰를 찾는 것이 아닌 HTTP 메시지 바디에 바로 입력함

<br>

**@RequestMapping(”/hello-basic”)**

- /hello-basic URL 호출이 오면 이 메서드가 실행되도록 매핑함
- 대부분의 속성을 배열[]로 제공. 다중 설정 가능 ({”/hello-basic”, “/hello-go”})

<br>

**둘다 허용**

다음 두가지 요청은 다른 URL이지만, 스프링은 같은 요청으로 매핑함

- 매핑: /hello-basic
- URL 요청: /hello-basic, /hello-basic/

<br>

**HTTP 메서드**

@RequestMapping에 method 속성으로 HTTP 메서드를 지정하지 않으면 모두 허용 됨 (GET, POST, PUT, PATCH, DELETE)

<br>

**HTTP 메서드 매핑**

```java
@RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
```

여기에 POST 요청을 하면 스프링 MVC는 HTTP 405 상태코드(Method Not Allowed)를 반환

<br>

**HTTP 메서드 매핑 축약**

```java
/**
 * 편리한 축약 애노테이션
 * @GetMapping
 * @PostMapping
 * @PutMapping
 * @DeleteMapping
 * @PatchMapping
 */
@GetMapping(value = "/mapping-get-v2")
```

HTTP 메서드를 축약한 애노테이션이 더 **직관적**

<br>

**PathVariable(경로 변수) 사용**

```java
/**
 * PathVariable 사용
 * 변수명이 같으면 생략 가능
 * @PathVariable("userId") String userId -> @PathVariable userId
 * /mapping/userA
 */
@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data) {}
```

최근 HTTP API는 **리소스 경로에 식별자를 넣는 스타일**을 선호

- /mapping/userA
- /users/1
- @RequestMapping은 URL 경로를 템플릿화 할 수 있음. @PathVariable을 사용하면 매칭 되는 부분을 편리하게 조회 가능
- @PathVariable의 이름과 파라미터 이름이 같으면 생략 가능
    
    ```java
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable String userId) {}
    ```
    
- PathVariable 다중 사용도 가능
    
    ```java
    @GetMapping("/mapping/users/{userId}/orders/{orderId}")
    public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {}
    ```
    
<br>

**특정 파라미터 조건 매핑**

특정 파라미터가 있어야 조회할 수 있음

- 가능: /mapping-param?mode=debug
- 불가능: /mapping-param → 400 Error(Bad Request)

```java
/**
 * 파라미터로 추가 매핑
 * params="mode",
 * params="!mode"
 * params="mode=debug"
 * params="mode!=debug" (! = )
 * params = {"mode=debug","data=good"}
 */
@GetMapping(value = "/mapping-param", params = "mode=debug")
```

<br>

**특정 헤더 조건 매핑**

```java
/**
 * 특정 헤더로 추가 매핑
 * headers="mode",
 * headers="!mode"
 * headers="mode=debug"
 * headers="mode!=debug" (! = )
 */
@GetMapping(value = "/mapping-header", headers = "mode=debug")
```

파라미터 매핑과 비슷, HTTP 헤더를 사용

<br>

**미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume**

```java
/**
 * Content-Type 헤더 기반 추가 매핑 Media Type
 * consumes="application/json"
 * consumes="!application/json"
 * consumes="application/*"
 * consumes="*\/*"
 * MediaType.APPLICATION_JSON_VALUE
 */
@PostMapping(value = "/mapping-consume", consumes = "application/json")
```

HTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑

만약, 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type)를 반환

<br>

예시) consumes

```
consumes = "text/plain"
consumes = {"text/plain", "application/*"}
consumes = MediaType.TEXT_PLAIN_VALUE
```

<br>

**미디어 타입 조건 매핑 - HTTP 요청 Accept, produce**

```java
/**
 * Accept 헤더 기반 Media Type
 * produces = "text/html"
 * produces = "!text/html"
 * produces = "text/*"
 * produces = "*\/*"
 */
@PostMapping(value = "/mapping-produce", produces = "text/html")
```

HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑

만약, 맞지 않으면 HTTP 406 상태코드(Not Acceptable) 반환

<br>

예시) produce

```
produces = "text/plain"
produces = {"text/plain", "application/*"}
produces = MediaType.TEXT_PLAIN_VALUE
produces = "text/plain;charset=UTF-8"
```

<br>

> **참고**
Accept: Client가 지정된 Content-Type만 받아들일 수 있게 함
>

<br>

## 3. 요청 매핑 - API 예시

회원 관리 HTTP API 만들어보자 (실제 데이터가 넘어가는 부분은 생략하고 URL 매핑만 구현)

<br>

**회원 관리 API**

- 회원 목록 조회: GET /user
- 회원 등록: POST /user
- 회원 조회: GET /user/{userId}
- 회원 수정: PATCH /user/{userId}
- 회원 삭제: DELETE /user/{userId}

<br>

```java
package hello.springmvc.basic.requestmapping;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    @GetMapping
    public String user() {
        return "get users";
    }

    @PostMapping
    public String addUser() {
        return "post user";
    }

    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId=" + userId;
    }

    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId=" + userId;
    }

    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId=" + userId;
    }
}
```

**@RequestMapping("/mapping/users")**

클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용

<br>

## 4. HTTP 요청 - 기본, 헤더 조회

HTTP 헤더 정보를 조회하는 방법

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpMethod;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

@Slf4j
@RestController
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie", required = false) String cookie) {

        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);

        return "ok";
    }
}
```

**HttpMethod**: HTTP 메서드를 조회

<br>

**Locale**: Locale(지역)정보를 조회

<br>

**@RequestHeader MultiValueMap<String, String> headerMap**

모든 HTTP 헤더를 MultiValueMap 형식으로 조회

<br>

**@RequestHeader("host") String host**

특정 HTTP 헤더를 조회

속성

- 필수 값 여부: required
- 기본 값 속성: defaultValue

<br>

**@CookieValue(value = "myCookie", required = false) String cookie**

특정 쿠키를 조회

<br>

**MultiValueMap**

- Map과 유사, 하나의 키에 여러 값을 받을 수 있음
- HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용
    - keyA=value1&keyA=value2
    
    ```java
    MultiValueMap<String, String> map = new LinkedMultiValueMap();
    map.add("keyA", "value1");
    map.add("keyA", "value2");
    
    //[value1,value2]
    List<String> values = map.get("keyA");
    ```
    
<br>

> **참고**
> 
> 
> @Conroller 의 사용 가능한 파라미터 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
> [https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments)
> 
> @Conroller 의 사용 가능한 응답 값 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
> [https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types)
> 

<br>

## 5. HTTP 요청 파라미터

클라이언트에서 서버로 요청 데이터를 전달할 때 3가지 방법을 사용

1. `GET - 쿼리 파라미터`
    - /url?username=hello&age=20
    - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
    - 예) 검색, 필터, 페이징 등에서 많이 사용하는 방식
2. `POST - HTML Form`
    - content-type: application/x-www-form-urlencoded
    - 메시지 바디에 쿼리 파라미터 형식으로 전달 (username=hello&age=20)
    - 예) 회원 가입, 상품 주문, HTML Form 사용
3. `HTTP message body`에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT PATCH

<br>

### 5.1 쿼리 파라미터, HTML Form

HttpServletRequest의 request.getParameter()를 사용하면 다음 두가지 요청 파라미터를 조회할 수 있음

<br>

**GET, 쿼리 파라미터 전송**

예시) http://localhost:8080/request-param?username=hello&age=20

<br>

**POST, HTML Form 전송**

예시) 

```
POST /request-param ...
content-type: application/x-www-form-urlencoded

username=hello&age=20
```

<br>

GET 쿼리 파라미터 전송 방식과 POST HTML Form 전송 방식은 둘다 형식이 같으므로 구분없이 조회할 수 있음. 이것을 요청 파라미터(request parameter) 조회라 함

<br>

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {

    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username={}, age={}", username, age);

        response.getWriter().write("ok");
    }
}
```

**request.getParameter()**

HttpServletRequest가 제공하는 방식으로 요청 파라미터를 조회

<br>

> **참고**
리소스는 /resources/static 아래에 두면 스프링 부트가 자동으로 인식

Jar를 사용하면 webapp 경로를 사용할 수 없다.
> 

<br>

### 5.2 @RequestParam

스프링이 제공하는 `@RequestParam`을 사용하면 요청 파라미터를 편리하게 사용할 수 있음

<br>

```java
@ResponseBody
@RequestMapping("/request-param-v2")
public String requestParamV2(@RequestParam("username") String memberName, 
                             @RequestParam("age") int memberAge) {
    log.info("username={}, age={}", memberName, memberAge);
    return "ok";
}
```

**@RequestParam**

파라미터 이름으로 바인딩

<br>

**@ResponseBody**

View 조회를 무시, HTTP message body에 직접 해당 내용 입력

(다른 방법으로는 @RestController를 사용하는 방법도 있음)

<br>

`@RequestParam`의 **name(value) 속성**이 파라미터 이름으로 사용

<br>

```java
//@RequestParam("username") String memberName
//@RequestParam("age") int memberAge

@RequestParam String username
@RequestParam int age
```

<br>

HTTP 파라미터 이름이 변수 이름과 같으면 name 속성 생략 가능

```java
//@RequestParam String memberName
//@RequestParam int memberAge

String username
int age
```

String, int, Integer 등의 단순 타입은 @RequestParam 생략 가능

<br>

> **주의**
@RequestParam 애노테이션을 생략하면 스프링 MVC 내부에서 required=false를 적용
> 

<br>

**파라미터 필수 여부 - requestParamRequired**

```java
@ResponseBody
@RequestMapping("/request-param-required")
public String requestParamRequired(@RequestParam(required = true) String username,
                                   @RequestParam(required = false) Integer age) {
    log.info("username={}, age={}", username, age);
    return "ok";
}
```

**@RequestParam.required**

- 파라미터 필수 여부
- 기본값이 파라미터 필수(true)

**/request-param 요청**

- username이 없으므로 400 Error 발생

<br>

> **주의**
파라미터 이름만 사용
- /request-param?username= ⇒ ‘’ (빈문자열)
- 파라미터 이름만 있고 값이 없는 경우 → 빈문자로 통과
- /request-param ⇒ null
> 

<br>

> **주의**
기본형(primitive)에 null 입력 
- /request-param 요청
- @RequestParam(required = false) int age
null을 int에 입력하는 것은 불가능(500 예외 발생)
따라서, null을 받을 수 있는 Integer로 변경하거나, defaultValue 사용
> 

<br>

int는 기본형이기 때문에 null이 들어갈 수 없고, Integer는 객체형이기 때문에 null을 받을 수 있음

<br>

**기본 값 적용 - requestParamDefault**

```java
@ResponseBody
@RequestMapping("/request-param-default")
public String requestParamDefault(@RequestParam(required = true, defaultValue = "guest") String username,
                                  @RequestParam(required = false, defaultValue = "-1") int age) {
    log.info("username={}, age={}", username, age);
    return "ok";
}
```

파라미터에 값이 없는 경우 `defaultValue`를 사용해 기본 값을 적용할 수 있음 (기본 값이 있으면 required는 의미가 없어짐)

defaultValue는 빈 문자의 경우에도 설정한 기본 값이 적용됨

<br>

**파라미터를 Map으로 조회하기 - requestParamMap**

```java
@ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
        log.info("username={}, age={}", paramMap.get("username"), paramMap.get("age"));
        return "ok";
    }
```

파라미터를 Map, MultiValueMap으로 조회 가능

- @RequestParam Map ,
Map(key=value)
- @RequestParam MultiValueMap
MultiValueMap(key=[value1, value2, ...] ex) (key=userIds, value=[id1, id2])

<br>

파라미터의 값이 1개가 확실하면 Map, 그렇지 않다면 MultiValueMap 사용