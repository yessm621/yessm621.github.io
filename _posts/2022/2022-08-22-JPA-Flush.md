---
layout: post
title: "플러시"
date: 2022-08-22 23:40:00
categories: [JPA]
tags:
  - JPA
author: "유자"
---

영속성 컨텍스트의 **변경내용**을 데이터베이스에 반영, 트랜잭션 커밋 될 때 플러시가 발생한다.

## 플러시 발생

- 변경 감지
- 수정된 엔티티 **쓰기 지연 SQL 저장소**에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)

## 영속성 컨텍스트를 플러시하는 방법

> **참고** 
<br>
직접 플러시를 할일은 많이 없지만 테스트 시 사용하는 경우가 있기 때문에 알고는 있어야 한다.
> 

- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

```java
Member member = new Member(200L, "member200");
em.persist(member);
em.flush();

System.out.println("=============================");

tx.commit();
```

```
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
=============================
```

> **참고** flush()를 하게 되면 1차 캐시가 지워질까?
<br>
No! flush()는 단순히 쓰기 지연 SQL 저장소의 쿼리를 DB에 반영하는 역할만 한다.
> 

### JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유

```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

// 중간에 JPQL 실행
query = em.createQuery("select m from Member m", Member.class);
List<Member> members= query.getResultList();
```

persist()를 해도 데이터베이스에 insert 되는 시점은 트랜잭션 커밋 시점이므로 원래 같으면 JPQL로 조회 시 데이터가 조회되지 않는다. 이를 방지하기 위해 **JPA에서 JPQL 실행 시 자동으로 flush()** 후 데이터를 가져오게 되어있다.

## 플러시 모드 옵션

- FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT: 커밋할 때만 플러시

```java
em.setFlushMode(FlushModeType.COMMIT);
```

## 정리

- 플러시는 영속성 컨텍스트를 비우지 않는다.
- 플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화(Insert) 해준다
- 트랜잭션이라는 작업 단위가 중요, 커밋 직전에만 동기화 하면 된다.