---
title: "체크 예외, 언체크 예외"
last_modified_at: 2022-10-11T15:00:00
categories:
  - Java
tags:
  - Java
toc: true
toc_label: "Index"
toc_sticky: true
---

## 예외의 종류

- 에러 (Error)
- 예외 (Exception)
    - 체크 예외 (Check Exception)
    - 언체크 예외 (Uncheck Exception)

![1](https://user-images.githubusercontent.com/79130276/195005057-a88cdf36-4676-4547-9e3b-2a13a43fe6b9.png)

## 에러(Error)

java.lang.Error 클래스의 하위 클래스들이다. 메모리 부족, 스택오버플로우 등과 같이 시스템이 비정상적인 상황인 경우에 사용한다. (프로그램 코드에 의해서 수습 될 수 없는 심각한 오류)

## 예외(Exception)

java.lang.Exception 클래스의 하위 클래스들이다. 개발자가 예외를 대비해 적절한 코드를 미리 작성하여 프로그램의 비정상적인 종료를 막을 수 있다. (프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류) 


예외는 체크 예외와 언체크 예외로 구분된다.

### 체크 예외(Check Exception)

`체크 예외`는 RuntimeException 클래스를 상속받지 않는 예외 클래스들이다. 체크 예외는 복구가 가능한 예외이므로 **반드시 예외를 처리하는 코드를 함께 작성**해야 한다. 예외를 처리하기 위해서는 catch 문으로 잡거나 throws로 예외를 자신을 호출한 클래스로 던지는 방법이 있다. 만약, 예외를 처리하지 않으면 컴파일 에러가 발생한다.

예) IOException, SQLException 등

체크 예외는 개발자가 실수로 예외 처리를 누락하지 않도록 컴파일러가 도와준다. 하지만 개발자가 모든 체크 예외를 처리해주어야 하므로 번거롭고 신경쓰지 않고 싶은 예외까지 처리해야 한다는 단점이 있다.

또한 실제 애플리케이션 개발에서 발생하는 예외들은 복구 불가능한 경우가 많다. 예를 들어 SQLException과 같은 체크 예외를 catch해도 쿼리를 수정하여 재배포하지 않는 이상 복구되지 않는다. 그래서 실제 개발에서는 대부분 **언체크 예외를 사용**한다.

### 언체크 예외(Uncheck Exception)

RuntimeException 클래스를 상속받는 예외 클래스들은 복구 가능성이 없는 예외들이므로 컴파일러가 예외처리를 강제하지 않음. 그래서 `언체크 예외`라고 불린다. 언체크 예외는 에러(Error)와 마찬가지로 에러를 처리하지 않아도 **컴파일 에러가 발생하지 않는다**. 즉, 런타임 예외는 예상치 못했던 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않는다.

예) NullPointerException, IllegalArgumentException 등

언체크 예외는 신경쓰고 싶지 않은 예외들을 모두 생략할 수 있다. 이러한 점 때문에 상당히 편리하지만 컴파일러가 예외를 잡아주지 않으므로 개발자가 실수로 예외를 누락할 수 있다는 단점이 있다.

체크 예외와 언체크 예외의 차이를 아는 것은 매우 중요하다. 왜냐하면 스프링 프레임워크가 제공하는 `선언적 트랜잭션(@Transactional)` 안에서 에러 발생 시 **체크 예외는 롤백이 되지 않고 언체크 예외는 롤백이 되기 때문**이다.

(참고로 이 부분은 자바 언어와는 무관하게 스프링 자체의 기능이다.)