---
title:  "트리와 이진트리, B-Tree와 B+Tree"
categories:
  - Etc
tags:
  - CS
toc: true
toc_sticky: true
---

## 개요

데이터베이스 **인덱스(Index)**를 구현할 때 대표적으로 해시 테이블과 B+Tree 자료구조를 많이 사용한다. 그 중에서도 `B+Tree`를 주로 사용한다. 이번 포스트는 B+Tree 자료구조에 대해 정리하려고 한다.

B-Tree, B+Tree를 이해하기 위해 필요한 기본적인 트리, 이진 탐색 트리(BST)의 개념을 알아본 후 B-Tree, B+Tree 개념을 정리하려고 한다.

## 트리 (Tree)

트리는 자료 구조 중 비선형 자료 구조에 속한다. 비선형 자료 구조는 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말한다.

### 트리의 구성

트리는 노드와 간선으로 이루어져 있다.

![스크린샷 2024-08-31 오후 8 02 23](https://github.com/user-attachments/assets/28fa8a9e-dd32-4d0e-bd68-6c0c97fe5f30)

- 루트 노드: 가장 위에 있는 노드
- 내부 노드(internal 노드): 루트 노드와 내부 노드 사이에 있는 노드
- 리프 노드(leaf 노드): 자식 노드가 없는 노드

### 트리 특징

- 부모, 자식 계층 구조를 가진다.
    - 예를 들어 위 그림에서 5 노드는 6 노드, 7 노드의 부모 노드이다.
- 간선 수 = 노드 수 - 1
- 임의의 두 노드 사이의 경로는 유일무이하게 존재한다. (반드시 존재한다는 뜻)

## 이진 탐색 트리(BST)

모든 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값들만 가지고 모든 노드의 오른쪽 서브트리는 해당 노드의 값보다 큰 값들만 가진다.

**이진 탐색 트리 예시**

![스크린샷 2024-08-31 오후 8 07 46](https://github.com/user-attachments/assets/9d9c765e-b900-462e-90ff-7912174e756d)

- 20 노드를 기준으로 왼쪽은 20보다 작은 노드들이 있고 오른쪽은 20보다 큰 노드들이 있다.
- 5 노드를 기준으로 보았을 때 왼쪽은 5보다 작은 노드가 있고 오른쪽은 5보다 큰 노드들이 있다.

### 이진 탐색 트리 특징

이진 탐색 트리는 자녀 노드를 최대 두개까지 가질 수 있다는 특징이 있다.

그렇다면 자녀 노드를 두개 보다 더 많이 가지고 싶을 땐 어떻게 해야할까? 이때 사용할 수 있는게 `B tree`이다.


## B tree가 등장한 이유

![스크린샷 2024-08-31 오후 11 58 12](https://github.com/user-attachments/assets/44827e98-13d4-4a4b-b601-348872f0b0ec)

- 위 그림에서 왼쪽이 이진 탐색 트리를 나타낸다.
- 이진 탐색 트리는 부모 노드를 기준으로 왼쪽은 부모 노드보다 작은 값을 가지고 있고 오른쪽은 부모 노드보다 큰 값을 가지고 있다.
- 이렇게 이진 탐색 트리의 원리를 가지고 자녀 노드가 3개일 때를 구현해보자.
- 자녀 노드가 3개일 때 각각의 자녀 노드가 가질 수 있는 값의 범위를 정해주는 것이다.
    - 왼쪽 노드는 k1보다 작고, 가운데 노드는 k1과 k2 중간 값을 가지고 오른쪽 노드는 k2보다 큰 값을 가진다.
- 이렇게 하려면 k1 값과 k2 값이 필요하다.

![스크린샷 2024-08-31 오후 11 58 23](https://github.com/user-attachments/assets/e051dcc1-c3eb-4579-8ade-8f296aec0bf7)

- 결국 부모 노드에 1개의 값만 저장하는 것이 아닌 k1 값과 k2 값을 모두 저장해야 한다.
- 이렇게 하면 이진 탐색 트리와 동일한 형태로 동작을 하면서도 하나의 노드가 2개 이상의 노드도 가질 수 있게 된다.

즉, B tree는 이진 탐색 트리가 자식 노드를 2개 이상 둘 수 없는 한계를 극복하고자 등장했다.

## B tree

B-Tree는 이진 탐색 트리를 일반화한 트리이다. 일반적인 이진 탐색 트리에서는 각 노드가 최대 두개의 자식 노드를 가지지만 B-Tree에서는 제약이 없어 여러 개의 자식 노드를 가질 수 있다.

### B tree 특징

- 자녀 노드의 최대 개수를 늘리기 위해서 부모 노드에 key를 하나 이상 저장한다.
- 부모 노드의 key들을 오름차순으로 정렬한다.
- 정렬된 순서에 따라 자녀 노드들의 key 값의 범위가 결정된다.
- 이런 방식을 사용하면 자녀 노드의 최대 개수를 입맛에 맞게 결정해서 쓸 수 있다.
- 때문에 **B tree는 BST를 일반화한 tree**라고도 한다.
- 최대 몇 개의 자녀 노드를 가질 것인지가 B tree를 사용할 때 중요한 파라미터이다.

### B tree의 4가지 파라미터

**최대 M개의 자녀를 가질 수 있는 B tree를 M차 B tree**라 부른다.

- 각 노드의 최대 자녀 노드 수: M
- 각 노드의 최대 key 수: M-1
- 각 노드의 최소 자녀 노드 수: [M/2] (소숫점은 올림) (root노드, leaf 노드 제외)
- 각 노드의 최소 key 수: [M/2]-1 (root 노드 제외)

일반적인 B tree는 internal 노드의 key 수가 x개라면 자녀 노드의 수는 언제나 x+1개라는 특징이 있다.

만약 아래 그림과 같은 트리가 있다면 이는 B tree가 아니다.

![스크린샷 2024-09-01 오전 12 35 18](https://github.com/user-attachments/assets/9ace42c5-8e8a-41a6-820b-14fad6f1ecf0)

- 부모 노드의 키가 2개이므로 자녀 노드의 수는 3개이어야 한다. 하지만 여기선 2개이므로 B tree가 아니다.

![스크린샷 2024-09-01 오전 12 35 25](https://github.com/user-attachments/assets/17e4030c-3fb0-426d-abaf-2e6b758a5872)

- 위 구조도 key는 1개 인데 자녀 노드가 3개이므로 B tree가 아니다.

일반적인 B tree가 아닌 M 차 B tree는 아래와 같이 계산 방법이 달라진다.

- M이 정해지면 root 노드를 제외하고 internal 노드는 최소 [M/2]개의 자녀 노드를 가질 수 있게 된다.
- 예) 5차 B tree 노드는 root 노드를 제외하고 internal 노드는 최소 3개의 자녀 노드를 가질 수 있게 된다.