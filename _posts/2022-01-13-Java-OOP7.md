---
title:  "객체지향개념(다형성, 참조변수의 형변환, instanceof연산자)"
last_modified_at: 2022-01-16T17:34:00
categories: 
  - Java
tags:
  - Java
toc: true
toc_label: "Getting Started"
toc_sticky: true
---

# 5.다형성(polymorphism)

## 5.1 다형성이란?

- 여러가지 형태를 가질 수 있는 능력
- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것(조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다)

```java
class Tv {
	boolean power;
	int channel;

	void power() { power = !power; }
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}

class SmartTv extends Tv {
	String text; // 캡션(자막)을 보여 주기 위한 문자열
	void caption() { /* 내용생략 */ }
}
```

Tv: 부모(멤버변수 5개), SmartTv: 자식(멤버변수 7개)

<br>

원래는 아래와 같이 사용했는데, 

Tv t = new Tv();

SmartTv s = new SmartTv();

<br>

다형성은 아래와 같이 사용

`Tv t = new SmartTv();` // 타입 불규칙, 사용 가능!

<br>

객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?

```java
SmartTv s = new SmartTv(); // 참조 변수와 인스턴스의 타입이 일치
// -> 멤버가 7개이므로 7개의 기능이 있다
Tv t = new SmartTv(); // 조상 타입 참조변수로 자손 타입 인스턴스 참조
// -> 멤버가 5개이므로 5개의 기능을 쓸 수 있다.
// (자손에 7개의 기능이 있지만 버튼이 5개밖에 없으므로 5개의 기능만 쓸 수 있음)
```

부모는 자식에 비해 멤버가 같거나 적을 수 밖에 없다

<br>

잉? 멤버를 7개 쓸 수 있다가 5개 쓸 수 있는게 장점인가요?

→ 장점이 될 수 있다.

<br>

- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
    
    ```java
    Tv t = new SmartTv(); // 허용
    SmartTv s = new Tv(); // 에러
    ```
    
    기능이 7개인데 5개만 쓰는건 ok
    
    기능이 5개인데 7개를 쓸 수 없음 error!
    
<br>

Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?

→ 아니요. 일치하는 것이 보통이지만 일치 하지 않을 수도 있음.

Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?

→ 참조변수로 사용할 수 있는 멤버의 갯수가 달라짐

Q. 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?

→ 아니요. 허용되지 않음

<br>

## 5.2 참조변수의 형변환

- 사용할 수 있는 멤버의 갯수를 조절하는 것
- `조상 자손 관계의 참조변수는 서로 형변환 가능`

```
자손타입 -> 조상타입 : 형변환 생략가능
자손타입 <- 조상타입 : 형변환 생략불가
```

<br>

```java
class Car {}
class FireEngine extends Car {}
class Ambulance extends Car {}
```

Car 와 FireEngine 은 서로 형변환 가능

Car 와 Ambulance 는 서로 형변환 가능

FireEngine과 Ambulance는 서로 형변환 불가능! (둘 다 자식. 상속관계가 아니기 때문에)

<br>

```java
FireEngine f = new FireEngine();

Car c = (Car)f; // OK. 조상인 Car타입으로 형변환(생략가능)
FireEngine f2 = (FireEngine)c; // OK. 자손인 FireEngine타입으로 형변환(생략불가)
Ambulance a = (Ambulance)f; // 에러. 상속관계가 아닌 클래스 간의 형변환 불가
```

```java
class Car {
	String color;
	int door;

	void drive() {
		System.out.println("drive, Brrrr~");
	}

	void stop() {
		System.out.println("stop!");
	}
}

class FireEngine extends Car {
	void water() {
		System.out.println("water!!");
	}
}
```

부모 멤버변수 4개 + 자식 멤버변수 1개 ⇒ 총 5개!

f 는 5개의 멤버변수에 접근 가능

c는 4개의 멤버변수에만 접근 가능(타입이 Car이기 때문에 리모컨 버튼이 4개 밖에 없음)

f2는 5개의 멤버변수에 접근 가능

a와 f는 둘 다 자식이므로 서로 형변환 불가능함 따라서, 에러 발생!

<br>

```java
class Car {
	String color;
	int door;

	void drive() {
		System.out.println("drive, Brrrr~");
	}

	void stop() {
		System.out.println("stop!");
	}
}

class FireEngine extends Car {
	void water() {
		System.out.println("water!!");
	}
}
```

```java
class Ex7_7 {
	public static void main(String[] args) {
		Car car = null;
		FireEngine fe = new FireEngine();
		FireEngine fe2 = null;

		fe.water();
		car = fe; // car = (Car)fe;에서 형변환이 생략됨
		// car.water(); // 컴파일 에러! Car타입의 참조변수로는 water()를 호출할 수 없다.
		fe2 = (FireEngine)car; // 자손타입 <- 조상타입. 형변환 생략 불가
		fe2.water();
	}
}
```

Car는 water()라는 멤버변수가 없다. 따라서 에러 발생한다

5개 → 4개 감소 안전. 생략가능

4개 → 5개 증가 안전하지 않음. 생략불가

<br>

예제1

```java
class Ex7_7 {
	public static void main(String args[]) {
		Car car = null;
		FireEngine fe = new FireEngine();
		FireEngine fe2 = null;

		fe.water();
		car = fe;    // car = (Car)fe;에서 형변환이 생략됨
//		car.water(); // 에러. Car타입의 참조변수인 car로는 water()를 사용불가.
		fe2 = (FireEngine)car; // 자손타입 ← 조상타입. 형변환 생략 불가
		fe2.water();
	}
}

class Car {
	String color;
	int door;

	void drive() { 	// 운전하는 기능
		System.out.println("drive, Brrrr~");
	}

	void stop() {  	// 멈추는 기능	
		System.out.println("stop!!!");	
	}
}

class FireEngine extends Car {	// 소방차
	void water() {	// 물을 뿌리는 기능
		System.out.println("water!!!");
	}
}
```

car.water();

→ Car 에는 water()가 없어서 오류 발생함

<br>

예제2

```java
class Ex7_7 {
	public static void main(String args[]) {
		Car car = null;
		FireEngine fe = null;

		FireEngine fe2 = (FireEngine)car; // 조상 -> 자손으로 형변환
		Car car2 = (Car)fe2; // 자손 -> 조상으로 형변환

		car2.drive(); // 에러. NullPointException 발생.
	}
}

class Car {
	String color;
	int door;

	void drive() { 	// 운전하는 기능
		System.out.println("drive, Brrrr~");
	}

	void stop() {  	// 멈추는 기능	
		System.out.println("stop!!!");	
	}
}

class FireEngine extends Car {	// 소방차
	void water() {	// 물을 뿌리는 기능
		System.out.println("water!!!");
	}
}
```

fe, car2 모두 null!

형 변환 할때 중요한건 `실제 인스턴스가 무엇인지`가 중요하다.

<br>

예제3

```java
class Ex7_7 {
	public static void main(String args[]) {
		Car car = new Car();
		FireEngine fe = (FireEngine)c; // 형변환 실행 에러. java.lang.ClassCastException
		fe.water();
	}
}

class Car {
	String color;
	int door;

	void drive() { 	// 운전하는 기능
		System.out.println("drive, Brrrr~");
	}

	void stop() {  	// 멈추는 기능	
		System.out.println("stop!!!");	
	}
}

class FireEngine extends Car {	// 소방차
	void water() {	// 물을 뿌리는 기능
		System.out.println("water!!!");
	}
}
```

컴파일은 통과, 그러나 실행 중 형변환 오류 발생함

→ 실제 인스턴스는 Car 이고 Car에는 water()가 없음. 따라서, 에러 발생!

<br>

**결론**

`참조변수가 가리키는 실제 인스턴스가 뭔지 확인하고 그 멤버의 갯수를 확인!`

<br>

## 5.3 instanceof연산자

- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인해야 함
    1. 확인. 형변환 해도 되는지: instanceof
    2. 형변환

<br>

```java
void doWork(Car c) {
	if (c instanceof FireEngine) { // 1. 형변환이 가능한지 확인
		FireEngine fe = (FireEngine)c; // 2. 형변환
		fe.water();
		// ...
	} else if (c instanceof Ambulance) {
		Ambulance a = (Ambulance)c;
		a.siren();
		// ...
	}
}
```

doWork(Car c)

→ doWork(new Car())

→ doWork(new  FireEngine())

→ doWork(new Ambulance())

위의 3문장 모두 가능

<br>

```java
FireEngine fe = new FireEngine();

System.out.println(fe instanceof Object);    // true
System.out.println(fe instanceof Car);       // true
System.out.println(fe instanceof FireEngine);// true
```

모두 true를 반환하는 이유는 FireEngine클래스는 Object클래스와 Car클래스의 자손 클래스이므로 조상의 멤버들을 상속받았기 때문에!

```
어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
```

<br>

Q. 참조변수의 형변환은 왜 하나요?

참조변수(리모콘)을 변경함으로써 사용할 수 있는 `멤버의 갯수를 조절`하기 위해서

Q. instanceof연산자는 언제 사용하나요?

참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때