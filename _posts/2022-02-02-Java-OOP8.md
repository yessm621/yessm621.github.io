---
title:  "객체지향개념(추상클래스, 추상메서드, 추상클래스의 작성)"
last_modified_at: 2022-02-03T13:26:00
categories: 
  - Java
tags:
  - Java
toc: true
toc_label: "Getting Started"
toc_sticky: true
---

# 6. 추상 클래스(abstract class)

## 6.1 추상클래스란?

- 미완성(부족한) 설계도. 미완성 메서드를 갖고 있는 클래스

```java
abstract class Player { // 추상클래스(미완성 클래스)
	abstract void play(int pos); // 추상메서드(몸통{}이 없는 미완성 메서드)
	abstract void stop(); // 추상메서드
}
```

<br>

클래스 또는 메서드 앞에 `abstract` 를 붙이면 추상 클래스 또는 추상 메서드인 것을 알 수 있다.

<br>

- 다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가.

```java
Player p = new Player(); // 에러. 추상 클래스의 인스턴스 생성 불가
```

<br>

- 상속을 통해 추상 메서드를 완성해야 인스턴스 생성가능

```java
class AudioPlayer extends Player {
	void play(int pos) { /* 내용 생략 */ } // 추상 메서드 구현
	void stop() { /* 내용 생략 */ } // 추상 메서드 구현(구현이란 추상 메서드 몸통 만들기)
}

AudioPlayer ap = new AudioPlayer(); // OK. 인스턴스 생성됨
Player ap = new AudioPlayer(); // 다형성 (Plyer = 부모, AudioPlayer **= 자손**)
```

<br>

## 6.2 추상 메서드(abstract method)

- 미완성 메서드. 구현부(몸통, {})가 없는 메서드

```java
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
abstract 리턴타입 메서드이름();
```

<br>

`미완성 메서드를 사용하는 이유?`

메서드의 내용이 상속받는 클래스에 따라 달라질 수 있음. 

따라서, 조상 클래스 → 선언부 + 주석 작성(어떤 기능을 수행할지)

실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것.

<br>

- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우 추상 메서드를 사용한다

```java
abstract class Player {
	abstract void play(int pos); // 추상메서드
	abstract void stop(); // 추상메서드
}

class AudioPlayer extends Player {
	void play(int pos) { /* 내용 생략 */ } // 추상메서드를 구현
	void stop() { /* 내용 생략 */ } // 추상메서드를 구현
}

// 아래는 일부만 구현. 따라서, 미완성이기 때문에 추상메서드가 있다는걸 알려주기 위해 abstract 붙임
abstract class AbstractPlayer extends Player {
	void play(int pos) { /* 내용 생략 */ } // 추상메서드 구현
	// abstract void stop(); // 이게 있는거.
}
```

<br>

- 추상 메서드 호출 가능 (호출할 때는 선언부만 필요)

```java
abstract class Player {
	boolean pause; // iv
	int currentPos; // iv

	Player() { // 추상 클래스도 생성자가 있어야 한다.
		pause = false;
		currentPos = 0;
	}

	abstract void play(int pos); // 추상메서드
	abstract void stop(); // 추상메서드

	void play() {
		// 호출
		play(currentPos); // 추상메서드를 사용할 수 있다.
	}
}
```

<br>

추상클래스는 일반 클래스와 똑같다(지역변수, 생성자 등). 단지, `추상메서드가 포함`되었을 뿐!

<br>

추상메서드를 호출하면 오류나는거 아닌가?

→ 오류 발생하지 않음!

1. 상속을 통해서 자손이 완성
2. 자손 객체 생성

<br>

### 6.2.1 추상으로 만드는 이유!

강요하기 위해서! `abstract` 를 사용하면 나중에 `구현부를 작성해야 한다`는 사실을 인식하여 자신의클래스에 맞게 구현할 것이다.

<br>

## 6.3 추상클래스의 작성

<br>

추상클래스 = 미완성 설계도(미완성 메서드 포함)

추상메서드 = 미완성 메서드 = 몸통 없는 메서드

<br>

- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.

<br>

기존 코드

```java
class Marine {
	int x, y; // 현재 위치
	void move(int x, int y) { /* 지정된 위치로 이동 */ }
	void stop() { /* 현재 위치에 정지 */ }
	void stimPack() { /* 스팀팩을 사용 */ }
}

class Tank {
	int x, y; // 현재 위치
	void move(int x, int y) { /* 지정된 위치로 이동 */ }
	void stop() { /* 현재 위치에 정지 */ }
	void changeMode() { /* 공격모드를 변환 */ }
}

class Dropship {
	int x, y; // 현재 위치
	void move(int x, int y) { /* 지정된 위치로 이동 */ }
	void stop() { /* 현재 위치에 정지 */ }
	void load() { /* 선택된 대상을 태운다 */ }
	void unload() { /* 선택된 대상을 내린다 */ }
}
```

<br>

**추상클래스**를 적용한 코드: `공통 부분을 추출`, 코드의 중복을 제거

```java
abstract class Unit {
	int x, y;
	abstract void move(int x, int y);
	void stop() { /* 현재 위치에 정지 */ }
}

class Marine extends Unit {
	void move(int x, int y) { /* 지정된 위치로 이동 */ };
	void stimPack() { /* 스팀팩을 사용 */ };
}

class Tank extends Unit {
	void move(int x, int y) { /* 지정된 위치로 이동 */ };
	void changeMode() { /* 공격모드를 변환 */ };
}

class Dropship extends Unit {
	void move(int x, int y) { /* 지정된 위치로 이동 */ };
	void load() { /* 선택된 대상을 태운다 */ };
	void unload() { /* 선택된 대상을 내린다 */ };
}
```

**abstract void move(int x, int y);** 대신 abstract 없애고  **void move(int x, int y) { };** 작성할 수도 있다. 그러나, abstract를 사용하지 않으면 move가 구현되어있다고 생각하고 구현을 안할 수도 있다. 따라서, 직관적으로 `abstract`를 붙이는게 좋다.

<br>

**정상 코드: 다형성의 장점도 나옴**

```java
// 아래 코드는 그 다음 4줄의 코드와 같다.
// Unit[] group = { new Marine(), new Tank(), new Dropship() };
Unit[] group = new Unit[3];
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Dropship();

for(int i=0; i<group.length; i++) {
	group[i].move(100, 200); // 추상메서드를 호출하는 것이 아니라 각자 구현된 메서드를 호출
}

// group의 타입은 Unit[] / group[0], group[1], group[2]의 타입은 Unit
// group[0], group[1], group[2]: 참조변수(리모콘)
group[0].move(100, 200); // Marine객체의 move 호출
group[1].move(100, 200); // Tank객체의 move 호출
group[2].move(100, 200); // Dropship객체의 move 호출
```

![Unit](https://user-images.githubusercontent.com/79130276/152271796-d7559419-4c31-4cad-bd2e-06c12d12e7f3.JPG)

<br>

**오류 코드**

```java
Object[] group = new Object[3];
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Dropship();

for(int i=0; i<group.length; i++) {
	group[i].move(100, 200); // 에러 발생. Object클래스에는 move메서드가 없다
}
```

![Object](https://user-images.githubusercontent.com/79130276/152271788-a597c758-a7ef-4cee-ad44-902ac11df992.JPG)

<br>

### 6.3.1 추상화 ↔ 구체화

- 추상화된 코드는 구체화된 코드보다 유연하다. 변경에 유리

```java
GregorianCalendar cal = new GregorianCalendar(); // 구체적(분명, 명확)

Calendar cal = Calendar.getInstance(); // 추상적(불분명)
```

```java
public static Calendar getInstance(Locale aLocale) {
	// 지역에 따라 캘린더 다르게 가져옴
	return createCalendar(TimeZone.getDefault(), aLocale);
}
```