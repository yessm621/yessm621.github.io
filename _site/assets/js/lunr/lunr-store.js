var store = [{
        "title": "Django Setting",
        "excerpt":"Pipenv 를 이용하여 가상환경 Setting   pipenv 란?   → python 에서 사용하는 가상환경을 구성하는 방식 중 하나.   pipenv 를 사용하는 이유   → 프로젝트별로 다른 패키지를 사용하며, 같은 패키지를 사용하더라도 버전이 다른 경우가 있기 때문에 pipenv 로 가상환경을 만든다.   설치방법   → pipenv 를 설치하기 전에 python 을 설치 해야 함.   아래 부터는 os에 따라 설치 방법이 다릅니다.           window       python 이 설치 되었는지 확인                       cmd 창에서 python 을 검색                              위의 사진과 같이 나온다면 pipenv 를 설치할 준비 끝!       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # 프로젝트 생성 및 프로젝트로 진입  mkdir project  cd project   # pip 으로 pipenv 설치  pip install pipenv   # python 버전 확인  python --version   # python 3.6.8 에 해당하는 pipenv 설치  # 위에서 나온 버전을 아래에 써줍니다.  pipenv --python 3.6.8   # pipenv 가 설치되었는지 확인  pipenv   # 가상환경으로 들어감  pipenv shell   # 가상환경에서 나옴  exit                mac       맥은 기본적으로 python 이 설치 되어 있기 때문에 해당 과정은 skip 합니다.       1 2 3 4 5 6 7  brew install pipenv   pipenv   pipenv —three   pipenv shell                Django 설치   이제 장고를 설치하도록 하겠습니다.   pipenv install django    장고가 정상적으로 설치되었는지 확인   → django-admin    이제 서버 실행합니다!   아래와 같이 입력하면 기본 포트 8000으로 서버를 실행해주고   python manage.py runserver    다음과 같이 입력하면 포트를 지정해 줄 수 있습니다.   python manage.py runserver 8888    다음과 같이 화면이 나온다면 장고 기본 셋팅은 끝났습니다     ","categories": ["Django"],
        "tags": ["Django","Python"],
        "url": "/django/Django-Setting/",
        "teaser": ""
      },{
        "title": "Django, Nginx, Gunicorn Setting (CentOS)",
        "excerpt":"Python3 설치   yum 으로 python3 설치  1 yum install python3 -y   yum 으로 python3 을 설치하면 pip3 도 같이 설치됨   python3 를 입력. 아래와 같이 나오면 설치 완료      설치하고자 하는 프로젝트 경로에 가상환경 설치   1 2 3 /usr/local/thriller/thriller pip3 install virtualenv virtualenv venv   가상환경에 접속   1 source venv/bin/activate      가상환경에서 빠져나옴   1 deactivate          MySQL DataBase, 사용자 생성 및 권한 부여   mysql 에 접속      데이터베이스 생성   1 mysql&gt; CREATE DATABASE 데이터베이스명 default CHARACTER SET UTF8;   사용자 생성, 권한 부여   1 2 3 4 5 mysql&gt; CREATE USER '사용자명'@'localhost' IDENTIFIED BY '비밀번호';  mysql&gt; GRANT ALL PRIVILEGES on 데이터베이스명.* TO '사용자명'@'localhost' identified by '비밀번호'; mysql&gt; GRANT ALL PRIVILEGES on 데이터베이스명.* TO '사용자명'@'127.0.0.1' identified by '비밀번호'; mysql&gt; FLUSH PRIVILEGES;      데이터베이스, 사용자 삭제   1 2 mysql&gt; DROP DATABASE 데이터베이스명; mysql&gt; DROP USER 사용자명@SERVER명;   사용자 조회   1 2 3 4 5 6 7 8 9 10 11 12 13 mysql&gt; use mysql; Database changed mysql&gt; select host, user from user; +---------------+-----------+ | host          | user      | +---------------+-----------+ | 127.0.0.1     | thriller  | | 59.15.244.217 | thriller  | | localhost     | mysql.sys | | localhost     | root      | | localhost     | thriller  | +---------------+-----------+ 5 rows in set (0.00 sec)   다음 과정부터는 프로젝트 경로에 git으로 프로젝트를 받아왔다고 가정하고 진행합니다.        gunicorn 설정   gunicorn 설치 (가상환경 상태에서)   1 (venv) &gt; pip3 install gunicorn   mysql 연결   1 2 3 4 5 yum install mysql-devel  yum install python3-devel  (venv) pip install mysqlclient   테스트 구동   1 2 3 4 5 6 &gt; python manage.py runserver 0.0.0.0:8000 &gt; gunicorn --bind 0.0.0.0:8000 thriller.wsgi:application [2021-04-06 16:27:23 +0900] [9674] [INFO] Starting gunicorn 20.1.0 [2021-04-06 16:27:23 +0900] [9674] [INFO] Listening at: http://0.0.0.0:8000 (9674) [2021-04-06 16:27:23 +0900] [9674] [INFO] Using worker: sync [2021-04-06 16:27:23 +0900] [9677] [INFO] Booting worker with pid: 9677   구동이 잘되면 가상환경 빠져나온다   1 &gt; deactivate   1 2 3 4 5 6 &gt; mkdir /run/gunicorn  &gt; sudo chown youurUserName.yourGroup /run/gunicorn  # youurUserName =&gt; &gt; whoami # yourGroup =&gt; &gt; groups   vi /etc/systemd/system/gunicorn.service   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [Unit] Description=gunicorn daemon After=network.target  [Service] PIDFile=/run/gunicorn/pid User=root Group=root WorkingDirectory=/usr/local/thriller/thriller ExecStart=/usr/local/thriller/thriller/venv/bin/gunicorn \\         --pid /run/gunicorn/pid \\         --workers 2 \\         --bind unix:/run/gunicorn/gunicorn.sock \\         thriller.wsgi:application  ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s TERM $MAINPID  [Install] WantedBy=multi-user.target   수정 후 적용시 아래 명령어 입력   1 &gt; systemctl daemon-reload   1 2 3 systemctl start gunicorn # 서버 재부팅 시에도 자동으로 실행되게 systemctl enable gunicorn            Nginx 설정   /etc/nginx/conf.d 아래에 프로젝트 명에 해당하는 config 파일 생성   vi /etc/nginx/conf.d/thriller.conf   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 server {     listen 80;     server_name 112.175.88.124;      location /static {         alias /usr/local/thriller/staticfiles;     }      location / {         proxy_set_header Host $host;         proxy_set_header X-Real-IP $remote_addr;         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;         proxy_set_header X-Forwarded-Proto $scheme;         proxy_pass http://unix:/run/gunicorn/gunicorn.sock;     } }   nginx 재시작   1 nginx -s reload    설정 완료!😁  ","categories": ["Django"],
        "tags": ["Django","Python","Nginx","Gunicorn","CentOS"],
        "url": "/django/Django-Nginx-Gunicorn/",
        "teaser": ""
      },{
        "title": "Django Forms",
        "excerpt":"Django Form   장고에는 Model 클래스를 이용하여 Form 을 자동으로 생성하는 기능이 있다.   장고의 폼에는 is_valid() 라는 함수가 있다   is_valid() 란?   ⇒ 입력받은 폼에 대한 유효성을 검사   views.py  1 2 3 4 5 6 7 8 9 10 11 12 13 14 from django.views import View from django.shortcuts import render from . import forms  class LoginView(View):     def get(self, request):         form = forms.LoginForm(initial={\"email\": \"\"})         return render(request, \"users/login.html\", {\"form\": form})      def post(self, request):         form = forms.LoginForm(request.POST)         if form.is_valid():             print(form.cleaned_data)         return render(request, \"users/login.html\", {\"form\": form})       cleaned_data 란?   is_valid() 라는 함수를 이용하여 유효성 검사가 끝나고 그 값이 true 일때 각 값들은 cleaned_data 에 저장된다.   clean 으로 시작하는 메서드 들은 각각의 값들의 유효성을 검사할 수 있다.   forms.py  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django import forms from . import models  class LoginForm(forms.Form):      email = forms.EmailField()     password = forms.CharField(widget=forms.PasswordInput)      def clean_email(self):         email = self.cleaned_data.get(\"email\")         try:             models.User.objects.get(username=email)             return email         except models.User.DoesNotExist:             raise forms.ValidationError(\"User does not exist\")      def clean_password(self):         return \"lalal\"       django 에서 post 로 전송 시 csrf_token 을 붙여줘야 한다   login.html  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  {% extends 'base.html' %}  {% block page_title %}     Log In {% endblock page_title %}  {% block search-bar %} {% endblock search-bar %}  {% block content %}     &lt;form method=\"POST\" action=\"{% url 'users:login' %}\"&gt;         {% csrf_token %}         {{form.as_p}}         &lt;button&gt;Login&lt;/button&gt;     &lt;/form&gt; {% endblock content %}   ","categories": ["Django"],
        "tags": ["Django","Python"],
        "url": "/django/Django-Forms/",
        "teaser": ""
      },{
        "title": "Django User Settings",
        "excerpt":"AUTH_USER_MODEL 설정   장고에는 기본적으로 내장되어있는 AbstractUser 이 있다.   내장된 AbstractUser 를 사용할 수도 있지만 보통은 새롭게 정의해서 사용하기 때문에   아래 설정을 settings.py 파일에서 해준다.   → 아래 설정을 생략하면 장고의 기본적으로 세팅되어있는 user 모델과 혼동이 올 수 있음   1 AUTH_USER_MODEL = 'users.User'       LOGIN_URL, LOGIN_REDIRECT_URL 설정   Django 의  Login, Logout 메커니즘은           next 라는 변수를 먼저 찾음. 없다면,            login_redirect_url 을 찾는다. 없다면,            default 로 간다.       settings.py   1 2 LOGIN_URL = reverse_lazy('account:login') LOGIN_REDIRECT_URL = reverse_lazy('main:index')   next 를 사용했는데 login_redirect_url 를 설정할 필요가 있을까?   → yes!! 주소창에서 직접 들어가게 되면 next 변수가 없어서 default 로 가게 됨. 따라서 오류 발생  ","categories": ["Django"],
        "tags": ["Django","Python"],
        "url": "/django/Django-User-Settings/",
        "teaser": ""
      },{
        "title": "jekyll 로 fork 해온 git blog 테마, 잔디밭 안심어질 때",
        "excerpt":"현재상태   git blog 를 생성하면서 jekyll 테마를 fork 해서 내 repository 에 생성을 했었는데  잔디밭이 안심어지는 현상을 발견! (이왕이면 심어지면 좋으니까..)   아마 내 repository 가 아닌 다른 사람의 repository 에 push 되고 있는게 아닐까 생각..       해결방안      github 에 새로운 repository 를 생성 (new_blog)        기존에 있는 repository 를 bare clone 한다       1  git clone --bare https://github.com/user/old_blog.git                새로운 레파지토리로 mirror-push       1 2  cd old_blog.git  git push --mirror https://github.com/user/new_blog.git               git clone 옵션   –normal: commit 이력 모두 담고 있고, 기본 branch 로 설정된 소스코드가 working tree 에 존재   –bare: commit 이력만 담고 있다   –mirror: 일반적인 commit 이력뿐만 아니라 숨어있는 모든 이력들을 담고 있다  ","categories": ["Git"],
        "tags": ["Git","GitBlog","GitHub"],
        "url": "/git/Git-fork-gitblog/",
        "teaser": ""
      },{
        "title": "python3, pip3 Symbolic Link 설정",
        "excerpt":"현재상태   Linux 에는 기본적으로 Python2 버전이 설치된다.   CentOS 에서 Python3 버전을 설치했는데 python 을 입력할 경우 2.x  버전으로 인식한다.   매번 python3 으로 명령어를 입력하는게 불편하여 구글링 해보니 Symbolic Link 를 통해 해결할 수 있다고 한다.       해결방안   python3 설정  1 2 3 4 5 6 7 8 9 # 현재 심볼릭 링크 확인 ls -l /bin/python*  # lrwxrwxrwx. 1 root root     7 Mar 25 22:45 /bin/python -&gt; python2 # lrwxrwxrwx. 1 root root     9 Mar 25 22:45 /bin/python2 -&gt; python2.7 # -rwxr-xr-x. 1 root root  7216 Aug  7  2019 /bin/python2.7 # lrwxrwxrwx. 1 root root     9 Jul  7 18:13 /bin/python3 -&gt; python3.6 # -rwxr-xr-x. 2 root root 11328 Nov 17  2020 /bin/python3.6 # -rwxr-xr-x. 2 root root 11328 Nov 17  2020 /bin/python3.6m   1 2 3 4 5 6 7 8 # 기존의 심볼릭 링크 삭제 sudo unlink /bin/python  # 아래와 같이 심볼릭 링크를 걸어준다 sudo ln -s /bin/python3.6 /bin/python  # 확인 ls -l /bin/python*       pip3 설정  1 2 3 4 5 6 7 8 ls -l /bin/pip*  -rwxr-xr-x. 1 root root 407 Oct 14  2020 /bin/pip3 lrwxrwxrwx. 1 root root   9 Jul  7 18:13 /bin/pip-3 -&gt; ./pip-3.6 lrwxrwxrwx. 1 root root   8 Jul  7 18:13 /bin/pip-3.6 -&gt; ./pip3.6 -rwxr-xr-x. 1 root root 407 Oct 14  2020 /bin/pip3.6  ln -s /bin/pip3.6 /bin/pip      설정 후 python, pip 명령어를 입력하면 3 버전을 가리키는 것을 확인할 수 있다.  ","categories": ["Python"],
        "tags": ["Python","Linux"],
        "url": "/python/python3-pip3-symbolic-link/",
        "teaser": ""
      },{
        "title": "Optional 이란",
        "excerpt":"1. 기존의 null 처리   아래 코드는 값(주소) 이 있다면 문제가 없는 코드이다.   1 System.out.println(house.getAddress());       하지만, 값(주소) 이 없다면 NPE 가 발생 한다.   따라서, null 처리를 위해선 다음과 같이 코드를 작성하였다.   1 2 3 if (house.getAddress() != null) { \t\tSystem.out.println(house.getAddress()); }   if 문을 사용하면 null 처리를 할 수 있다.       위의 코드는 간단하여 보기에 좋지만 수 많은 null 처리를 진행하게 되면 코드가 지저분해진다.   이럴때 사용하는게 Optional 클래스다. (java8 부터 지원)       2. Optional 클래스   Optional 클래스를 사용하면 보다 나은 null 처리를 할 수 있고 NPE(Null Point Exception) 를 방지 할 수 있다.       3. Optional 에서 제공하는 메서드   3.1 Optional 객체 생성           Optional.of()       → value 가 null 인 경우 NPE 예외 발생. 값이 반드시 있어야 할 경우에 사용       1 2 3  // public static &lt;T&gt; Optional&lt;T&gt; of(T value);   Optional&lt;String&gt; result = Optional.of(value);                Optional.ofNullable()       → value 가 null 인 경우 비어있는 Optional 반환. 값이 null 일 수도 있는 경우에 사용       1 2 3  // public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value);   Optional&lt;String&gt; result = Optional.ofNullable(null);                Optional.empty()       → 비어있는 Optional 객체 생성       1 2 3  // public static&lt;T&gt; Optional&lt;T&gt; empty();   Optional&lt;String&gt; result = Optional.empty();               3.2 Optional 중간 처리           filter()       → predicate 값이 참이면 해당 필터를 통과시키고 거짓이면 통과 되지 않습니다.       1 2 3 4  // public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);   Optional.of(\"1\").filter((val) -&gt; \"1\".eqauls(val)).orElse(\"NO DATA\"); // \"1\"  Optional.of(\"0\").filter((val) -&gt; \"1\".eqauls(val)).orElse(\"NO DATA\"); // \"NO DATA\"                map()       1 2 3 4  // public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper);   // string to integer  Integer test = Optional.of(\"1\").map(Integer::valueOf).orElseThrow(NoSuchElementException::new);               3.3 Optional 종단 처리           ifPresent()       1 2 3 4 5 6 7 8 9 10  // public void ifPresent(Consumer&lt;? super T&gt; consumer);   // ex1.  Optional.of(\"test\").ifPresent((value) -&gt; {  \t// something to do  });  // ex2. (ifPresent 미수행)  Optional.ofNullable(null).ifPresent((value) -&gt; {  \t// nothing to do  });                isPresent()       → 객체가 존재하는지 여부 판별       1 2 3 4  // public boolean isPresent();   Optional.ofNullable(\"1\").isPresent(); // true  Optional.ofNullable(\"1\").filter((val) -&gt; \"0\".eqauls(val)).isPresent(); // false                get()       → 객체를 꺼냄 (비어있는 객체이면 예외 발생)       1 2 3 4  // public T get();   Optional.of(\"test\").get(); // 'test'  Optional.ofNullable(null).get(); // Exception!!!                Optional.orElse()       → 객체가 비어있다면 기본값 제공       1 2 3  // public T orElse(T other);   Optional.ofNullable(null).orElse(\"default\"); // 'default'                Optional.orElseGet()       → 객체가 비어있다면 기본값 제공       1 2 3  // public T orElseGet(Supplier&lt;? extends T&gt; other);   Optional.ofNullable(\"input\").filter(\"test\"::equals).orElseGet(() -&gt; \"default\"); // 'default'                Optional.orElseThrow()       1 2 3  // public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X;   Optional.ofNullable(\"input\").filter(\"test\"::equals).orElseThrow(NoSuchElementException::new);               만약 빈 Optional 객체에 get() 메서드를 호출할 경우 NoSuchElementException 발생   따라서, Optional 객체를 가져오기 전에 값이 있는지 확인 해야 함   두가지 방법이 있는데 아래 방법을 권장한다.      isPresent()-get()   orElse(), orElseGet(), orElseThrow() (권장)       4. Optional 을 잘 사용하는 방법           isPresent()-get() 대신 orElse()/orElseGet()/orElseThrow()       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 안 좋음  Optional&lt;Member&gt; member = ...;  if (member.isPresent()) {      return member.get();  } else {      return null;  }       // 좋음  Optional&lt;Member&gt; member = ...;  return member.orElse(null);       // 안 좋음  Optional&lt;Member&gt; member = ...;  if (member.isPresent()) {      return member.get();  } else {      throw new NoSuchElementException();  }       // 좋음  Optional&lt;Member&gt; member = ...;  return member.orElseThrow(() -&gt; new NoSuchElementException());                orElse(new …) 대신 orElseGet(() -&gt; new …)       1 2 3 4 5 6 7 8 9 10 11 12 13  // 안 좋음  Optional&lt;Member&gt; member = ...;  return member.orElse(new Member());  // member에 값이 있든 없든 new Member()는 무조건 실행됨       // 좋음  Optional&lt;Member&gt; member = ...;  return member.orElseGet(Member::new);  // member에 값이 없을 때만 new Member()가 실행됨       // 좋음  Member EMPTY_MEMBER = new Member();  ...  Optional&lt;Member&gt; member = ...;  return member.orElse(EMPTY_MEMBER);  // 이미 생성됐거나 계산된 값은 orElse()를 사용해도 무방           단지 값을 얻을 목적이라면 Optional 대신 null   Optional 대신 비어있는 컬렉션 반환   Optional 을 필드로 사용 금지   Optional 을 생성자나 메서드 인자로 사용 금지        Optional 을 컬렉션의 원소로 사용 금지       1 2  ex.   Map&lt;String, Optional&lt;String&gt;&gt; sports = new HashMap&lt;&gt;();                Optional 대신 OptionalInt, OptionalLong, OptionalDouble       → Type 이 Int, Long, Double 이면 OptionalInt, OptionalLong, OptionalDouble 을 사용하는게 좋음      ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-Optional/",
        "teaser": ""
      },{
        "title": "테스트 코드",
        "excerpt":"테스트 코드   테스트 코드란   프로그램 작성 시 문제가 없는지 확인하기 위해 사용       테스트 코드를 작성하는 이유      빠른 피드백   자동검증이 가능   개발자가 만든 기능을 안전하게 보호해 준다.       테스트 코드 작성 방법   → 메서드를 작성하고 그 위에 @Test 를 작성하면 된다.   → 테스트코드는 직관적으로 보기 위해 메소드를 한글로 작성하기도 한다   → 테스트코드는 빌드 시 포함되지 않는다. (따라서, 한글로 작성해도 된다)       테스트코드 작성 시 아래 패턴을 기반으로 하면 좋다.   1 2 3 4 5 6 7 8 @Test void 회원가입() {     // given      // when      // then }       테스트 주도 개발 (TDD)   기능 구현 후 테스트 케이스 작성하는 것이 아닌 테스트 케이스를 먼저 작성하고 기능 구현하는 것을 테스트 주도 개발 (TDD) 이라고 한다.       테스트 코드 꼭 해야할까 에 대한 의문?   간단한 프로젝트의 경우 필요가 없을 수도 있고 출력문을 통해 진행 할 수도 있겠다.   하지만, 몇만 라인 넘어가는 프로젝트 같은 경우 테스트케이스 없이 개발시 문제가 많이 생김   → 따라서, 테스트 코드 관련해서는 깊이 있는 공부가 필요함       JUnit 과 AssertJ   java 에서 테스트 코드 작성 시 JUnit 과 assertj 를 주로 사용       JUnit이란?  자바를 위한 단위 테스트 라이브러리       JUnit의 assert 메소드들   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import static org.junit.jupiter.api.Assertions;  Assertions.assertEquals(result, member); Assertions.assertNotEquals(result, member);  Assertions.assertTrue(result); Assertions.assertFalse(result);  Assertions.assertNull(result); Assertions.assertNotNull(result);  Assertions.assertSame(result); Assertions.assertNotSame(result);  Assertions.assertArrayEquals();  Assertions.assertThrows();       JUnit의 어노테이션   @Test   → 메소드 위에 해당 어노테이션을 선언, 테스트 대상 메서도임을 지정할 수 있음   @BeforeEach   → 공통적인 Param 및 설정을 할때 호출되면 좋을 부분이다.   → 같은 리소스를 사용하도록 설정하고 싶을 때   @AfterEach   → 테스트 코드 실행이 끝나고 실행 된다.   → 테스트 코드가 여러 개일 경우 각각의 코드 실행이 끝날 때마다 실행   사용이유!   여러개의 테스트 코드를 실행 시 테스트 코드 실행 순서는 랜덤이다.   이때 같은 메모리를 사용하게 되면 문제가 발생 할 수 있다.   즉, 독립적인 테스트 케이스  실행이 필요하다   1 2 3 4 5 6 7 8 9 10 // MemberRepository public void clearStore(){     store.clear(); }  // MemberRepositoryTest @AfterEach public void afterEach() {     repository.clearStore(); }       AssertJ란?  자바 JUnit의 테스트코드에 사용되어, 테스트코드의 가독성과 편의성을 높여 주는 라이브러리       AssertJ의 assert 메소드   AssertJ에서 모든 테스트 코드는 assertThat()으로 시작함.   assertThat(테스트 타겟).메소드1().메소드2().메소드3()’ 이런 포맷으로 AssertJ의 여러 메소드들을 연쇄적으로 호출해 코드를 작성할 수 있다. (메서드 체이닝)   1 2 3 4 import static org.assertj.core.api.Assertions;  // 명확한 값 비교를 위해 사용 Assertions.assertThat(a, b);       isNotEmpty(), contains(e), doesNotContain(e), startsWith(e), endsWith(e), isEqualTo(e)       예제 - 문자열 테스트   1 2 3 4 5 6 7 8 assertThat(\"Hello, world! Nice to meet you.\") // 주어진 \"Hello, world! Nice to meet you.\"라는 문자열은     .isNotEmpty() // 비어있지 않고     .contains(\"Nice\") // \"Nice\"를 포함하고     .contains(\"world\") // \"world\"도 포함하고     .doesNotContain(\"ZZZ\") // \"ZZZ\"는 포함하지 않으며     .startsWith(\"Hell\") // \"Hell\"로 시작하고     .endsWith(\"u.\") // \"u.\"로 끝나며     .isEqualTo(\"Hello, world! Nice to meet you.\"); // \"Hello, world! Nice to meet you.\"과 일치합니다.   예제 - 숫자 테스트   1 2 3 4 5 6 7 assertThat(3.14d) // 주어진 3.14라는 숫자는     .isPositive() // 양수이고     .isGreaterThan(3) // 3보다 크며     .isLessThan(4) // 4보다 작습니다     .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고     .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며     .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다      junit Assertions 와 assertj Assertions 의 사용법 예시   1 2 3 4 5 import static org.junit.jupiter.api.Assertions.assertEquals; assertEquals(result, member);  import static org.assertj.core.api.Assertions.assertThat; assertThat(result).isEqualTo(member);  ","categories": ["Spring"],
        "tags": ["Spring","Java","TEST CODE"],
        "url": "/spring/Java-TESTCODE/",
        "teaser": ""
      },{
        "title": "Transactional 이란",
        "excerpt":"트랜잭션이란?      데이터베이스의 상태를 변경하는 작업   한번에 수행되어야 하는 연산들을 의미   begin, commit 을 자동으로 수행   예외 발생 시  rollback 처리를 자동으로 수행       트랜잭션의 4가지 성질           원자성       → 한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리함. 즉, 모두 성공 또는 모두 실패            일관성       → 일관성 있는 데이터베이스 상태를 유지            격리성       → 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리            영속성       → 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 함           트랜잭션 처리 방법   스프링에서는 어노테이션 방식으로 사용   @Transactional 을 메소드, 클래스, 인터페이스 위에 추가하여 사용 (선언적 트랜잭션)   적용된 범위에서는 트랜잭션 기능이 포함된 프록시 객체가 생성되어 자동으로 commit 혹은 rollback 을 진행 해준다.   1 2 @Transactional public class MemberService { }       @Transactional 옵션   1. isolation   2. propagation   3. noRollbackFor (예외무시)   특정 예외 발생 시 Rollback 처리 하지 않음.   1 2 @Transactional(noRollbackFor=Exception.class) public void addMember(Member member) throws Exception { }   4. rollbackFor (예외추가)   특정 예외 발생 시 강제로 Rollback   1 2 @Transactional(rollbackFor=Exception.class) public void addMember(Member member) throws Exception { }   5. timeout (시간지정)   지정한 시간 내에 해당 메소드 수행이 완료되지 않을 경우 rollback 수행 (default=-1)   1 2 @Transactional(timeout=10) public void addMember(Member member) throws Exception { }   6. readOnly (읽기전용)   true 시 insert, update, delete 실행 시 예외 발생 (default=false)   1 2 @Transactional(readonly=true) public void addMember(Member member) throws Exception { }       @Transactional 만 붙이면 롤백이 안되는 이유?   @Transactional 은 기본적으로 unchecked Exception, Error 만을 롤백한다   따라서, 모든 예외에 대해 롤백을 진행하고 싶을 경우 @Transactional(rollbackFor = Exception.class) 를 써야한다.  ","categories": ["Spring"],
        "tags": ["Java","Spring","DB"],
        "url": "/spring/Spring-Transactional/",
        "teaser": ""
      },{
        "title": "SpringBoot Settings",
        "excerpt":"1. SpringBoot Settings   → spring boot 기반으로 셋팅   Spring Initializr   위의 사이트에서 기본적인 스프링 프로젝트 셋팅을 할 수 있다   설정 시 Dependencies 에서      spring web   Thymeleaf   spring data jpa   h2 database   lombok   를 선택 후 GENERATE!      위에서 GENERATE 한 파일을 IntelliJ 에서 Open!   → build.gradle 파일을 Open         2. IntelliJ Gradle 대신에 자바 직접 실행   IntelliJ 버전은 Gradle 로 실행하는 것이 기본 설정이지만, 이렇게 하면 실행속도가 느림. 따라서, 다음과 같이 변경하면 자바로 바로 실행해서 속도가 빠르다.   Preferences 에서 Gradle 을 검색하여      build and run using   Run tests using   을 IntelliJ IDEA 로 바꿔준다         3. Lombok 설정   lombok 을 설정하고 나서 preferences 에서 annotation processors 를 설정해야 한다.   enable annotation processing 에 체크!         4. H2 데이터베이스 생성      h2 콘솔에 접속        콘솔에서 아래와 같이 입력 후 연결을 누르면 jpapractice 라는 데이터베이스가 생성됨                jpapractice.mv.db 파일이 생성됨                   h2 데이터베이스 접속       아래와 같이 jdbc url 을 변경한다.                  참고) H2 Database 설치, 서버 실행, 접속 방법 (Windows, MacOS)         5. application.yml 작성   기존에 있던 application.properties 대신 application.yml 을 사용   (둘 중 하나 선택해서 사용하면 되는데 복잡해질 경우 yml 이 보기가 좋음)   application.yml   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring:   datasource:     url: jdbc:h2:tcp://localhost/~/jpashop     username: sa     password:     driver-class-name: org.h2.Driver    jpa:     hibernate:       ddl-auto: create     properties:       hibernate: #        show_sql: true         format_sql: true  logging:   level:     org.hibernate.SQL: debug #    org.hibernate.type: trace           show_sql 과 org.hibernate.SQL 차이점       공통점: 두가지 옵션 다 hibernate 실행 sql 로그를 찍는 기능을 한다.       차이점: show_sql 은 system.out 에 출력하는것이고 org.hibernate.SQL 은 logger 를 통해서 출력       → 운영환경에서는 show_sql 을 사용하지 않는다.       → 모든 로그 출력은 가급적 logger 를 통해 남기는게 좋다            spring.jpa.hibernate.ddl-auto: create       애플리케이션 생성 시점에 테이블을 drop 하고 다시 생성!             6. console 에 Query 파라미터 로그 남기기   스프링부트에서 기본적으로 제공하는 라이브러리가 없기 때문에 외부에서 가져와 사용   build.gradle 에 추가   1 implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.5.6'   → 개발단계에서는 편하지만 운영시스템에 적용하려면 성능테스트가 필요!  ","categories": ["Spring"],
        "tags": ["Java","Spring"],
        "url": "/spring/Java-SpringBoot-Settings/",
        "teaser": ""
      },{
        "title": "JPA Intro",
        "excerpt":"JPA   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jpabook.start;  import javax.persistence.*; import java.util.List;   public class JpaMain {      public static void main(String[] args) {          //엔티티 매니저 팩토리 생성         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpabook\");         EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성          EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득          try {              tx.begin(); //트랜잭션 시작             logic(em);  //비즈니스 로직             tx.commit();//트랜잭션 커밋          } catch (Exception e) {             e.printStackTrace();             tx.rollback(); //트랜잭션 롤백         } finally {             em.close(); //엔티티 매니저 종료         }          emf.close(); //엔티티 매니저 팩토리 종료     }      // 비즈니스 로직     public static void logic(EntityManager em) {          String id = \"id1\";         Member member = new Member();         member.setId(id);         member.setUsername(\"지한\");         member.setAge(2);          //등록         em.persist(member);          //수정         member.setAge(20);          //한 건 조회         Member findMember = em.find(Member.class, id);         System.out.println(\"findMember=\" + findMember.getUsername() + \", age=\" + findMember.getAge());          //목록 조회         List&lt;Member&gt; members = em.createQuery(\"select m from Member m\", Member.class).getResultList();         System.out.println(\"members.size=\" + members.size());          //삭제         em.remove(member);      } }   코드는 크게 3부분으로 나뉘어 있다.      엔티티 매니저 설정   트랜잭션 관리   비즈니스 로직         엔티티 매니저 설정           엔티티 매니저 팩토리 생성       → 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용            엔티티 매니저 생성       → 엔티티 매니저 팩토리에서 엔티티 매니저 생성       → 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회 할 수 있다.       → 엔티티 매니저는 db 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.            종료       → 엔티티 매니저 종료       → 엔티티 매니저 팩토리 종료             트랜잭션 관리   JPA 를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다.   트랜잭션 없이 데이터를 변경하면 예외 발생   트랜잭션 API 를 사용해서 비즈니스 로직이 정상동작하면 트랜잭션을 commit 하고 예외가 발생하면 rollback 한다.         비즈니스 로직   JPQL   사용이유?   → JPA 는 엔티티 객체를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다.   → 테이블이 아닌 엔티티 객체를 대상으로 검색하려면 db 의 모든 데이터를 애플리케이션으로 불러와서 엔티티 객체로 변경한 다음 검색해야하는데 이는 사실상 불가능   → 따라서, 이 문제를 해결하기 위해 JPA 는 JPQL 이라는 쿼리 언어 사용   JPQL vs SQL           JPQL: 엔티티 객체를 대상으로 쿼리한다            SQL: DB 테이블을 대상       1 2 3 4 5 6 7 ...  //목록 조회 List&lt;Member&gt; members = em.createQuery(\"select m from Member m\", Member.class).getResultList(); System.out.println(\"members.size=\" + members.size());  ...   위의 코드의 select m from Member m 에서 from Member 는 테이블이 아닌 엔티티 객체를 의미  ","categories": ["JPA"],
        "tags": ["Java","JPA"],
        "url": "/jpa/Java-JPA-Intro/",
        "teaser": ""
      },{
        "title": "JPA Repository",
        "excerpt":"ItemRepository.java   1 2 3 4 5 6 7 8 package com.shop.shop.repository;  import com.shop.shop.entity.Item; import org.springframework.data.jpa.repository.JpaRepository;  public interface ItemRepository extends JpaRepository&lt;Item, Long&gt; {  }       JpaRepository   JpaReporitory 는 2개의 제네릭 타입을 사용하는데 첫번째에는 엔티티 타입 클래스, 두번재는 기본키 타입을 넣어줌   JpaReporitory 는 기본적인 CRUD 및 페이징 처리를 위한 메소드가 정의돼 있음           JpaReporitory 에서 지원하는 메소드 예시                  application-test.properties   1 2 3 4 5 6 7 # Datasource 설정 spring.datasource.driver-class-name=org.h2.Driver spring.datasource.url=jdbc:h2:mem:test spring.datasource.username=sa spring.datasource.password=  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect       ItemRepositoryTest.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.shop.shop.repository;  import com.shop.shop.entity.Item; import com.shop.shop.entity.ItemSellStatus; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.TestPropertySource;  import java.time.LocalDateTime;  @SpringBootTest @TestPropertySource(locations = \"classpath:application-test.properties\") class ItemRepositoryTest {      @Autowired     ItemRepository itemRepository;      @Test     @DisplayName(\"상품 저장 테스트\")     public void createItemTest() {         Item item = new Item();         item.setItemNm(\"테스트 상품\");         item.setPrice(10000);         item.setItemDetail(\"테스트 상품 상세 설명\");         item.setItemSellStatus(ItemSellStatus.SELL);         item.setStockNumber(100);         item.setRegTime(LocalDateTime.now());         item.setUpdateTime(LocalDateTime.now());         Item savedItem = itemRepository.save(item);         System.out.println(savedItem.toString());     } }       @SpringBootTest   통합 테스트를 위해 스프링 부트에서 제공하는 어노테이션   실제 애플리케이션을 구동할 때처럼 모든 Bean 을 IoC 컨테이너에 등록   애플리케이션의 규모가 크면 속도가 느려질 수 있다.       @TestPropertySource(locations = “classpath:application-test.properties”)   테스트 코드 실행 시 application.properties 에 설정해둔 값보다 application-test.properties 에 같은 설정이 있다면 더 높은 우선순위를 부여       @Autowired   ItemRepository 를 사용하기 위해 어노테이션을 이용하여 Bean 을 주입       @Test   테스트할 메소드위에 선언하여 테스트 대상으로 지정       @DisplayName(“상품 저장 테스트”)   테스트 코드 실행 시 지정한 테스트명이 노출됨   Spring Data JPA 는 JPA 의 구현체인 Hibernate 를 이용하기 위한 여러 API 를 제공.   그중에서 가장 많이 사용하는 것이 JpaRepository 라는 인터페이스         JpaRepository 예제   MemoRepository.java   1 2 3 4 5 6 7 package org.zerock.ex2.repository;  import org.springframework.data.jpa.repository.JpaRepository; import org.zerock.ex2.entity.Memo;  public interface MemoRepository extends JpaRepository&lt;Memo, Long&gt; { }   작성된 MemoRepository 는 인터페이스 자체, JpaRepository 인터페이스를 상속하는 것만으로 모든 작업이 끝   JpaRepository 를 사용할 때는 엔티티의 타입 정보(Memo) 와 @Id 의 타입(Long) 을 지정.   Spring Data JPA 는 인터페이스 선언만으로 자동으로 스프링의 빈으로 등록됨       테스트 코드를 통한 CRUD 연습      insert 작업: save(엔티티 객체)   select 작업: findById(키 타입), getOne(키 타입)   update 작업: save(엔티티 객체)   delete 작업: deleteById(키 타입), delete(엔티티 객체)       특이하게 insert 와 update 작업에 사용하는 메서드가 동일하게 save() 를 이용하는데 이는 JPA 의 구현체가 메모리상(Entity Manager) 에서 객체를 비교하고 없다면 insert, 존재한다면 update 를 동작시키는 방식으로 동작하기 때문   MemoRepositoryTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package org.zerock.ex2.repository;  import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.transaction.annotation.Transactional; import org.zerock.ex2.entity.Memo;  import java.util.Optional; import java.util.stream.IntStream;  @SpringBootTest class MemoRepositoryTests {      @Autowired     MemoRepository memoRepository;      @Test     public void testClass() {         System.out.println(memoRepository.getClass().getName());     }      @Test     @DisplayName(\"등록 작업 테스트\")     public void testInsertDummies() {         IntStream.rangeClosed(1, 100).forEach(i -&gt; {             Memo memo = Memo.builder().memoText(\"Sample...\" + i).build();             memoRepository.save(memo);         });     }      @Test     @DisplayName(\"조회 작업 테스트\")     public void testSelect() {         Long mno = 100L;         Optional&lt;Memo&gt; result = memoRepository.findById(mno);          System.out.println(\"=====================================\");          if (result.isPresent()) {             Memo memo = result.get();             System.out.println(memo);         }     }      @Transactional     @Test     @DisplayName(\"조회 작업 테스트2\")     public void testSelect2() {         Long mno = 100L;          Memo memo = memoRepository.getOne(mno);          System.out.println(\"=====================================\");          System.out.println(memo);     }      @Test     @DisplayName(\"수정 작업 테스트\")     public void testUpdate() {         Memo memo = Memo.builder().mno(100L).memoText(\"Update Text\").build();          System.out.println(memoRepository.save(memo));     }      @Test     @DisplayName(\"삭제 작업 테스트\")     public void testDelete() {         Long mno = 100L;          memoRepository.deleteById(mno);     } }           testClass       → 본격적인 테스트에 앞서 실제로 MemoRepository 가 정상적으로 스프링에서 처리되고, 의존성 주입에 문제가 없는지를 먼저 확인            등록 작업 테스트       → 한 번에 여러 개의 엔티티 객체를 저장하도록 작성            조회 작업 테스트       → findById(): Optional 타입으로 반환       → findById() 를 실행하는 순간에 이미 SQL 은 처리가 됨            조회 작업 테스트2       → getOne(): Transactional 어노테이션이 추가로 필요       → getOne() 의 리턴 값은 해당 객체이지만, 실제 객체가 필요한 순간까지 SQL 을 실행하지 않음            수정 작업 테스트       → 내부적으로 해당 엔티티의 @Id 값이 일치하는지를 확인해서 insert or update 작업을 처리            삭제 작업 테스트       → 삭제하려는 번호의 엔티티 객체가 있는지 먼저 확인하고, 이를 삭제       → deleteById() 의 리턴 타입은 void, 만일 해당 데이터가 존재하지 않으면 예외를 발생      ","categories": ["JPA"],
        "tags": ["Java","Spring","JPA"],
        "url": "/jpa/Java-JPARepository/",
        "teaser": ""
      },{
        "title": "Nginx 를 이용하여 SpringBoot 무중단 배포하기",
        "excerpt":"참고) 스프링 부트와 AWS로 혼자 구현하는 웹서비스   [SpringBoot] 웹서비스 출시하기 - 5. Nginx를 활용한 무중단 배포 구축하기         1. 구조      Nginx 1대, 스프링부트 jar 2대   Nginx에는 80(http), 443(https) 포트를 할당합니다.   스프링부트 jar1에는 8081포트로 , 스프링부트 jar2에는 8082포트로 실행합니다.(포트는 원하시는 포트를 사용하시면 됩니다.)   구조는 아래의 그림같이 형성      위 그림의 동작 과정      사용자는 80, 443 포트로 서비스에 접속   Nginx 는 해당 요청을 받아 현재 동작중인 스프링부트 Jar1(Port: 8081) 으로 전달함   스프링부트 Jar2(Port: 8082) 는 현재 동작중이지 않기 때문에 받지 못함          위 그림의 신규 버전 배포시 동작 과정      2.0 버전으로 신규 배포가 진행되면 현재 동작중이지 않은 스프링부트 Jar2(8082) 로 배포   배포하는 동안에는 사용자는 스프링부트 Jar1(8081)를 계속해서 바라보고 있는 중   배포가 정상적으로 끝난다면, 스프링부트 Jar2(8082)의 구동 여부를 확인   정상 구동 중이라면 nginx 는 스프링부트 Jar2(8082)를 바라보도록 설정   배포에 문제가 생길 시에는 정상 구동 중인 스프링부트 Jar로 돌아감          위 그림 동작 과정      2.1 버전으로 신규 배포가 진행되면 현재 동작중이지 않은 스프링부트 Jar1(8081)로 배포   배포하는 동안에는 사용자는 스프링부터 Jar2(8082)를 계속해서 바라보고 있는 중   배포 도중 문제가 생겼다면, nignx 는 그대로 스프링부트 Jar2(8082)를 바라보도록 함   배포의 문제를 확인하고 다시 배포를 진행         2. 프로젝트 경로   1 2 3 4 5 6 7 8 9 10 # /usr/local/web . ├── config                    - 무중단배포 포트관련 설정파일 ├── cutelovelycat             - 프로젝트 경로 (git) │   ├── build │   ├── gradle │   └── src └── nonstop                   - 무중단배포     ├── cutelovelycat     └── jar                   - 배포시 실제 적용되는 jar 파일         3. 프로젝트 settings       1) nginx 설치   1. nginx 저장소 추가   yum 저장소에는 nginx 라이브러리가 없기 때문에 저장소를 임의로 추가   1 vi /etc/yum.repos.d/nginx.repo   nginx.repo 파일 만들고 아래 내용 추가   1 2 3 4 5 [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1       2. nginx 설치   1 yum install -y nginx       3. nginx 서비스 등록 및 시작   1 2 3 4 5 6 # 서비스 등록 systemctl enable nginx # 서비스 시작 systemctl start nginx # 서비스 상태 확인 systemctl status nginx       4. nginx 설정파일 수정   /etc/nginx/conf.d/*.conf   1 2 3 4 5 6 7 8 9 10 11 12 13 14 server {     listen 80;     listen [::]:80;     server_name localhost;      include /etc/nginx/conf.d/service-url.inc;      location / {         proxy_pass $service_url;         proxy_set_header X-Real-IP $remote_addr;         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;         proxy_set_header Host $http_host;     } }   service-url.inc   1 set $service_url http://127.0.0.1:8081;       nginx 재시작   1 systemctl restart nginx       참고) Nginx 동적 프록시 설정   nginx 가 set1(port: 8081) 과 set2(port: 8082) 를 번갈아가면서 바라보도록 하는 프록시 설정   1 2 3 4 5 6 7 location / { \t\t# 동적으로 Proxy Pass 를 변경 \t\tproxy_pass $service_url;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header Host $http_host; }         2) github repository 연결   1. SSH key 파일 확인 및 public key 등록   1 2 cd ~/.ssh ls      위의 사진처럼 키파일이 있다면 github settings 에서 ssh key 를 등록해주면 된다.   주의! 반드시 퍼블릭키를 등록해야 한다 (*.pub)   참고)   [Git (7)] Github 비밀번호 입력 없이 pull/push 하기(github ssh key 설정)       2. git clone ssh 주소   프로젝트 경로에 clone 을 할때 ssh 주소로 가져옴   1 git clone git@github.com:nnyang0110/cat.git         3) 프로젝트 설정   프로젝트의 기본 경로는 /usr/local/web 이다   1 cd /usr/local/web       실제 운영환경 설정파일   1 vi ./cutelovelycat/src/main/resources/application.yml   application.yml   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 spring:   devtools:     livereload:       enabled: true     restart:       enabled: true     thymeleaf:       cache: false   datasource:     url: jdbc:mysql://127.0.0.1:3306/dbname?useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true&amp;useSSL=false&amp;serverTimezone=Asia/Seoul     username:      password:      driver-class-name: com.mysql.cj.jdbc.Driver    security:     oauth2:       client:         registration:           kakao:             client-id:              redirectUri: \"{baseUrl}/{action}/oauth2/code/{registrationId}\"             client-authentication-method: POST             authorization-grant-type: authorization_code             scope: profile_nickname, account_email             client-name: Kakao         provider:           kakao:             authorization_uri: https://kauth.kakao.com/oauth/authorize             token_uri: https://kauth.kakao.com/oauth/token             user-info-uri: https://kapi.kakao.com/v2/user/me             user_name_attribute: kakao_account    jpa:     hibernate:       ddl-auto: none     properties:       hibernate:         format_sql: true  logging:   level:     org.hibernate.SQL: debug       무중단 배포를 위한 설정파일   → profiles 에 따라 포트를 다르게 줌   1 vi ./config/real-application.yml   real-application.yml   1 2 3 4 5 6 7 8 9 10 11 12 --- spring:   profiles: set1 server:   port: 8081  --- spring:   profiles: set2  server:   port: 8082         4) 무중단 배포 설정   기본 경로는 /usr/local/web/nonstop 이다   1 cd /usr/local/web/nonstop   1 2 3 4 5 6 7 8 9 10 11 12 . ├── cutelovelycat │   └── build │       └── libs │           └── cat-0.0.1-SNAPSHOT.jar ├── deploy.sh ├── jar │   ├── cat-0.0.1-SNAPSHOT.jar │   ├── set1-cat.jar -&gt; /usr/local/web/nonstop/jar/cat-0.0.1-SNAPSHOT.jar │   └── set2-cat.jar -&gt; /usr/local/web/nonstop/jar/cat-0.0.1-SNAPSHOT.jar ├── nohup.out └── switch.sh         자동 배포, 무중단 배포 스크립트   deploy.sh   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 #!/bin/bash  REPOSITORY=/usr/local/web DEPLOY_PATH=$REPOSITORY/nonstop/cutelovelycat/build/libs/  cd $REPOSITORY/cutelovelycat/  echo \"&gt; Git Pull\" git pull  echo \"&gt; 프로젝트 Build 시작\" ./gradlew build  echo \"&gt; 배포 경로에 복사\" JAR_NAME=$(ls $REPOSITORY/cutelovelycat/build/libs/ |grep 'cat' |grep 'SNAPSHOT.jar' | tail -n 1)  echo \"&gt; JAR Name: $JAR_NAME\"  cp ./build/libs/$JAR_NAME $DEPLOY_PATH  BASE_PATH=/usr/local/web/nonstop BUILD_PATH=$(ls $BASE_PATH/cutelovelycat/build/libs/*.jar) JAR_NAME=$(basename $BUILD_PATH) echo \"&gt; build 파일명: $JAR_NAME\"  echo \"&gt; build 파일 복사\" DEPLOY_PATH=$BASE_PATH/jar/ cp $BUILD_PATH $DEPLOY_PATH  echo \"&gt; 현재 구동중인 Set 확인\" CURRENT_PROFILE=$(curl -s http://localhost/profile) echo \"&gt; $CURRENT_PROFILE\"  # 쉬고 있는 set 찾기: set1이 사용중이면 set2가 쉬고 있고, 반대면 set1이 쉬고 있음 # Nginx 에 연결되어 있지 않은 Profile 찾기 # set1 이 구동중이면 set2 를 연결 # set2 이 구동중이면 set1 를 연결 if [ $CURRENT_PROFILE == set1 ] then   IDLE_PROFILE=set2   IDLE_PORT=8082 elif [ $CURRENT_PROFILE == set2 ] then   IDLE_PROFILE=set1   IDLE_PORT=8081 else   echo \"&gt; 일치하는 Profile이 없습니다. Profile: $CURRENT_PROFILE\"   echo \"&gt; set1을 할당합니다. IDLE_PROFILE: set1\"   IDLE_PROFILE=set1   IDLE_PORT=8081 fi  # 미연결된 Jar 로 신규 Jar 심볼릭 링크 (ln) echo \"&gt; application.jar 교체\" IDLE_APPLICATION=$IDLE_PROFILE-cat.jar IDLE_APPLICATION_PATH=$DEPLOY_PATH$IDLE_APPLICATION  ln -Tfs $DEPLOY_PATH$JAR_NAME $IDLE_APPLICATION_PATH  # Nginx 와 연결되지 않은 Profile 종료 echo \"&gt; $IDLE_PROFILE 에서 구동중인 애플리케이션 pid 확인\" IDLE_PID=$(pgrep -f $IDLE_APPLICATION)  if [ -z $IDLE_PID ] then   echo \"&gt; 현재 구동중인 애플리케이션이 없으므로 종료하지 않습니다.\" else   echo \"&gt; kill -15 $IDLE_PID\"   kill -15 $IDLE_PID   sleep 5 fi  # Nginx 와 연결된 Profile Jar 로 실행 echo \"&gt; $IDLE_PROFILE 배포\" nohup java -jar -Dspring.profiles.active=$IDLE_PROFILE $IDLE_APPLICATION_PATH &amp;  # 프로젝트 상태 확인 echo \"&gt; $IDLE_PROFILE 10초 후 Health check 시작\" echo \"&gt; curl -s http://localhost:$IDLE_PORT/profile\" sleep 10  for retry_count in {1..10} do   response=$(curl -s http://localhost:$IDLE_PORT/profile)   up_count=$(echo $response | grep 'set' | wc -l)    if [ $up_count -ge 1 ]   then # $up_count &gt;= 1 (\"set\" 문자열이 있는지 검증)       echo \"&gt; Health check 성공\"       break   else       echo \"&gt; Health check의 응답을 알 수 없거나 혹은 status가 UP이 아닙니다.\"       echo \"&gt; Health check: ${response}\"   fi    if [ $retry_count -eq 10 ]   then     echo \"&gt; Health check 실패. \"     echo \"&gt; Nginx에 연결하지 않고 배포를 종료합니다.\"     exit 1   fi    echo \"&gt; Health check 연결 실패. 재시도...\"   sleep 10 done  # 아래 추가 echo \"&gt; 스위칭\" sleep 10 /usr/local/web/nonstop/switch.sh       동적 프록시 환경이 구축된 Nginx 가 배포 시점에 바라보는 Profile 을 자동으로 변경하는 switch 스크립트 생성   switch.sh   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash echo \"&gt; 현재 구동중인 Port 확인\" CURRENT_PROFILE=$(curl -s http://localhost/profile)  # 쉬고 있는 set 찾기: set1이 사용중이면 set2가 쉬고 있고, 반대면 set1이 쉬고 있음 if [ $CURRENT_PROFILE == set1 ] then   IDLE_PORT=8082 elif [ $CURRENT_PROFILE == set2 ] then   IDLE_PORT=8081 else   echo \"&gt; 일치하는 Profile이 없습니다. Profile: $CURRENT_PROFILE\"   echo \"&gt; 8081을 할당합니다.\"   IDLE_PORT=8081 fi  echo \"&gt; 전환할 Port: $IDLE_PORT\" echo \"&gt; Port 전환\" echo \"set \\$service_url http://127.0.0.1:${IDLE_PORT};\" |sudo tee /etc/nginx/conf.d/service-url.inc  PROXY_PORT=$(curl -s http://localhost/profile) echo \"&gt; Nginx Current Proxy Port: $PROXY_PORT\"  echo \"&gt; Nginx Reload\" sudo service nginx reload       참고)   gradlew 의 실행권한이 없다는 메시지가 뜬다면   1 chmod +x ./gradlew   nginx proxy 오류 (포트 설정에 대한 부분)   → SELinux 가 차단하여 발생   1 /usr/sbin/setsebool httpd_can_network_connect true         결과적으로 아래와 같이 두개의 jar 파일이 돌고 있고          현재 set2 가 실행 중이다          코드가 수정되고 배포를 하게 되면 set1 이 실행되게 된다.     ","categories": ["Spring"],
        "tags": ["Java","Spring","Nginx"],
        "url": "/spring/Java-Nginx-SpringBoot/",
        "teaser": ""
      },{
        "title": "Spring Profile 이란?",
        "excerpt":"개발환경에 따라 설정파일을 다르게 로딩해야할 필요가 있다   이처럼 Profile 은 어떤 특정 환경의 설정 값을 다르게 하고 싶을 때 사용   예를 들어, 테스트 환경과 배포 환경을 다르게 두고 Profile 설정       기본적인 profile 정보      application.properties   application.yml       여기서 특정 규칙에 만족하게 설정 파일을 만들면 SpringBoot 가 읽어올 수 있다.      application-{프로필네임키워드}.properties            ex. application-dev.properties           application-{프로필네임키워드}.yml            ex. application-prod.yml                 실행하기   설정 정보를 바꿔서 실행하기 위한 방법으로 크게 2가지 방법을 사용      application.yml 에 profile.active 지정하기   java -jar 에 옵션을 줘서 특정 profile 로드하기       1. application.yml 에 profile.active 지정하기   yml 이나 properties 파일에서 직접 설정 정보를 변경, profile.active 를 지정하면 된다.   1 2 3 4 5 6 7 8 9 --- spring:   profiles:     active: set1  --- spring:   profiles:     active: set2   만약, 아무것도 지정하지 않는다면 application.yml 또는 application.properties 파일을 불러오게 된다.       2. java -jar 에 옵션을 줘서 특정 profile 로드하기   java jar 파일로 빌드를 하고 jar 파일을 실행시키는 시점에 환경변수를 추가하여 profile 을 변경시킬 수 있다.   1 2 3 java -jar -Dspring.profiles.active=set1 ./cat-0.0.1-SNAPSHOT.jar  java -jar -Dspring.profiles.active=set2 ./cat-0.0.1-SNAPSHOT.jar       테스트   application.yml   1 2 3 4 5 6 7 8 9 10 11 12 server:   port: 8080  spring:   application:     name: user-service    profiles:     active: test # 만약 application-prod.yml 파일을 로딩하고 싶다면, prod  greeting:   message: this is MAIN application.yml   application-test.yml   1 2 greeting:   message: this is TEST application.yml   application-prod.yml   1 2 greeting:   message: this is PRODUCTION application.yml   ProfileApplication.java   1 2 3 4 5 6 7 8 9 10 11 12 13 @SpringBootApplication @RestController public class UserServiceApplication {      public static void main(String[] args) {         SpringApplication.run(UserServiceApplication.class, args);     }      @GetMapping     public String string(@Value(\"${greeting.message}\") String message) {         return message;     } }       profiles.active=test 일때, 아래 메시지 출력   1 this is TEST application.yml   profiles.active=prod 일때, 아래 메시지 출력   1 this is PRODUCTION application.yml   profiles.active 가 빈 값 일때, 아래 메시지 출력   1 this is MAIN application.yml       참고)   java 에서 profile 옵션을 가져오고 싶을때?   → System.getProperty 를 이용!   1 2 // java -Dspring.profiles.active=set1 -jar ProfileApplication.jar 실행시 String profile = System.getProperty(\"spring.profiles.active\"); // set1  ","categories": ["Spring"],
        "tags": ["Java","Spring"],
        "url": "/spring/Java-SpringProfile/",
        "teaser": ""
      },{
        "title": "객체지향개념(객체지향언어, 클래스와 객체)",
        "excerpt":"1. 객체지향언어  1.1 객체지향언어의 역사   80년 초 소프트웨어의 위기(c언어, fortran, cobol 등) - 빠른 변화를 못쫓아감   해결책으로 객체지향 언어를 도입(절차적 → 객체지향)   참고) c언어 + 객체지향 개념 ⇒ c++ ⇒ java       1.2 객체지향언어   코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거   객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)   OOP (Object-Oriented Programming, 객체 지향 프로그래밍)   객체지향언어의 핵심 개념 (캡상추다)      캡슐화   상속   추상화   다형성 *** (가장 중요)   이론서     디자인 패턴: 객체지향개념을 이용해서 프로그래밍을 자주할 때 사용하는 패턴을 모아놓은 것   객체지향개념   객체지향언어란 결국 설계를 잘하는 것! 설계가 잘 안된다고 해서 이론서로 바로 빠지면 안된다! jsp, spring 을 공부한 후 이론서 공부를 하던가 해야지 바로 이론서로 가지 말 것!   2. 클래스와 객체   2.1 클래스와 객체의 정의와 용도   1 2 클래스의 정의: 클래스란 객체를 정의해 놓은 것, 객체의 설계도 또는 틀 클래스의 용도: 클래스는 객체를 생성하는데 사용   1 2 객체의 정의: 실제로 존재하는 것. 사물 또는 개념 객체의 용도: 객체가 가지고 있는 기능과 속성에 따라 다름   클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다. 우리가 원하는 기능의 객체를 사용하기 위해서는 먼저 클래스로부터 객체를 생성하는 과정이 선행되어야 한다.   예를들어, 우리가 TV를 보기 위해서는 TV(객체)가 필요한 것이지 TV설계도(클래스)가 필요한 것이 아니며, TV설계도(클래스)는 단지 TV라는 제품(객체)을 만드는 데만 사용될 뿐이다.   TV설계도를 통해 TV가 만들어진 것 처럼 클래스를 작성한 다음, 클래스로부터 객체를 생성하여 사용한다.      객체를 사용한다는 것은 객체가 가지고 있는 속성(변수)과 기능(메서드)을 사용한다는 뜻     2.2 객체와 인스턴스   1 2 3 객체: 모든 인스턴스를 대표하는 일반적 용어 인스턴스: 특정 클래스로부터 생성된 객체(예: TV 클래스로부터 생성된 객체는 Tv 인스턴스) 인스턴스화: 클래스로부터 객체를 만드는 과정      클래스(설계도)      인스턴스,객체(제품)      2.3 객체의 구성요소 - 속성과 기능   객체(사물) = 속성(변수) + 기능(메서드)   TV 일때      속성: 크기, 길이, 높이, 색상, 볼륨, 채널등   기능: 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등   Tv 클래스 = Tv 설계도   1 2 3 4 5 6 7 8 9 10 11 12 13 class Tv{ \t// 변수 시작 \tStirng color; \tboolean power; \tint channel; \t// 변수 끝  \t// 메서드 시작 \tvoid power() { power = !power; } \tvoid channelUp() { channel++; } \tvoid channelDown() { channel--; } \t// 메서드 끝 }  변수 3개 + 메서드 3개 ⇒ 멤버 변수 6개   2.4 객체의 생성과 사용   1. 객체의 생성   1 2 3 4 5 6 7 8 클래스명 변수명;           // 클래스의 객체를 참조하기 위한 참조변수를 선언 변수명 = new 클래스명();   // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장  Tv t;                  // Tv 클래스 타입의 참조변수 t를 선언 t = new Tv();          // Tv 인스턴스를 생성한 후, 생성된 Tv 인스턴스의 주소를 t에 저장  // 위의 두줄을 아래 처럼 사용 가능 Tv t = new Tv(); // Tv 객체를 생성           Tv t;       → 변수선언       t 는 참조변수 → 리모콘이라고도 한다.       Tv 는 기본형이 아님. 따라서, 참조형.            t = new Tv();       → Tv 객체 생성       new 연산자는 객체를 만들고 객체의 주소를 반환한다(0x100)              객체를 사용하려면 반드시 참조변수(리모콘)가 필요하다.   생성된 객체와 참조변수를 연결해줘야한다(‘=’(대입연산자) 사용)   참조변수 t를 통해 TV인스턴스에 접근 할 수 있다.   인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다.   2. 객체의 사용(사용이란 변수, 메서드 사용)   1 2 3 t.channel = 7;     // Tv 인스턴스의 멤버변수 channel 의 값을 7로 한다. =&gt; 변수사용 t.channelDown();   // Tv 인스턴스의 메서드 channelDown()을 호출한다.  =&gt; 메서드사용(메서드호출) System.out.println(\"현재 채널은 \" + t.channel + \" 입니다.\");   과정     클래스 작성(설계도 작성)   객체 생성(제품 생성)   객체 사용(제품 사용)   인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.   TvTest.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Tv {       // Tv의 속성(멤버변수)       String color;           \t// 색상       boolean power;         \t// 전원상태(on/off)       int channel;           \t// 채널        // Tv의 기능(메서드)       void power()   { power = !power; }  // TV를 켜거나 끄는 기능을 하는 메서드        void channelUp()   {  ++channel; }  // TV의 채널을 높이는 기능을 하는 메서드       void channelDown() { --channel; }   // TV의 채널을 낮추는 기능을 하는 메서드   }  class TvTest {        public static void main(String args[]) {              Tv t;                  // Tv인스턴스를 참조하기 위한 변수 t를 선언                    t = new Tv();          // Tv인스턴스를 생성한다.              t.channel = 7;         // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.              t.channelDown();       // Tv인스턴스의 메서드 channelDown()을 호출한다.              System.out.println(\"현재 채널은 \" + t.channel + \" 입니다.\");        }  }       TvTest3.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Tv {       // Tv의 속성(멤버변수)       String color;           // 색상       boolean power;          // 전원상태(on/off)       int channel;          \t // 채널        // Tv의 기능(메서드)       void power()   { power = !power; }  // TV를 켜거나 끄는 기능을 하는 메서드       void channelUp()   {  ++channel; }  // TV의 채널을 높이는 기능을 하는 메서드       void channelDown() {  --channel; }  // TV의 채널을 낮추는 기능을 하는 메서드   }  class TvTest3 { \tpublic static void main(String args[]) { \t\tTv t1 = new Tv(); \t\tTv t2 = new Tv(); \t\tSystem.out.println(\"t1의 channel값은 \" + t1.channel + \"입니다.\"); \t\tSystem.out.println(\"t2의 channel값은 \" + t2.channel + \"입니다.\");  \t\tt2 = t1;\t\t// t1이 저장하고 있는 값(주소)을 t2에 저장한다. \t\tt1.channel = 7;\t// channel 값을 7로 한다. \t\tSystem.out.println(\"t1의 channel값을 7로 변경하였습니다.\");  \t\tSystem.out.println(\"t1의 channel값은 \" + t1.channel + \"입니다.\"); \t\tSystem.out.println(\"t2의 channel값은 \" + t2.channel + \"입니다.\"); \t} }           Tv t1 = new Tv();       Tv t2 = new Tv();       → 객체마다 별도의 저장공간이 생긴다 (주소가 다름)            t2 = t1;       → t1 이 저장하고 있는 객체의 주소를 t2 에 저장          위의 예제에서 알 수 있듯이, 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것은 가능하지만 하나의 참조변수로 여러개의 인스턴스를 가리키는 것은 불가능하다.    2.5 객체배열   객체도 배열로 다루는 것이 가능하다. 이를 ‘객체 배열’ 이라고 한다. 그렇다고 객체 배열 안에 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다. 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열인 것이다.   객체 배열 == 참조변수 배열   1 2 3 4 Tv tv1, tv2, tv3;  // Tv 타입 참조변수 * 3 Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열   1 2 3 4 5 6 7 // tvArr // 0x100  tvArr[0] = new Tv(); // 0x200 tvArr[1] = new Tv(); // 0x300 tvArr[2] = new Tv(); // 0x400  Tv[] tvArr = { new Tv(), new Tv(), new Tv() };   객체 생성   1 2 3 Tv t1 = new Tv(); // 0x100 Tv t2 = new Tv(); // 0x200 Tv t3 = new Tv(); // 0x300      객체 배열 생성   1 2 3 4 Tv tvArr = new Tv[3]; tvArr[0] = new Tv(); tvArr[1] = new Tv(); tvArr[2] = new Tv();      객체배열을 만들었다고 해서 그 안에 객체들이 자동으로 들어가는게 아니다. 따로 넣어줘야함   객체배열을 만드는 것과 객체를 만드는 것을 혼동하지 말 것!   2.6 클래스의 또 다른 정의   클래스의 정의(1) - 데이터와 함수의 결합      설계도   데이터와 함수의 결합   사용자정의 타입      변수: 하나의 데이터를 저장할 수 있는 공간   배열: 같은 종류(같은 타입)의 여러 데이터를 하나로 저장할 수 있는 공간   구조체: 서로 관련된 여러 데이터(종류 관계x, 다른 타입도 ok)를 하나로 저장할 수 있는 공간   클래스: 데이터와 함수의 결합(구조체(변수(데이터))+함수(메서드))      클래스의 정의(2) - 사용자정의 타입   사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.   1 2 3 4 5 class Time { \tint hour; \tint minute; \tint second; }      왼쪽은 비객체지향적 코드, 오른쪽은 객체지향적 코드   객체지향적 코드는 서로 관련된 값을 강하게 묶을 수 있다      ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP/",
        "teaser": ""
      },{
        "title": "Spring Security",
        "excerpt":"스프링 시큐리티   → 다양한 방식으로 사용자 정보를 유지할 수 있는 방법을 제공      세션(HttpSession) 기반: 사용자 정보는 서버에서 보관, 필요시 설정을 통해서 제어       1. 스프링 시큐리티를 이용하는 프로젝트   build.gradle   1 implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity5'   application.yml   1 2 3 4 5 6 7 8 9 logging:   level:     com:       springframework:         security:           web:             trace       project:         debug   security 관련 부분은 로그 레벨을 낮게 설정해서 자세한 로그 확인   위의 설정을 완료하면 프로젝트를 실행 시 다음과 같이 중간에 패스워드 하나가 출력됨      생성된 패스워드는 user 계정의 패스워드 (임시 패스워드 역활을 함)   localhost:8080/login 의 경로로 접근 했을 때 아래와 같은 화면이 보인다.          참고) 브라우저에서 강제로 로그아웃하고 싶을 땐, 개발자 도구의 Application탭에서 Cookies 의 JSESSIONID 를 강제 삭제한다   쿠키들 중에 톰캣은 JSESSIONID 라는 이름의 쿠키를 사용       1.1 시큐리티 설정 클래스 작성   SecurityConfig 클래스 추가   해당 클래스에는 시큐리티 관련 기능을 쉽게 설정하기 위해 WebSecurityConfigurerAdapter 라는 클래스를 상속으로 처리. WebSecurityConfigurerAdapter 클래스는 주로 override 를 통해서 여러 설정 조정   config/SecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.project.netflix.config;  import lombok.extern.log4j.Log4j2; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder;  @Configuration @Log4j2 public class SecurityConfig extends WebSecurityConfigurerAdapter {  }        1.2 확인을 위한 SampleController   SampleController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.project.netflix.controller;  import lombok.extern.log4j.Log4j2; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping;  @Controller @Log4j2 @RequestMapping(\"/sample\") public class SampleController {      // 로그인을 하지 않은 사용자도 접근할 수 있는     @GetMapping(\"/all\")     public void exAll() {         log.info(\"all..............\");     }      // 로그인한 사용자만이 접근할 수 있는     @GetMapping(\"/member\")     public void exMember() {         log.info(\"member..............\");     }      // 관리자 권한이 있는 사용자만이 접근할 수 있는     @GetMapping(\"/admin\")     public void exAdmin() {         log.info(\"admin..............\");     } }    templates 도 작성       1.3 스프링 시큐리티 용어와 흐름   Filter1,2,3…N → Authentication Manager → AuthenticationProvider → UserDetailsService   Authentication Manager(인증 매니저): 핵심 역할   AuthenticationProvider: 인증 매니저가 어떻게 동작해야 하는지를 결정   UserDetailsService: 실제 인증   스프링 시큐리티의 핵심 개념은 인증(Authentication)과 인가(Authorization)   예시) 은행에 금고가 하나 있고, 사용자가 금고의 내용을 열어본다 가정하였을 때      사용자는 은행에 가서 자신이 어떤 사람인지 자신의 신분증으로 자신을 증명   은행에서는 사용자의 신분을 확인   은행에서 사용자가 금고를 열어 볼 수 있는 사람인지를 판단   만일 적절한 권리나 권한이 있는 사용자의 경우 금고를 열어줌   1은 인증(자신을 증명), 3은 인가(사용자에게 일종의 허가를 해 주는 과정)       필터와 필터 체이닝   스프링 시큐리티에서 필터는 스프링의 빈과 연동할 수 있는 구조로 설계됨   여러 개의 필터가 Filter Chain 이라는 구조로 Request 를 처리하게 됨. 개발 시에 필터를 확장하고 설정하면 스프링 시큐리티를 이용해서 다양한 형태의 로그인 처리가 가능하게 됨       인증을 위한 AuthenticationManager(AM)   필터의 핵심적인 동작은 AuthenticationManager을 통해서 인증이라는 타입의 객체로 작업   AuthenticationManager가 가진 인증 처리 메서드는 파라미터,리턴 타입 모두 Authentication.   인증: 스스로 증명하다 (= 주민등록증)   예시) 로그인 하는 과정에서는 사용자의 아이디/패스워드로 자신이 어떤 사람인지 전달. 검증하는 행위는 AuthenticationManager를 통해 이루어짐   스프링 시큐리티 필터의 주요 역할은 인증 관련된 정보를 토큰이라는 객체로 만들어서 전달. UsernamePasswordAuthenticationToken 의 동작      request 를 이용해 사용자의 아이디와 패스워드 받음   아이디와 패스워드로 UsernamePasswordAuthenticationToken 라는 객체 생성   객체를 AuthenticationManager 의 authenticate() 에 전달   AuthenticationManager 는 다양한 방식으로 인증처리 방법을 제공      데이터베이스 이용   메모리상에 있는 정보를 활용   AuthenticationProvider 는 전달되는 토큰의 타입을 처리할 수 있는 존재인지를 확인하고 authenticate() 를 수행   AuthenticationProvider 는 내부적으로 UserDetailsService 를 이용. UserDetailsService는 실제로 인증을 위한 데이터를 가져오는 역할       인가와 권한/접근 제한   인증처리 단계가 끝나면 사용자의 권한이 적절한지 확인   인증: 사용자가 스스로 자신을 증명하는 것   인가: 허가의 의미   AuthenticationManager 의 authenticate() 메서드의 리턴값은 Authentication(인증)   이 인증 정보에는 Roles 라는 권한에 대한 정보가 있음. 이 정보로 사용자가 원하는 작업을 할 수 있는지 허가하게 되는데 이러한 행위를 Access-Control(접근 제한)이라고 함   단계1. 사용자는 원하는 URL 을 입력   단계2. 스프링 시큐리티에서는 인증/인가가 필요하다고 판단하고(필터에서 판단) 사용자가 인증하도록 로그인 화면 보여줌      올바른 사용자라고 인증되면 사용자의 정보를 Authentication 타입으로 전달(인증)   전달된 객체로 사용자가 적절한 권한이 있는지 확인(인가)   단계3. 정보가 전달된다면 AuthenticationManager가 적절한 AuthenticationProvider를 찾아서 인증을 시도         2. 스프링 시큐리티 커스터마이징       2.1 반드시 필요한 PasswordEncoder   패스워드를 암호화   BCryptPasswordEncoder 는 bcrypt 라는 해시 함수를 이용해서 패스워드를 암호화하는 목적으로 설계된 클래스. BCryptPasswordEncoder 로 암호화된 패스워드는 복호화가 불가능하고 매번 암호화된 값도 다름.   SecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.project.netflix.config;  import lombok.extern.log4j.Log4j2; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder;  @Configuration @Log4j2 public class SecurityConfig extends WebSecurityConfigurerAdapter {      @Bean     PasswordEncoder passwordEncoder() {         return new BCryptPasswordEncoder();     } }        2.2 AuthenticationManager 설정   SecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.project.netflix.config;  import lombok.extern.log4j.Log4j2; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder;  @Configuration @Log4j2 public class SecurityConfig extends WebSecurityConfigurerAdapter {      @Bean     PasswordEncoder passwordEncoder() {         return new BCryptPasswordEncoder();     }      @Override     protected void configure(AuthenticationManagerBuilder auth) throws Exception {          // 사용자 계정은 user1         auth.inMemoryAuthentication().withUser(\"user1\")                 // 1111 패스워드 인코딩 결과                 .password(\"$2a$10$yfgSY/2154i6Tf9/s83PCeCB/xo1L1/7dtGv1XG2mN4l3Qwlz05Ze\")                 .roles(\"USER\");     } }        2.3 인가가 필요한 리소스 설정   SecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.project.netflix.config;  import lombok.extern.log4j.Log4j2; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder;  @Configuration @Log4j2 public class SecurityConfig extends WebSecurityConfigurerAdapter {      ...      @Override     protected void configure(HttpSecurity http) throws Exception {         http.authorizeRequests()                 .antMatchers(\"/sample/all\").permitAll()                 .antMatchers(\"/sample/member\").hasRole(\"USER\");          http.formLogin();     }      ... }    http.authorizeRequests()   인증이 필요한 자원들을 설정   antMatchers(“/*”)**   앤트 스타일의 패턴으로 원하는 자원을 선택   permitAll()   모든 사용자에게 허락   http.formLogin();   인가/인증에 실패시 로그인 화면       2.4 CSRF 설정   스프링 시큐리티는 CSRF 라는 공격을 방어하기 위해 임의의 값을 만들어 이를 GET 방식을 제외한 모든 요청 방식(POST,PUT,DELETE)에 포함시켜야만 정상적인 동작을 함   CSRF(Cross Site Request Forgery)공격: 사이트간 요청 위조   form 태그를 이용하는 방식에서 CSRF 토큰이 보안상으로 권장됨. REST방식에서는 매번 CSRF 토큰의 값을 알아내야 하는 불편함이 있기 때문에 경우에 따라 CSRF 토큰의 발행을 하지 않는 경우도 있음       csrf토큰 비활성화   SecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.project.netflix.config;  import lombok.extern.log4j.Log4j2; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder;  @Configuration @Log4j2 public class SecurityConfig extends WebSecurityConfigurerAdapter {      ...      @Override     protected void configure(HttpSecurity http) throws Exception {         http.authorizeRequests()                 .antMatchers(\"/sample/all\").permitAll()                 .antMatchers(\"/sample/member\").hasRole(\"USER\");          http.formLogin();         http.csrf().disable();         http.logout();     }      ... }    http.csrf().disable();   예제에서는 REST방식으로 이용할 수 있는 보안 설정을 다루기 위해 CSRF 토큰을 방행하지 않는 방식으로 설정       2.5 logout 설정   http.logout();   logout() 에서 주의해야 할 점은 CSRF 토큰을 사용할 때 POST 방식으로만 로그아웃   CSRF 토큰을 disable() 로 비활성화 시키면 GET 방식으로도 로그아웃 할 수 있음         3. 프로젝트를 위한 JPA 처리   Member.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.project.netflix.entity;  import lombok.*;  import javax.persistence.*; import java.util.HashSet; import java.util.Set;  @Entity @AllArgsConstructor @NoArgsConstructor @Builder @Getter @ToString public class Member extends baseEntity {  \t@Id     private String email;      private String password;      private String name;      private Boolean fromSocial;      @ElementCollection(fetch = FetchType.LAZY)     @Builder.Default     private Set&lt;MemberRole&gt; roleSet = new HashSet&lt;&gt;();      public void addMemberRole(MemberRole memberRole) {         roleSet.add(memberRole);     }  }   MemberRole.java   1 2 3 4 5 package com.project.netflix.entity;  public enum MemberRole {     USER, MANAGER, ADMIN }       3.1 Repository 와 더미데이터 추가하기   더미데이터 추가시 회원은 여러 개의 권한을 가질 수 있어야 함을 유의하며 작성   MemberRepository.java   1 2 3 4 5 6 7 package com.project.netflix.repository;  import com.project.netflix.entity.Member; import org.springframework.data.jpa.repository.JpaRepository;  public interface MemberRepository extends JpaRepository&lt;Member, String&gt; { }   security/MemberTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.project.netflix.security;  import com.project.netflix.entity.Member; import com.project.netflix.entity.MemberRole; import com.project.netflix.repository.MemberRepository; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.security.crypto.password.PasswordEncoder;  import java.util.stream.IntStream;  @SpringBootTest public class MemberTests {      @Autowired     private MemberRepository memberRepository;      @Autowired     private PasswordEncoder passwordEncoder;      @Test     public void insertDummies() {  \t\t// 1~80: USER         // 81~90: USER, MANAGER         // 91~100: USER, MANAGER, ADMIN          IntStream.rangeClosed(1, 100).forEach(i -&gt; {             Member member = Member.builder()                     .email(\"user\" + i + \"@gmail.com\")                     .name(\"user\" + i)                     .fromSocial(false)                     .password(passwordEncoder.encode(\"1111\"))                     .build();              member.addMemberRole(MemberRole.USER);             if (i &gt; 80) {                 member.addMemberRole(MemberRole.MANAGER);             }             if (i &gt; 90) {                 member.addMemberRole(MemberRole.ADMIN);             }             memberRepository.save(member);         });     } }       3.2 회원 데이터 조회 테스트   MemberRepository.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.project.netflix.repository;  import com.project.netflix.entity.Member; import org.springframework.data.jpa.repository.EntityGraph; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query;  import java.util.Optional;  public interface MemberRepository extends JpaRepository&lt;Member, String&gt; {      @EntityGraph(attributePaths = {\"roleSet\"}, type = EntityGraph.EntityGraphType.LOAD)     @Query(\"select m from Member m where m.fromSocial = :social and m.email = :email\")     Optional&lt;Member&gt; findByEmail(String email, boolean social); }   참고) @EntityGraph   JPA 를 쓰다가 보면 LAZY 패치타입으로 relation 이 달려 있는 entity 를 n+1 문제 없이 한번에 가져오고 싶을 때가 있다. 평소에는 LAZY 를 쓰지만 특정 시나리오에서는 한번에 패치하는게 필요하기도 하다. 이럴때 repository 메소드에 @EntityGraph만 붙이면 손쉽게 join 해서 한 번에 패치해 옴   @EntityGraph의 type은 EntityGraph.EntityGraphType.FETCH와 EntityGraph.EntityGraphType.LOAD 2가지가 있다.      FETCH: entity graph에 명시한 attribute는 EAGER로 패치하고, 나머지 attribute는 LAZY로 패치   LOAD: entity graph에 명시한 attribute는 EAGER로 패치하고, 나머지 attribute는 entity에 명시한 fetch type이나 디폴트 FetchType으로 패치 (e.g. @OneToMany는 LAZY, @ManyToOne은 EAGER 등이 디폴트이다.)         4. 시큐리티를 위한 UserDetailsService   일반적인 아이디/패스워드와 스프링 시큐리티의 차이점      스프링 시큐리티에서는 회원이나 계정에 대해 User 라는 용어 사용   username 사용            단어 자체가 회원을 구별할 수 있는 식별 데이터를 의미           username 과 password 동시에 사용하지 않음            스프링 시큐리티는 UserDetailsService 를 이용해서 회원의 존재만을 우선적으로 가져오고, 이후에 password 가 틀리면 Bad Cridential(잘못된 자격증명) 이라는 결과를 만들어 냄(인증)           username, password 인증 과정이 끝나면 원하는 자원(URL)에 접근할 수 있는 권한이 있는지 확인하고 인가 과정을 실행(Access Denied 과 같은 결과 생성됨)   위의 과정에서 가장 핵심은 UserDetailsService       4.1 UserDetails 인터페이스   loadUserByUsername()   → username 이라는 회원 아이디와 같은 식별 값으로 회원 정보를 가져옴   → 리턴 타입: UserDetails 타입      getAuthorities(): 사용자가 가지는 권한에 대한 정보   getPassword(): 인증을 마무리하기 위한 패스워드 정보   getUsername(): 인증에 필요한 아이디와 같은 정보   계정 만료 여부: 사용 불가능 계정인지 알 수 있는 정보   계정 잠김 여부: 현재 계정의 잠김 여부   Member 를 처리할 수 있는 방법      기존 DTO 클래스에 UserDetails 인터페이스를 구현하는 방법   DTO 와 같은 개념으로 별도의 클래스를 구성하고 이를 활용하는 방법 (선호!)   security/dto/AuthMemberDTO.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.project.netflix.security.dto;  import lombok.Getter; import lombok.Setter; import lombok.ToString; import lombok.extern.log4j.Log4j2; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.User;  import java.util.Collection;  @Log4j2 @Getter @Setter @ToString public class AuthMemberDTO extends User {      private String email;      private String name;      private boolean fromSocial;      public AuthMemberDTO(             String username,             String password,             boolean fromSocial,             Collection&lt;? extends GrantedAuthority&gt; authorities) {         super(username, password, authorities);         this.email = username;         this.fromSocial = fromSocial;     }  }   User 클래스를 상속, 부모 클래스인 User 클래스의 생성자를 호출할 수 있는 코드 생성   AuthMemberDTO 는 DTO 역할도 수행하고 스프링 시큐리티에서 인가/인증 작업에 사용 (password 는 부모 클래스를 사용하므로 멤버 변수로 선언하지 않음)       4.2 UserDetailsService 구현   Member 가 AuthMemberDTO 라는 타입으로 처리된 가장 큰 이유는 사용자의 정보를 가져오는 핵심적인 역할을 하는 UserDetailsService 라는 인터페이스 때문   스프링 시큐리티의 구조에서 인증을 담당하는 AuthenticationManager 는 내부적으로 UserDetailsService 를 호출해서 사용자의 정보를 가져옴   JPA 로 사용자의 정보를 가져오려면 UserDetailsService가 이용하는 구조로 작성   SecurityUserDetailsService.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.project.netflix.security.service;  import com.project.netflix.entity.Member; import com.project.netflix.repository.MemberRepository; import com.project.netflix.security.dto.AuthMemberDTO; import lombok.RequiredArgsConstructor; import lombok.extern.log4j.Log4j2; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service;  import java.util.Optional; import java.util.stream.Collectors;  @Log4j2 @Service @RequiredArgsConstructor public class SecurityUserDetailsService implements UserDetailsService {      private final MemberRepository memberRepository;      @Override     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {          log.info(\"SecurityUserDetailsService loadUserByUsername: \" + username);          Optional&lt;Member&gt; result = memberRepository.findByEmail(username, false);          if (!result.isPresent()) {             throw new UsernameNotFoundException(\"Check Email or Social\");         }          Member member = result.get();          log.info(\"-------------------------\");         log.info(member);          AuthMemberDTO authMember = new AuthMemberDTO(                 member.getEmail(),                 member.getPassword(),                 member.isFromSocial(),                 member.getRoleSet().stream()                         .map(role -&gt; new SimpleGrantedAuthority(\"ROLE_\"+role.name()))                         .collect(Collectors.toSet())         );          authMember.setName(member.getName());          return authMember;     } }   @Service 를 사용해서 자동으로 스프링에서 빈으로 처리될 수 있게 했다.      MemberRepository 를 주입받을 수 있는 구조로 변경, @RequiredArgsConstructor 처리   username 이 실제로는 email 을 의미   사용자가 존재하지 않으면 UsernameNotFoundException으로 처리   Member 를 UserDetails 타입으로 처리하기 위해 AuthMemberDTO 타입으로 변환   MemberRole 은 스프링 시큐리티에서 사용하는 SimpleGrantedAuthority 로 변환  ","categories": ["Spring"],
        "tags": ["Java","Spring","JPA"],
        "url": "/spring/Java-SpringSecurity/",
        "teaser": ""
      },{
        "title": "객체지향개념(변수와 메서드)",
        "excerpt":"3. 변수와 메서드   3.1 선언위치에 따른 변수의 종류   영역엔 두가지가 있다.      클래스 영역: 인스턴스 변수(iv), 클래스 변수(cv = static + iv)   메서드 영역: 지역 변수(lv)   1 2 3 4 5 6 7 8 9 10 11 12 class Variables { \t// 변수선언 시작 \tint iv;               // 인스턴스 변수 \tstatic int cv;        // 클래스 변수(static변수, 공유변수) \t// 변수 선언 끝  \t// 메서드 선언 시작 \tvoid method() { \t\tint lv = 0;         // 지역변수 \t} \t// 메서드 선언 끝 }   lv 는 변수 선언 시점부터 메서드 종료되는 시점까지 유효하다   iv 의 생성시기***  중요하다!   객체는 iv 를 여러개 묶어 놓은 것(hour, minute, second 모두 iv 이다)      클래스가 메모리에 올라갈 때 → 클래스가 필요할 때 → 설계도가 필요할 때 → 객체를 생성하기 전에!       3.2 클래스 변수와 인스턴스 변수   선언위치 영역      클래스 영역: 인스턴스 변수(iv), 클래스 변수(cv = static + iv)   메서드 영역: 지역 변수(lv)       카드 클래스를 작성하기 위해선 카드의 속성과 기능을 알아야 함   카드의 속성: 숫자, 무늬, 높이, 폭      숫자, 무늬: 개별 (객체마다 다르게 유지되어야 함)   폭, 높이: 모든 객체 공통       인스턴스 변수(iv): 각기 다른 값을 유지, 개별적 (숫자, 무늬)   클래스 변수(cv): 공통된 값을 가짐, 공통적 (폭, 높이)       iv 는 객체마다 만들어지고 cv 는 공통으로 하나만 만들어진다.   1 2 3 4 5 6 7 8 9 class Card { \t// 개별 \tString kind; \tint number;  \t// 공통 \tstatic int width = 100; \tstatic int height = 250; }       Ex6_3.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Ex6_3 { \tpublic static void main(String args[]) { \t\t// 객체 생성 없이 사용 가능 (클래스 변수는 자동으로 만들어짐) \t\tSystem.out.println(\"Card.width = \" + Card.width); \t\tSystem.out.println(\"Card.height = \" + Card.height);  \t\tCard c1 = new Card(); \t\tc1.kind = \"Heart\"; \t\tc1.number = 7;  \t\tCard c2 = new Card(); \t\tc2.kind = \"Spade\"; \t\tc2.number = 4;  \t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\"); \t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\"); \t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다.\"); \t\tc1.width = 50;    // 코드를 봤을 땐 iv 같아 보이지만 실제론 cv 이므로 c1, c2 모두 바뀜! \t\tc1.height = 80; \t\t// 아래와 같이 적는게 좋은 코드!! \t\t// Card.width = 50; \t\t// Card.height = 80;  \t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\"); \t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\"); \t} }  class Card { \tString kind; \tint number; \tstatic int width = 100; \tstatic int height = 250; }       클래스 변수를 사용할 때는 클래스이름.클래스변수(Card.width) 와 같이 사용하는 것이 좋다   1 2 3 4 5 6 7 8 9 10 11 12 13 // 객체 생성 Card c = new Card();  // 객체 사용 c.kind = \"HEART\"; c.number = 5;  // 틀린건 아니지만 권장하지 않음 // c.width = 100; // c.height = 250; // 아래 코드와 같이 쓰는게 좋은 코드 (클래스 변수인지 알아보기 편함!) Card.width = 100; Card.height = 250;       3.3 메서드   정의      문장들을 묶어놓은 것.            작업단위로 문장들을 묶어서 이름 붙인 것       별도의 메서드를 정의하고 메서드를 호출함으로써 코드의 중복을 삭제 할 수 있음           1 2 3 4 5  static void printArr(int[] numArr) {       }       printArr(numArr); // 메서드 호출(사용)           값(입력)을 받아서 처리하고, 결과를 반환(출력)            함수 = 메서드(객체지향개념에서 함수를 메서드라 함)       함수와 메서드의 차이점? → 메서드는 반드시 클래스 안에 있어야 함, 함수는 클래스에 독립적           1 2 3 4 5 6  // 차례대로  // 반환타입(출력), 메서드 이름, 매개변수선언(입력)  int add (int x, int y) {  \tint result = x + y;  \treturn result;  }           메서드는 메서드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 되고 메서드 내부를 알 필요가 없다.   메서드를 내부가 보이지 않는 블랙박스라고도 한다.       메서드의 작성      반복적으로 수행되는 여러 문장을 메서드로 작성 (여러 문장으로 구성된 하나의 작업을 메서드로 만드는 것도 좋다)   하나의 메서드는 한 가지 기능만 수행하도록 작성 (코드를 하나의 의미있는 작업으로 만드는게 좋다)       메서드의 장점      코드의 중복을 줄일 수 있다   코드의 관리가 쉽다   코드를 재사용할 수 있다   코드가 간결해서 이해하기 쉬워진다       3.4 메서드의 선언과 구현   메서드 = 선언부 + 구현부         리턴 타입: 작업결과 타입(출력)   타입 변수명: 매개변수 (입력)       여러개의 매개변수(파라미터)를 전달할 때 객체로 하면 좋다   → 객체가 여러개의 값을 가지고 있으니까!       메서드 선언부   메서드의 이름 + 매개변수 선언 + 반환타입 으로 구성됨       매개변수 선언   매개변수는 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공. 입력할 값의 개수가 많다면 배열이나 참조변수를 사용   매개변수도 지역변수! (매개변수도 메서드 내에 선언된 것으로 간주되며 지역변수이다)       반환타입   메서드의 작업수행 결과(출력)인 반환값의 타입을 적는다. 반환값이 없을 경우엔 void.       메서드의 구현부   메서드를 호출했을 때 수행될 문장들을 넣음       return문   return문의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 함       지역변수   지역변수(lv): 메서드 내에 선언된 변수   1 2 3 4 5 6 7 8 9 10 // 지역변수: x, y, result int add (int x, int y) { \tint result = x + y; \treturn result; }  int multiply(int x, int y) { \tint result = x * y; \treturn result; }   각 메서드에서 사용하는 변수의 이름은 같지만 서로 다른 변수이다.       3.5 메서드의 호출   메서드를 호출해야 메서드를 실행할 수 있다   메서드 호출하는 방법: 메서드이름(값1, 값2, …);   1 2 3 4 print99danAll(); // void print99danAll()을 호출  int result = add(3, 5); // int add(int x, int y)를 호출하고, 결과를 result 에 저장 // int: 출력 / 3, 5: 입력       인자(인수)와 매개변수(파라미터)      인자: 메서드를 호출할 때 괄호 안에 지정해준 값들   인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함       메서드의 실행흐름   같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MyMathTest { \tpublic static void main(String args[]) {  \t\tMyMath mm = new MyMath();  // 먼저 인스턴스를 생성한다.  \t\tlong result1 = mm.add(5L, 3L); // 메서드를 호출한다. \t\tlong result2 = mm.subtract(5L, 3L); \t\tlong result3 = mm.multiply(5L, 3L); \t\tdouble result4 = mm.divide(5L, 3L);  \t\tSystem.out.println(\"add(5L, 3L) = \"      + result1); \t\tSystem.out.println(\"subtract(5L, 3L) = \" + result2); \t\tSystem.out.println(\"multiply(5L, 3L) = \" + result3); \t\tSystem.out.println(\"divide(5L, 3L) = \"   + result4); \t} }  class MyMath {  \tlong add(long a, long b) { \t\tlong result = a+b; \t\treturn result; \t//\treturn a + b;\t// 위의 두 줄을 이와 같이 한 줄로 간단히 할 수 있다. \t}  \tlong subtract(long a, long b) { \t\treturn a - b; \t}  \tlong multiply(long a, long b) { \t\treturn a * b; \t}  \tdouble divide(double a, double b) { \t\treturn a / b; \t}  }   메서드의 실행 흐름은 객체를 먼저 생성하고 메서드를 호출한다   따라서, add(long a, long b) 를 호출하기 위해선 MyMath mm = new MyMath(); 와 같이 인스턴스를 생성한 다음 참조변수 mm을 통해야한다.       3.6 return문   실행 중인 메서드를 종료하고 호출한 곳으로 되돌아감   1 2 3 4 5 6 7 8 9 10 void printGugudan(int dan) { \tif(!(2 &lt;= dan &amp;&amp; dan &lt;= 9)) { \t\treturn; // 호출한 곳으로 그냥 되돌아간다. \t}  \tfor(int i=1; i&lt;= 9; i++) { \t\tSystem.out.printf(\"%d * %d = %d%n\", dan, i, dan * i); \t} \t// 반환타입이 void 이므로 생략가능. 컴파일러가 자동추가 }       반환타입이 void가 아닌 경우, 반드시 return문 필요   1 2 3 4 5 6 7 8 9 10 11 int multiply(int x, int y) { \tint result = x * y; \treturn result; }  int max(int a, int b) { \tif(a &gt; b) { \t\treturn a; // 조건식이 참일 때만 실행됨. 따라서, 에러 발생! \t} \t// else { return b; } }       반환값(return value)   return문의 반환값으로 주로 변수가 오지만 항상 그런 것은 아니다.   1 2 3 4 5 6 7 8 int add(int x, int y) { \tint result = x + y; \treturn result; // 변수를 반환 }  int add(int x, int y) { \treturn x + y; // 수식이 반환 }       매개변수의 유효성 검사   메서드의 구현부를 작성할 때 매개변수의 값이 적절한 것인지 확인해야 함   매개변수의 유효성 검사는 메서드의 작성에 있어서 간과하기 쉬운 중요한 부분   1 2 3 4 5 6 7 8 float divide(int x, int y) { \t// 작업을 하기 전에 나누는 수(y)가 0인지 확인 \tif(y == 0) { \t\tSystem.out.println(\"0으로 나눌 수 없습니다.\"); \t\treturn 0; // 매개변수가 유효하지 않으므로 메서드를 종료 \t} \treturn x / (float)y; }  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP2/",
        "teaser": ""
      },{
        "title": "객체지향개념(호출스택, 기본형/참조형 매개변수, 참조형 반환타입, 클래스/인스턴스 메서드)",
        "excerpt":"3.7 JVM의 메모리 구조   JVM은 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 주요 3가지 영역은 메서드영역, 호출스택, 힙이 있다. 그 중 호출 스택에 대해 알아본다          스택(stack): 밑이 막힌 상자. 위에 차곡차곡 쌓인다.       호출스택(call stack)이란?(중요)      메서드 수행에 필요한 메모리가 제공되는 공간   메서드가 호출되면 호출스택에 메모리 할당, 메서드가 작업을 종료하면 할당되었던 메모리 공간 해제       호출스택 특징      메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.   메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.   호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.        아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.                  main 메서드가 firstMethod 메서드를 호출하면 아래 그림과 같다         main()이 실행, firstMethod() 를 호출   main()은 대기 상태, firstMethod()가 실행   이후, firstMedthod() 가 종료되면 main()이 대기 상태에서 실행 상태로 바뀜   → 아래 있는 메서드가 위의 메서드를 호출한 것. 맨 위의 메서드 하나만 실행 중, 나머지는 대기중       호출스택에 대한 예제   1 2 3 4 5 class Ex6_5 { \tpublic static void main(String[] args){ \t\tSystem.out.println(\"Hello\"); \t} }      스택이 비어있음   main()이 실행됨   main()이 println()을 호출, main()은 대기 println() 실행하고 실행이 끝나면 자신이 사용하던 메모리 반환하고 종료됨   main() 실행상태   main() 종료되고 메모리 반환, 스택이 비어짐       3.8 기본형 매개변수와 참조형 매개변수(매우 중요)   1 2 기본형 매개변수 - 변수의 값을 읽기만 할 수 있다(read only) 참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다(read &amp; write)       기본형 매개변수 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Data { int x; }  class Ex6_6 { \tpublic static void main(String[] args){ \t\tData d = new Data(); // 객체 생성 \t\td.x = 10; \t\tSystem.out.println(\"main() : x = \" + d.x); \t\t \t\tchange(d.x); // change() 호출됨 \t\tSystem.out.println(\"After change(d.x)\"); \t\tSystem.out.println(\"main() : x = \" + d.x); \t}  \tstatic void change(int x) { // 기본형 매개변수 (읽기만 가능) \t\tx = 1000; // x는 지역변수(메인메서드의 x와 변수명은 같지만 전혀 다른 변수이다) \t\tSystem.out.println(\"change() : x = \" + x); \t} }   실행결과   1 2 3 4 main() : x = 10 change() : x = 1000 After change(d.x) main() : x = 10      스택에 main 쌓임, main() 실행   참조변수 d 생성 후 Data() 객체 생성, Data 객체의 멤버변수가 x 하나만 존재   멤버변수 x 의 주소가 0x100이라고 하면 참조변수 d에 멤버변수의 주소가 저장됨. 그럼 참조변수가 x를 가리키게 됨   참조변수 d가 가리키는 객체의 x 값이 10이 됨   println() 실행   change() 실행, 지역변수 x가 10이 됨   main()과 change()의 x는 변수명은 같지만 전혀 다른 변수   x = 1000이 됨. println() 실행   after change, println() 실행 d.x는 10   main() 종료, 스택에서 제거됨       참조형 매개변수 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Data2 { int x; }  class Ex6_7 { \tpublic static void main(String[] args){ \t\tData2 d = new Data2(); // 객체 생성 \t\td.x = 10; \t\tSystem.out.println(\"main() : x = \" + d.x); \t\t \t\tchange(d); // change() 호출됨 \t\tSystem.out.println(\"After change(d)\"); \t\tSystem.out.println(\"main() : x = \" + d.x); \t}  \tstatic void change(Data2 d) { // 참조형 매개변수 (읽기&amp;쓰기 가능) \t\td.x = 1000; // x는 지역변수(메인메서드의 x와 변수명은 같지만 전혀 다른 변수이다) \t\tSystem.out.println(\"change() : x = \" + d.x); \t} }   실행결과   1 2 3 4 main() : x = 10 change() : x = 1000 After change(d) main() : x = 1000      스택에 main 쌓임, main() 실행   참조변수 d 생성 후 Data2() 객체 생성, Data2 객체의 멤버변수가 x 하나만 존재   멤버변수 x 의 주소가 0x100이라고 하면 참조변수 d에 멤버변수의 주소가 저장됨. 그럼 참조변수가 x를 가리키게 됨   참조변수 d가 가리키는 객체의 x 값이 10이 됨   println() 실행   스택에 change 쌓임. change() 실행, 참조변수 d를 change의 지역변수에 복사(주소값이 복사되는 것)   참조변수 d가 가르키는 x의 값을 1000으로 바꿈. println() 실행   after change, println() 실행 d.x는 1000   main() 종료, 스택에서 제거됨       3.9 참조형 반환타입   반환타입이 참조형이라는 것은 반환하는 값의 타입이 참조형이라는 얘긴데, 모든 참조형 타입의 값은 객체의 주소 이므로 정수값이 반환되는 것일 뿐 특별할 것은 없다.   참조형 반환타입 예시   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Data3 { int x; }  class Ex6_8 { \tpublic static void main(String[] args){ \t\tData3 d = new Data3(); // 객체 생성 \t\td.x = 10;  \t\tData3 d2 = copy(d); \t\tSystem.out.println(\"d.x =\" + d.x); \t\tSystem.out.println(\"d2.x=\" + d2.x); \t}  \tstatic Data3 copy(Data3 d) { \t\tData3 tmp = new Data3(); // 새로운 객체 tmp를 생성한다. \t\ttmp.x = d.x; // d.x의 값을 tmp.x에 복사한다. \t\treturn tmp; // 복사한 객체의 주소를 반환한다. \t} }   실행결과   1 2 d.x =10 d2.x=10      스택에 main 쌓임, main() 실행   참조변수 d 생성 후 Data3() 객체 생성, Data3 객체의 멤버변수가 x 하나만 존재   멤버변수 x 의 주소가 0x100이라고 하면 참조변수 d에 멤버변수의 주소가 저장됨. 그럼 참조변수가 x를 가리키게 됨   참조변수 d가 가리키는 객체의 x 값이 10이 됨   참조변수 d2 생성   copy() 실행. main()의 참조변수 d가 copy()의 지역변수 d에 저장됨(주소값이 복사)   참조변수 tmp에 객체 주소 저장됨(0x200)   0x100에 저장된 값이 0x200에 저장됨   반환타입이 참조형   println() 실행   main() 종료, 스택에서 제거됨          참조형 반환타입은 메서드가 '객체의 주소(정수)'를 반환한다는 것을 의미한다.       참고)   같은 클래스에 있는 main()과 copy()   Data3 d2 = copy(d);   왜 참조변수 없이 할 수 있는가? (Data3 d2 = e.copy(d); 처럼)      같은 클래스에 있기 때문   static으로 정의했기 때문   static 은 객체 생성 없이 호출 가능!       3.10       3.11 클래스 메서드(static메서드)와 인스턴스 메서드   변수와 마찬가지로 메서드 앞에 static 이 붙으면 static 메서드, 클래스 메서드라 하고 메서드 앞에 static 이 없으면 인스턴스 메서드이다.   1 2 3 4 5 6 7 8 9 10 11 class MyMath2 { \tlong a, b; \t \tlong add() { // 인스턴스 메서드 \t\treturn a + b; \t}  \tstatic long add(long a, long b) { // 클래스 메서드(static 메서드) \t\treturn a + b; \t} }          인스턴스 메서드            인스턴스 생성 후 ‘참조변수.메서드이름()’ 으로 호출                인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드           → iv: 인스턴스 변수, im: 인스턴스 메서드               메서드 내에서 인스턴스 변수(iv) 사용가능           static 메서드(클래스 메서드)                     객체 생성 없이 ‘클래스이름.메서드이름()’ 으로 호출           → Math.random() 객체 생성 안함           → 객체 생성 안하니까 참조변수 없어서 클래스이름 쓴다.               인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메서드       메서드 내에서 인스턴스 변수(iv) 사용불가               인스턴스 메서드와 스태틱 메서드는 인스턴스변수의 사용여부에 따라 구분된다   → 사용하면 인스턴스 메서드, 사용안하면 클래스(스태틱) 메서드       1 2 3 4 5 6 7 8 9 10 11 12 class MyMath2 { \tlong a, b; //인스턴스 변수(iv) \t \tlong add() { // 인스턴스 메서드 (iv 사용, iv를 사용하니까 매개변수 필요없음) \t\treturn a + b; \t}  \t\t\t\t\t// 지역 변수(lv) \tstatic long add(long a, long b) { // 클래스 메서드(static 메서드) (lv 사용) \t\treturn a + b; \t} }   위의 코드에서 인스턴스 메서드와 클래스 메서드의 차이점      static 의 여부   매개변수 여부   1 2 3 4 5 6 7 8 9 10 class MyMathTest2 { \tpublic static void main(String[] args) { \t\tSystem.out.println(MyMath2.add(200L,100L)); // 클래스메서드 호출  \t\tMyMath2 mm = new MyMath2(); // 인스턴스 생성 \t\tmm.a = 200L; \t\tmm.b = 100L; \t\tSystem.out.println(mm.add()); // 인스턴스 메서드 호출, mm: 참조변수 \t} }       클래스 메서드도 클래스 변수처럼, 객체를 생성하지 않고 ‘클래스이름.메서드이름’와 같은 식으로 호출 가능하다.   인스턴스 메서드는 객체 생성해야만 호출할 수 있다.      클래스메서드: 객체 생성 없이 호출 가능!   인스턴스 메서드: 객체 만들고 참조변수값 셋팅하고 인스턴스 메서드 호출       static메서드는 언제쓰나요?   → 인스턴스와 관계없는 작업을 할 때 클래스 메서드로 정의한다.   → 즉, iv를 사용하지 않을때       인스턴스 변수 사용여부에 따라 사용하면 인스턴스메서드, 사용안하면 스태틱(클래스)메서드               클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.       → 속성(멤버 변수) 중서 공통 속성에 static 을 붙인다.(카드 예제 참고)       클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.   클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.        메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.       → 인스턴스 멤버(iv, im)을 사용하지 않는 메서드에 static을 붙인다       1 2 3 4 5 6  class MyMath2 {  \tlong a, b;     \t  \tlong add() { return a + b; }                      // a, b는 인스턴스 변수  \tstatic long add(long a, long b) { return a + b; } // a, b는 지역 변수   }               객체는 iv의 묶음! (이해하고 말고 할 필요 없다)   인스턴스 생성은 iv생성이다   인스턴스 메서드는 iv로 작업한다       메서드 간의 호출과 참조   static 메서드는 인스턴스 변수를 사용할 수 없다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TestClass2 { \tint iv; // 객체 생성 후 사용가능 \tstatic int cv; // 언제나 사용가능  \tvoid instanceMethod() { // 인스턴스 메서드(객체 생성 후 호출 가능) \t\tSystem.out.println(iv); // 인스턴스 변수를 사용할 수 있다 \t\tSystem.out.println(cv); // 클래스 변수를 사용할 수 있다 \t}  \tstatic void staticMethod() { // static 메서드(객체 생성 없이 호출 가능) \t\tSystem.out.println(iv); // 에러!!! 인스턴스 변수를 사용할 수 없다(객체 생성 후에 호출 가능) \t\tSystem.out.println(cv); // 클래스 변수는 사용할 수 있다 \t} }       static 메서드는 인스턴스 메서드를 호출할 수 없다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TestClass { \tvoid instanceMethod() {} // 인스턴스 메서드 \tstatic void staticMethod() {} // static 메서드  \tvoid instanceMethod2() { // 인스턴스 메서드 \t\tinstanceMethod(); // 다른 인스턴스 메서드를 호출한다 \t\tstaticMethod(); // static 메서드를 호출한다 \t}  \tstatic void staticMethod2() { // static 메서드 \t\tinstanceMethod(); // 에러!!! 인스턴스 메서드를 호출할 수 없다(객체 생성 후에 사용 가능) \t\tstaticMethod(); // static 메서드는 호출할 수 있다 \t} }   인스턴스 메서드는 인스턴스 변수를 사용하기 때문에 객체 생성 없이는 사용할 수 없다   static 메서드가 인스턴스 메서드를 호출할 수 없다!       Q. static 메서드는 static 메서드 호출가능? 네   Q. static 메서드는 인스턴스 변수 사용가능? 아니요   Q. static 메서드는 인스턴스 메서드 호출가능? 아니요   Q. 왜? static 메서드는 인스턴스 멤버(iv, im)를 쓸 수 없나?   → static 메서드 호출 시 객체(iv묶음)가 없을 수도 있어서  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP3/",
        "teaser": ""
      },{
        "title": "Git 자주쓰는 명령어",
        "excerpt":"설정 정보 (Config)   사용자 정보 설정   1 2 3 4 5 6 7 # repository 마다 사용자 정보 설정 git config --local user.email \"yessm621@gmail.com\" git config --local user.name \"yessm621\"  # 전역(Global)으로 설정 git config --global user.email \"yessm621@gmail.com\" git config --global user.name \"yessm621\"   Remote 저장소   저장소 연결/삭제   1 2 3 4 5 6 7 8 # 저장소 연결 상태 확인 git remote -v  # 저장소 연결 git remote add origin https://github.com/yessm621/yessm621.github.io  # 저장소 삭제 git remote remove origin   Clone   저장소 clone   1 git clone 깃헙주소 프로젝트폴더명(생략가능)   저장소의 특정 브랜치 clone   1 git clone 깃헙주소 --branch 브랜치명 --single-branch 프로젝트폴더명   브랜치   브랜치 조회   1 2 # 생성된 모든 브랜치 조회 git branch -a   브랜치 생성과 삭제   1 2 3 4 5 6 7 8 # 로컬 브랜치 생성하고 바로 checkout git checkout -b issue1  # 브랜치 삭제 git branch -d issue1  # 브랜치 삭제(강제) git branch -D issue1   브랜치명 변경   1 git branch -m old_branch new_branch   원격 브랜치 생성과 삭제   1 2 3 4 5 6 # 로컬에 브랜치 생성된 상태에서 진행 # 원격 브랜치 생성 git push origin issue1  # 원격 브랜치 삭제 git push origin --delete issue1   원격 브랜치 동기화   1 2 # 모든 브랜치 동기화 git remote prune origin   Commit   commit 명 변경   아래 명령어 입력하고 수정한 다음 :wq 로 저장   1 git commit --amend   commit 날짜 변경   1 2 3 4 5 # 마지막 Commit 날짜를 현재 날짜로 설정 git commit --amend --no-edit --date \"$(date)\"  # 마지막 Commit 날짜를 임의의 날짜로 설정 git commit --amend --no-edit --date \"Mon 20 Aug 2018 20:19:19 KST\"   commit author 변경   1 git commit --amend --author=\"yessm621 &lt;yessm621@gmail.com&gt;\"   commit 내용 합치기   1 2 # HEAD에서 2개까지 커밋을 합침 git rebase -i HEAD~2   commit 안한 변경사항 초기화 하기   1 2 3 4 5 6 # 개별 초기화 git restore 파일명  # 모든 파일 초기화 git restore . git checkout .   commit 취소   1 git reset HEAD^   unstaging   add 취소 (stage → unstage)   1 2 3 4 5 git reset HEAD 파일명  git restore --staged {file_name}  git checkout -- 파일명   다른 브랜치를 master로 최신화   1 2 git checkout dev git rebase master   특정 commit 만 master에 추가   1 2 git checkout master git cherry-pick commit명   특정 branch를 master에 merge   1 2 git checkout master git merge branch명   history   명령어 히스토리 조회   1 git reflog  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/Git-Command/",
        "teaser": ""
      },{
        "title": "객체지향개념(오버로딩, 생성자, 생성자 this(), 참조변수 this, 변수의 초기화)",
        "excerpt":"4. 메서드 오버로딩   4.1 메서드 오버로딩이란?   한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것       대표적인 것: println()   파라미터(매개변수)만 다르다   1 2 3 4 5 6 7 8 9 10 void println() void println(boolean x) void println(char x) void println(char[] x) void println(double x) void println(float x) void println(int x) void println(long x) void println(Object x) void println(String x)       4.2 오버로딩의 조건      메서드 이름이 같아야 한다   매개변수의 개수 또는 타입이 달라야 한다   반환 타입은 영향없다(매개변수는 같고 반환타입이 다른 경우는 오버로딩이 성립되지 않는다)   위의 조건을 만족시키지 못하는 메서드는 중복정의 된 것으로 간주되어 컴파일 시 에러가 발생함       4.3 오버로딩의 예   예제1. 오버로딩 아님, 메서드 중복 정의   → 매개변수의 이름만 다를 뿐 매개변수의 타입이 같기 때문에 오버로딩 성립하지 않음   1 2 int add(int a, int b) { return a+b; } int add(int x, int y) { return x+y; }       예제2. 오버로딩 아님, 중복 정의   → 리턴타입만 다른 경우. 매개변수의 타입과 개수가 일치하기 때문에 add(3, 3)과 같이 호출하였을 때 어던 메서드가 호출된 것인지 결정할 수 없기 때문에 오버로딩으로 간주되지 않는다.   1 2 int add(int a, int b) { return a+b; } long add(int a, int b) { return (long)(a+b); }       예제3. 오버로딩 성립, 매개변수 타입이 다름   1 2 3 4 5 long add(int a, long b) { return a+b; } long add(long a, int b) { return a+b; }  add(3,3L); // 실행 add(3,3); // 오류 발생 (어떤 메서드를 호출하는지 모호하다)       예제4. 오버로딩의 올바른 예 - 매개변수는 다르지만 같은 의미의 기능수행   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 메서드 이름이 같다 = 하는 작업이 같다  class MyMath3 { \tint add(int a, int b) { \t\tSystem.out.print(\"int add(int a, int b) - \"); \t\treturn a + b; \t}  \tlong add(long a, long b) { \t\tSystem.out.print(\"long add(long a, long b) - \"); \t\treturn a + b; \t}  \tint add(int[] a) { \t\tSystem.out.print(\"int add(int[] a) - \"); \t\tint result = 0; \t\tfor(int i=0; i&lt; a.length; i++) { \t\t\tresult += a[i]; \t\t} \t\treturn result; \t} }       4.4 오버로딩의 장점      가독성이 증가한다.   하나의 이름만 기억하면 되므로 오류의 가능성을 많이 줄일 수 있다.   메서드의 이름만 보고 이름이 같으니, 같은 기능이라고 예측할 수 있다.   메서드 이름을 절약할 수 있다.       5. 생성자   5.1 생성자란?      인스턴스가 생성될 때 마다 호출되는 인스턴스 초기화 메서드   인스턴스 생성 시 수행할 작업(iv 초기화)에 사용       인스턴스 = 객체(iv 묶음)   인스턴스 초기화 = iv 초기화       1 2 3 4 5 6 7 8 Time t = new Time(); // iv 초기화 시작 t.hour = 12; t.minute = 34; t.second = 56; // iv 초기화 끝  Time t = new Time(12, 34, 56); // 생성자       생성자 특징      생성자의 이름이 클래스 이름과 같아야 한다.   리턴값이 없다 (void 안붙임)   모든 클래스는 반드시 생성자를 가져야 한다.   1 2 3 4 5 6 7 8 9 10 11 class Card { \t// 생성자1, 오버로딩 \tCard() { // 매개변수가 없는 생성자 \t\t// 인스턴스 초기화 작업 \t}  \t// 생성자2, 오버로딩 \tCard(String kind, int number) { // 매개변수가 있는 생성자 \t\t// 인스턴스 초기화 작업\t \t} }       연산자 new 가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다.   생성자는 단순히 인스턴스 변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다       1 Card c = new Card(); // 생성자 호출      연산자 new 에 의해서 메모리에 Card 클래스의 인스턴스가 생성됨   생성자 Card() 가 호출되어 수행됨   연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c 에 저장됨       5.2 기본 생성자      매개변수가 없는 생성자   생성자가 하나도 없을 때만, 컴파일러가 기본 생성자 자동 추가   1 2 클래스이름() {} // 기본 생성자 Point() {} // Point클래스의 기본 생성자   모든 클래스에는 반드시 하나 이상의 생성자가 정의되어야 한다. 만약, 생성자가 하나도 없다면 컴파일러가 기본 생성자를 자동으로 생성해준다. 기본 생성자는 매개변수가 없다.       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Data_1 { \tint value; }  class Data_2 { \tint value; \t \tData_2(int x) { // 매개변수가 있는 생성자 \t\tvalue = x; \t} }  class Ex6_11 { \tpublic static void main(String args[]) { \t\tData_1 d1 = new Data_1(); \t\t\t\t\t\t// Data_2(); 기본 생성자 호출 \t\tData_2 d2 = new Data_2(); // compile error 발생  \t\t\t\t\t\t\t\t  // -&gt; 기본생성자 추가해주면 오류 발생하지 않는다. \t} }   클래스 Data_1 에도 생성자가 없는데 왜 클래스 Data_2 에서만 에러가 날까?   → 클래스 Data_1 에는 생성자가 하나도 없어서 컴파일러가 기본 생성자를 자동 추가해준다   그러나, 클래스 Data_2 처럼 생성자가 하나라도 존재하기 때문에 기본 생성자가 없어서 오류가 난다.       클래스 만들때 기본 생성자를 항상 추가하는 습관       5.3 매개변수가 있는 생성자   생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용 할 수 있다. 인스턴스마다 각기 다른 값으로 초기화되어야하는 경우가 많기 때문에 매개변수를 사용한 초기화는 매우 유용함   1 2 3 4 5 6 7 8 9 10 11 12 13 class Car { \t// 인스턴스 변수들 \tString color; // 색상 \tString gearType; // 변속기 종류 - auto(자동), manual(수동) \tint door; // 문의 개수  \tCar() {} // 매개변수가 없는 기본 생성자 \tCar(String c, String g, int d) { // 매개변수가 있는 생성자 \t\tcolor = c; \t\tgearType = g; \t\tdoor = d; \t} }   Car인스턴스를 생성할 때 생성자 Car()를 사용한다면, 인스턴스 생성 후 인스턴스 변수들을 따로 초기화해주어야 함. 하지만, 매개변수가 있는 생성자 Car(매개변수들..)를 사용한다면 인스턴스를 생성하는 동시에 초기화도 가능       1 2 3 4 5 6 Car c = new Car(); // iv 초기화 시작 c.color = \"white\"; c.gearType = \"auto\"; c.door = 4; // iv 초기화 끝       생성자를 쓰면 위의 코드를 아래와 같이 한줄로 간단히 쓸 수 있다.   1 Car c = new Car(\"white\", \"auto\", 4);   코드를 보다 직관적이고 간결하게 만든다.          참조변수 c 가 만들어짐   new 연산자가 객체를 만듦 (color, gearType, door)   생성자가 객체 초기화하고 생성자 호출   대입(참조변수 c가 객체의 주소를 가리키게 됨)       5.4 생성자에서 다른 생성자 호출하기 - this(), this   다음 두조건을 만족하면 생성자 간에도 서로 호출이 가능하다      생성자의 이름으로 클래스이름 대신 this를 사용한다.   한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.       5.4.1 생성자 this()      생성자에서 다른 생성자 호출 할 때 사용   다른 생성자 호출시 첫 줄에서만 사용가능   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Car2 { \tString color; \tString gearType; \tint door;  \tCar2() { \t\tthis(\"white\", \"auto\", 4); // 생성자 Car2(String color, String gearType, int door) {} 호출 \t}  \tCar2(String color) { \t\tthis(color, \"auto\", 4); // 생성자 Car2(String color, String gearType, int door) {} 호출 \t}  \tCar2(String color, String gearType, int door) { \t\tthis.color = color; \t\tthis.gearType = gearType; \t\tthis.door = door; \t} }       생성자가 하는일: iv 초기화       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Car { \tString color; \tString gearType; \tint door;  \tCar() { \t\tcolor = \"white\"; \t\tgearType = \"auto\"; \t\tdoor = 4; \t}  \tCar(String color) { \t\tthis(color, \"auto\", 4); \t}  \tCar(String color, String gearType, int door) { \t\tthis.color = color; \t\tthis.gearType = gearType; \t\tthis.door = door; \t} }  class CarTest { \tpublic static void main(String[] args) { \t\tCar c1 = new Car(); \t\tCar c2 = new Car(\"blue\");  \t\tSystem.out.println(\"c1의 color=\"+c1.color+\", gearType=\"+c1.gearType+\", door=\"+c1.door); \t\tSystem.out.println(\"c2의 color=\"+c2.color+\", gearType=\"+c2.gearType+\", door=\"+c2.door); \t} }   1 2 c1의 color=white, gearType=auto, door=4 c2의 color=blue, gearType=auto, door=4       두 코드는 같은 일을 하지만 아래 코드는 생성자를 활용하여 더 간략히 함. 유지보수 쉽다.   1 2 3 4 5 6 7 8 9 Car() { \tcolor = \"white\"; \tgearType = \"auto\"; \tdoor = 4; }  Car() { \tthis(\"white\", \"auto\", 4); }       Bad Code   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car { \tString color; \tString gearType; \tint door;  \t// 위의 생성자와 아래 생성자 거의 비슷 -&gt; 코드 중복 \tCar() { \t\tcolor = \"white\"; \t\tgearType = \"auto\"; \t\tdoor = 4; \t}  \tCar(String c, String g, int d) { \t\tcolor = c; \t\tgearType = g; \t\tdoor = d; \t} }       Good Code   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car { \tString color; \tString gearType; \tint door;  \tCar() { \t\tthis(\"white\", \"auto\", 4); \t}  \tCar(String c, String g, int d)  \t\tcolor = c; \t\tgearType = g; \t\tdoor = d; \t} }       5.4.2 참조변수 this      인스턴스 자신을 가리키는 참조변수   인스턴스 메서드(생성자 포함)에서 사용가능   지역변수(lv)와 인스턴스변수(iv)를 구별할 때 사용       참고)   this() → 생성자   참조변수 this 와 전혀 다름       1 2 3 4 5 6 7 8 9 10 11 12 13 Car(String c, String g, int d) { \t(this.)color = c; // 지역변수 c의 값을 인스턴스 변수 color에 저장 \t(this.)gearType = g; \t(this.)door = d; \t//(this.) 생략가능(같은 클래스내에서) }  Car(String color, String gearType, int door) { \tthis.color = color; // 지역변수 color와 인스턴스 변수 color의 변수명이 똑같아 구별이 안됨 \tthis.gearType = gearType; \tthis.door = door; \t//(this.) 원래는 생략가능한데 변수명이 같아 구별하기 위해 붙임 }   this.color 는 인스턴스 변수이고 color 는 생성자의 매개변수로 정의된 지역변수       this 는 참조변수로 인스턴스 자신을 가리킴. 참조변수를 통해 인스턴스 멤버에 접근할 수 있는 것처럼 this로 인스턴스 변수에 접근 할 수 있다.       클래스 메서드(static메서드)는 객체 생성이 없기 때문에  iv 사용 불가. 따라서, this 사용 불가 (why? this는 객체 자신이기 때문)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyMath2 { \tlong a, b; // this.a, this.b  \tMyMath2(int a, int b) { // 생성자 \t\tthis.a = a; \t\tthis.b = b; // this 생략 불가능 (lv와 iv 를 구분하기 위해) \t}  \tlong add() { // 인스턴스 메서드 \t\treturn a + b; // return this.a + this.b; (생략가능) \t} \tstatic long add(long a, long b) { // 클래스 메서드(static메서드) \t\treturn a + b; \t} }   long a, b; → iv   this.a, this.b → iv 의 진짜 이름   this 선언 안해도 선언 가능하다(생략이 가능)       참고) this 와 this() 는 비슷하게 생겼을 뿐 완전히 다른 것. this는 참조변수, this()는 생성자이다   1 2 3 this   인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.        모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다. this(), this(매개변수) 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.       5.5 생성자를 이용한 인스턴스 복사   1 2 3 4 5 Car(Car c) { \tcolor = c.color; \tgearType = c.gearType; \tdoor = c.door; }   Car 클래스의 참조변수를 매개변수로 선언한 생성자.       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Car { \tString color; \tString gearType; \tint door;  \tCar() { \t\tthis(\"white\", \"auto\", 4); \t}  \tCar(Car c) { // 인스턴스의 복사를 위한 생성자 \t\tcolor = c.color; \t\tgearType = c.gearType; \t\tdoor = c.door; \t}  \tCar(String color, String gearType, int door) { \t\tthis.color = color; \t\tthis.gearType = gearType; \t\tthis.door = door; \t} }  class CarTest { \tpublic static void main(String[] args) { \t\tCar c1 = new Car(); \t\tCar c2 = new Car(c1); // c1의 복사본 c2를 생성  \t\tSystem.out.println(\"c1의 color=\"+c1.color+\", gearType=\"+c1.gearType+\", door=\"+c1.door); \t\tSystem.out.println(\"c2의 color=\"+c2.color+\", gearType=\"+c2.gearType+\", door=\"+c2.door); \t\tc1.door = 100; \t\tSystem.out.println(\"c1의 color=\"+c1.color+\", gearType=\"+c1.gearType+\", door=\"+c1.door); \t\tSystem.out.println(\"c2의 color=\"+c2.color+\", gearType=\"+c2.gearType+\", door=\"+c2.door); \t} }   1 2 3 4 5 c1의 color=white, gearType=auto, door=4 c2의 color=blue, gearType=auto, door=4  c1의 color=white, gearType=auto, door=100 c2의 color=blue, gearType=auto, door=4   인스턴스 c2 는 c1을 복사하여 생성된 것이므로 서로 같은 상태를 갖지만, 서로 별도의 메모리공간에 독립적으로 존재하는 인스턴스이므로 c1이 변경되어도 c2는 영향을 받지 않는다       6. 변수의 초기화   6.1 변수의 초기화      지역변수(lv)는 수동 초기화 해야함 (직접 초기화 해야함)   멤버변수(iv, cv)는 자동 초기화 된다   1 2 3 4 5 6 7 8 9 class InitTest { \tint x;       // 인스턴스 변수 \tint y = x;   // 인스턴스 변수  \tvoid method1() { \t\tint i;     //지역변수 \t\tint j = i; // 에러. 지역변수를 초기화 하지 않고 사용 \t} }              멤버변수(클래스변수, 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수는 반드시 사용하기 전에 초기화 해주어야 한다.       멤버변수(iv, cv)의 초기화           명시적 초기화: 대입연산자(=), 간단초기화       1 2 3 4  class Car {  \tint door = 4;             // 기본형 변수의 초기화  \tEngine e = new Engine();  // 참조형 변수의 초기화  }           초기화 블럭: 복잡초기화            인스턴스 초기화 블럭: {}       클래스 초기화 블럭: static {}                생성자: iv 초기화, 복잡한 초기화에 사용       1 2 3 4 5  Car(String color, String gearType, int door) { // 매개변수 있는 생성자  \tthis.color = color;  \tthis.gearType = gearType;  \tthis.door = door;  }               cv, iv 초기화엔 3가지가 있다.      자동초기화: 0으로 초기화   간단초기화: =(대입연산자)   복잡초기화            {}: 거의 안씀       static {}: cv 초기화       생성자: iv 초기화               6.2 명시적 초기화   변수 선언과 동시에 초기화하는 것   1 2 3 4 5 6 class Car { \tint door = 4; // 기본형 변수의 초기화 \tEngine e = new Engine(); // 참조형 변수의 초기화 \t \t// ... }       6.3 초기화 블럭      클래스 초기화 블럭: 클래스 변수의 복잡한 초기화에 사용   인스턴스 초기화 블럭: 인스턴스 변수의 복잡한 초기화에 사용   1 2 3 4 5 class InitBlock { \tstatic { /* 클래스 초기화 블럭 */}  \t{ /* 인스턴스 초기화 블럭 */ } }       클래스 변수 초기화 시점: 클래스가 처음 로딩 될 때 단 한번   인스턴스 변수 초기화 시점: 인스턴스가 생성될 때 마다 실행 (생성자보다 iv 초기화가 먼저 실행됨)   인스턴스 변수의 초기화는 주로 생성자를 사용하기 때문에 인스턴스 초기화 블럭은 잘 사용되지 않음   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BlockTest { \t \tstatic { \t\tSystem.out.println(\"static { }\"); \t}  \t{ \t\tSystem.out.println(\"{ }\"); \t}  \tpublic BlockTest() { \t\tSystem.out.println(\"생성자\"); \t}  \tpublic static void main(String[] args) { \t\tSystem.out.println(\"BlockTest bt = new BlockTest(); \"); \t\tBlockTest bt = new BlockTest();  \t\tSystem.out.println(\"BlockTest bt2 = new BlockTest(); \"); \t\tBlockTest bt2 = new BlockTest(); \t} }   1 2 3 4 5 6 7 static { } BlockTest bt = new BlockTest(); { } 생성자 BlockTest bt2 = new BlockTest(); { } 생성자       1 2 3 4 5 6 7 8 9 10 class StaticBolokTest { \t// cv \tstatic int[] arr = new int[10]; // 명시적 초기화 \t \tstatic { // 클래스 초기화 블럭 - 배열 arr을 난수로 채운다 \t\tfor (int i = 0; i &lt; arr.length; i++) { \t\t\tarr[i] = (int)(Math.random()*10) + 1; \t\t} \t} }       6.4 멤버변수의 초기화 시기와 순서   1 2 3 4 5 클래스 변수의 초기화 시점: 클래스가 처음 로딩될 때 단 한번 초기화 된다 인스턴스 변수의 초기화 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.  클래스 변수의 초기화 순서: 기본값 -&gt; 명시적초기화 -&gt; 클래스 초기화 블럭 인스턴스 변수의 초기화 순서: 기본값 -&gt; 명시적초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자      InitTest it = new InitTest(); 를 통해 객체를 생성하면 위의 표처럼 순서대로 실행된다.   다시한번 객체가 생성되면 클래스초기화는 하지 않고 인스턴스 초기화만 실행함       초기화 순서   cv 초기화 → iv 초기화   자동(0) → 간단(=) → 복잡(static{}, 생성자)  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP4/",
        "teaser": ""
      },{
        "title": "객체지향개념(상속, 클래스간의 관계, 포함, 단일상속, Object클래스, 오버라이딩, super)",
        "excerpt":"1. 상속   1.1 상속의 정의와 장점           상속이란, 기존의 클래스로 새로운 클래스를 작성하는 것       → 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이(코드의 재사용성, 유지보수 용이)       → class Child extends Parent { }            두 클래스를 부모와 자식으로 관계를 맺어주는 것       1 2   **조상 클래스**  부모클래스, 상위클래스, 기반클래스   **자손 클래스**  자식클래스, 하위클래스, 파생된 클래스           1 2 3 4 5 6 7 8 9   class 자식클래스 extends 부모클래스 {   \t// ...   }        class Parent { }   //     자식           부모   class Child extends Parent {   \t// ...   }           자손은 조상(부모의 부모)의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)        자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다)       1 2 3 4 5   class Parent {   \tint age;   }        class Child extends Parent {}                자손의 변경은 조상에 영향을 미치지 않는다       1 2 3 4 5 6 7 8 9 10   class Parent {   \tint age;   }        class Child extends Parent {   \tvoid play() {   \t\tSystem.out.println(\"놀자\");   \t}   }   // 자식멤버 1개, 상속받은 멤버 1개               예제   1 2 3 4 class Point { \tint x; \tint y; }   Point 클래스와 상관없음   1 2 3 4 5 class Point3D { \tint x; \tint y; \tint z; }   Point 클래스를 상속 받음, Point 클래스에 변경이 있으면 영향을 받는다.   1 2 3 class Point3D extends Point { \tint z; }       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Tv { \tboolean power; // 전원상태(on/off) \tint channel;\t// 채널  \tvoid power()       {   power = !power; } \tvoid channelUp()   {   ++channel;      } \tvoid channelDown() {   --channel;      } }  class SmartTv extends Tv {  // CaptionTv는 Tv에 캡션(자막)을 보여주는 기능을 추가 \tboolean caption;     // 캡션상태(on/off) \tvoid displayCaption(String text) { \t\tif (caption) {   // 캡션 상태가 on(true)일 때만 text를 보여 준다. \t\t\tSystem.out.println(text); \t\t} \t} }  class Ex7_1 { \tpublic static void main(String args[]) { \t\tSmartTv stv = new SmartTv(); \t\tstv.channel = 10;\t\t\t// 조상 클래스로부터 상속받은 멤버 \t\tstv.channelUp();\t\t\t// 조상 클래스로부터 상속받은 멤버 \t\tSystem.out.println(stv.channel); \t\tstv.displayCaption(\"Hello, World\"); \t\tstv.caption = true;\t// 캡션(자막) 기능을 켠다.\t        \t\tstv.displayCaption(\"Hello, World\"); \t} }   자식 멤버 2개 + 부모 멤버 5개 → 7개       1.2 클래스간의 관계 - 포함관계   클래스의 관계      상속   포함       포함이란?      클래스의 멤버로 참조변수를 선언하는 것   작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.   예제1. 포함 없는 것   1 2 3 4 5 class Circle { \tint x; \tint y; \tint r; }   예제2. Circle 이 Point 를 포함   1 2 3 4 5 6 7 8 9 class Circle { \tPoint p = new Point(); \tint r; }  class Point { \tint x; \tint y; }   예제3.   1 2 3 4 5 6 class Car { \t// 아래 두 문장 모두 포함 예시 \t// 이런식으로 작성하면 복잡도가 줄어든다 \tEngine e = new Engine(); // 엔진 \tDoor[] d = new Door[4]; // 문, 문의 개수를 넷으로 가정하고 배열로 처리했다. }   포함관계로 작성하면 클래스를 작성하는 것도 쉽고 코드도 간결해서 이해하기 쉽고 코드 관리도 수월하다.       1.3 클래스 간의 관계 결정하기   클래스를 작성하는데 있어서 상속관계를 맺어 줄까? 포함관계를 맺어줄까?   → 포함이 90%, 상속은 꼭 필요할때만!   1 2 상속관계 '~은 ~이다(is-a)' 포함관계 '~은 ~을 가지고 있다(has-a)'   아래와 같이 말을 만들어보면 편하다      원(Circle)은 점(Point)이다   원(Circle)은 점(Point)을 가지고 있다   2번이 자연스럽기 때문에 포함관계로 작성하면 된다.       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Circle { // 포함 \tPoint p = new Point(); // 참조변수의 초기화 \t/* Circle() { \t\tp = new Point(); \t} */ // 생성자를 이용한 참조변수의 초기화 \tint r; }  class Circle extends Point { // 상속 \tint r; }  class Point { \tint x; \tint y; }       1.4 단일 상속      Java는 단일상속만을 허용한다.(C++은 다중상속 허용)   1 2 3 class TvDVD extends Tv, DVD { // 에러발생! 조상은 하나만 허용한다 \t// ... }   서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점이 있다.       비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Tv { \tboolean power; \t// 전원상태(on/off) \tint channel;\t\t// 채널  \tvoid power()       { \tpower = !power; } \tvoid channelUp()   { \t++channel; } \tvoid channelDown() {\t--channel; } }  class VCR { \tboolean power; \t// 전원상태(on/off)    int counter = 0; \tvoid power() { \tpower = !power; } \tvoid play()  { /* 내용생략*/ } \tvoid stop()  { /* 내용생략*/ } \tvoid rew()   { /* 내용생략*/ } \tvoid ff()    { /* 내용생략*/ } }  class TVCR extends Tv { \tVCR vcr = new VCR(); \tint counter = vcr.counter;  \t// 객체 사용 시작 \tvoid play() { \t\tvcr.play(); \t}  \tvoid stop() { \t\tvcr.stop();    }  \tvoid rew() { \t\tvcr.rew();    }  \tvoid ff() { \t\tvcr.ff();\t    } \t// 객체 사용 끝 }       1.5 Object 클래스 - 모든 클래스의 조상      부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.(컴파일러가 자동 추가 해준다)   모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다.            toString(), equals(Object obj), hashCode()…           1 2 3 4 5 6 7 8 9 class Tv { \t// ... }  // 위의 코드와 아래의 코드는 같다. // 부모 클래스가 없기 때문에 Object클래스를 상속 받음 class Tv extends Object { \t// ... }       1 2 3 4 5 6 7 8 9 10 11 12 class Circle extends Object { // 포함 \tMyPoint p = new MyPoint(); \tint r; }  public class InheritanceTest { \tpublic static void main(String[] args) { \t\t// 위아래 두문장이 똑같은 출력이다. \t\tSystem.out.println(c.toString()); // Circle@15db9742 \t\tSystem.out.println(c); // Circle@15db9742 \t} }   2. 오버라이딩  2.1 오버라이딩   상속받은 조상의 메서드를 자신에 맞게 변경하는 것   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Point { \tint x; \tint y;  \tString getLocation() { \t\treturn \"x :\" + x + \", y :\" + y; \t} }  class Point3D extends Point { \tint z;  \tString getLocation() { // 오버라이딩: 구현부{}만 변경가능(선언부 변경불가) \t\treturn \"x :\" + x + \", z :\" + z; \t} }       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyPoint3 { \tint x; \tint y; \tString getLocation() { \t\treturn \"x:\" + x + \", y:\" + y; \t} }  class MyPoint3D extends MyPoint3 { \tint z;  \t// 조상의 getLocation()을 오버라이딩 \tString getLocation() { \t\treturn \"x:\" + x + \", y:\" + y + \", z:\" + z; \t} }  public class OverrideTest { \tpublic static void main(String[] args) { \t\tMyPoint3D p = new MyPoint3D();  \t\tp.x = 3; \t\tp.y = 5; \t\tp.z = 7; \t\tSystem.out.println(p.getLocation()); \t} }   1 2 // 결과 x: 3, y: 5, z: 7       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MyPoint3 { \tint x; \tint y;  \t// Object클래스의 toString()을 오버라이딩 \tpublic String toString() { \t\treturn \"x:\" + x + \", y:\" + y; \t} }  public class OverrideTest { \tpublic static void main(String[] args) { \t\tMyPoint3D p = new MyPoint3D();  \t\tp.x = 3; \t\tp.y = 5; \t\t \t\t// 아래의 모든 결과는 동일하다. \t\tSystem.out.println(p); \t\tSystem.out.println(p.toString()); \t\tSystem.out.println(\"x:\" + p.x + \"y:\" + p.y); \t} }  // 위의 메서드와 아래 메서드의 결과는 같다 public class OverrideTest { \tpublic static void main(String[] args) { \t\tMyPoint3D p = new MyPoint3D(3, 5); \t\tSystem.out.println(p); \t} }   1 2 // 결과 x: 3, y: 5       2.2 오버라이딩의 조건   오버라이딩은 메서드의 내용만 새로 작성하는 것           선언부가 조상 클래스의 메서드와 일치해야 한다.       1 2 3 4  자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와  - 이름이 같아야 한다.  - 매개변수가 같아야 한다.  - 리턴타입이 같아야 한다.           위의 내용을 요약하면 한마디로 선언부가 같아야 한다.       접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다            접근 제어자: public, protected, private, default(접근제어자 안붙인 것)           예외는 조상 클래스의 메서드보다 많이 선언할 수 없다       2.3 오버로딩 vs 오버라이딩   오버로딩: 기존에 없는 이름이 같은데 매개변수가 다른 새로운 메서드를 정의하는 것(new)   오버라이딩: 상속받은 메서드의 내용을 변경하는 것(change, modify)   1 2 3 4 5 6 7 8 9 10 11 12 class Parent { \tvoid parentMethod() {} }  class Child extends Parent { \tvoid parentMethod() {} // 오버라이딩 \tvoid parentMethod(int i) {} // 오버로딩  \tvoid childMethod() {} // 메서드 정의 \tvoid childMethod(int i) {} // 오버로딩 \tvoid childMethod() {} // 에러, 중복정의 }       2.4 super   참조변수 super (this와 거의 비슷)      객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자) 내에서만 존재(static 메서드에서 사용 불가)   조상의 멤버를 자신의 멤버와 구별할 때 사용   1 2 this     lv와 iv 구별에 사용 super    조상멤버, 자식멤버 구별에 사용   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class SuperTest { \tpublic static void main(String[] args) { \t\tChild c = new Child(); \t\tc.method(); \t} }  class Parent { \tint x = 10; /* super.x */ }  class Child extends Parent { \tint x = 20; /* this.x */  \tvoid method() { \t\tSystem.out.println(\"x=\", x); \t\tSystem.out.println(\"this.x=\", this.x); \t\tSystem.out.println(\"super.x=\", super.x); \t} }   1 2 3 x=10 this.x=20 super.x=10   자식클래스와 부모클래스에 같은 이름의 변수가 존재할 수 있다. 이 둘의 구분은 super로 한다       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class SuperTest { \tpublic static void main(String[] args) { \t\tChild c = new Child(); \t\tc.method(); \t} }  class Parent { \tint x = 10; /* super.x, this.x 둘 다 가능 */ }  class Child extends Parent { \tvoid method() { \t\tSystem.out.println(\"x=\", x); \t\tSystem.out.println(\"this.x=\", this.x); \t\tSystem.out.println(\"super.x=\", super.x); \t} }   1 2 3 x=10 this.x=10 super.x=10   자신(child)의 x가 없고 조상(parent)의 x를 상속받았기 때문에 모두 10 이 나온다       super 와 this는 멤버를 구분할때 빼고는 거의 같다고 보면 된다(둘 다 참조변수)       2.5 super() - 조상 클래스의 생성자   super() ≠ super   super()는 this() 처럼 생성자다          조상의 생성자를 호출할 때 사용   조상의 멤버는 조상의 생성자를 호출해서 초기화       상속에서 생성자하고 초기화블럭은 상속이 안된다고 배움. 따라서, 조상의 생성자를 호출할땐 super()를 사용       1 2 3 4 5 6 7 8 9 class Point { \tint x, y;  \t// 생성자 \tPoint(int x, int y) { \t\tthis.x = x; // iv 초기화 \t\tthis.y = y; // iv 초기화 \t} }   참고) 생성자의 정의와 조건   iv 초기화에 사용, 생성자의 이름은 클래스 이름과 같아야하고 리턴값이 없고 모든 클래스는 반드시 생성자를 가진다.       1 2 3 4 5 6 7 8 9 class Point3D extends Point { \tint z;  \tPoint3D(int x, int y, int z) { \t\tthis.x = x; // 조상의 멤버 초기화 \t\tthis.y = y; // 조상의 멤버 초기화 \t\tthis.z = z; // iv 초기화 \t} }   여기서도 iv 를 초기화 하고 있는데 x, y 는 조상의 멤버이다. 근데 자손의 생성자가 x, y를 초기화 하고 있다. 자손의 생성자는 자기가 선언한 것만 초기화 해야한다. (에러는 안나지만 이렇게 쓰면 안된다!)   조상의 멤버는 조상 생성자가 초기화해야한다   위 코드는 아래와 같이 바꿔야 한다.   1 2 3 4 5 6 7 8 class Point3D extends Point { \tint z;  \tPoint3D(int x, int y, int z) { \t\tsuper(x, y); // 조상의클래스의 생성자 Point(x, y)를 호출 \t\tthis.z = z; // iv 초기화(자신의 멤버를 초기화) \t} }       **중요!** 생성자의 첫 줄에 반드시 생성자(super() 또는 this())를 호출해야 한다.   그렇지 않으면 컴파일러가 생성자의 첫 줄에 super(); 를 삽입   1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Point { \tint x; \tint y;  \tPoint() { \t\tthis(0, 0); // 생성자 호출함 \t}  \tPoint(int x, int y) { \t\t// 생성자 호출 없음! 조상의 기본생성자인 super(); 호출! \t\tthis.x = x; \t\tthis.y = y; \t} }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Point extends Object { \tint x; \tint y;  \tPoint() { \t\tthis(0, 0); // 생성자 호출함 \t}  \tPoint(int x, int y) { \t\tsuper(); // Object(); 호출 \t\tthis.x = x; \t\tthis.y = y; \t} }       매우 중요한 예제!   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class PointTest { \tpublic static void main(String[] args) { \t\tPoint3D p3 = new Point3D(1, 2, 3); \t} }  class Point { \tint x; \tint y;  \tPoint(int x, int y) { \t\tthis.x = x; \t\tthis.y = y; \t}  \tString getLocation() { \t\treturn \"x: \" + x + \", y: \" + y; \t} }  class Point3D extends Point { \tint z; \t \tPoint3D(int x, int y, int z) { \t\tthis.x = x; \t\tthis.y = y; \t\tthis.z = z; \t}  \tString getLocation() { \t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z; \t} }   위의 코드를 실행시키면 Point 의 생성자가 없다는 에러 발생   why? 모든 생성자는 첫줄에 다른 생성자를 호출해야한다. 없다면 컴파일러가 super()를 자동 추가 해준다.       위의 코드를 컴파일러가 실행시 아래 처럼 바뀐다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class PointTest { \tpublic static void main(String[] args) { \t\tPoint3D p3 = new Point3D(1, 2, 3); \t} }  class Point { \tint x; \tint y;  \tPoint(int x, int y) { \t\tsuper(); // Object();  \t\tthis.x = x; \t\tthis.y = y; \t}  \tString getLocation() { \t\treturn \"x: \" + x + \", y: \" + y; \t} }  class Point3D extends Point { \tint z; \t \tPoint3D(int x, int y, int z) { \t\tsuper(); // Point()를 호출  \t\tthis.x = x; \t\tthis.y = y; \t\tthis.z = z; \t}  \tString getLocation() { // 오버라이딩 \t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z; \t} }          Point3D p3 = new Point3D(1, 2, 3); 를 하면   Point3D(int x, int y, int z) {} 로 가고   super()가 자동생성되기때문에   Point() 를 호출한다   근데 Point 클래스에 기본 생성자인 Point() {} 없다. (컴파일러시 자동 생성 안됨, 이미 생성자가 하나 존재하기 때문에)   그래서 에러가 발생한다       따라서, 항상 클래스 만들때 기본 생성자 작성은 필수이다.(규칙! 규칙은 외워라)       에러 해결방법1.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class PointTest { \tpublic static void main(String[] args) { \t\tPoint3D p3 = new Point3D(1, 2, 3); \t} }  class Point { \tint x; \tint y;  \t// 기본생성자 작성 \tPoint() {}  \tPoint(int x, int y) { \t\tsuper(); // Object(); : Point의 조상인 Object  \t\tthis.x = x; \t\tthis.y = y; \t}  \tString getLocation() { \t\treturn \"x: \" + x + \", y: \" + y; \t} }  class Point3D extends Point { \tint z; \t \tPoint3D(int x, int y, int z) { \t\tsuper(); // Point()를 호출  \t\tthis.x = x; \t\tthis.y = y; \t\tthis.z = z; \t}  \tString getLocation() { // 오버라이딩 \t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z; \t} }       해결방법2. 이 방법이 더 좋은 방법 → 조상의 멤버는 조상이 초기화하는게 좋다   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class PointTest { \tpublic static void main(String[] args) { \t\tPoint3D p3 = new Point3D(1, 2, 3); \t} }  class Point { \tint x; \tint y;  \t// 기본생성자 작성 \tPoint() {}  \tPoint(int x, int y) { \t\tsuper(); // Object();  \t\tthis.x = x; \t\tthis.y = y; \t}  \tString getLocation() { \t\treturn \"x: \" + x + \", y: \" + y; \t} }  class Point3D extends Point { \tint z; \t \tPoint3D(int x, int y, int z) { \t\tsuper(x, y); // 조상의 생성자 Point(int x, int y)를 호출 \t\tthis.z = z; \t}  \tString getLocation() { // 오버라이딩 \t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z; \t} }  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP5/",
        "teaser": ""
      },{
        "title": "객체지향개념(package, import, 제어자, 접근제어자, 캡슐화)",
        "excerpt":"3. package와 import   3.1 패키지(package)      서로 관련된 클래스의 묶음   클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더        클래스의 실제 이름은 패키지를 포함(java.lang.String)       rt.jar 는 클래스들을 압축한 파일       rt: runtime, jar: class 파일을 묶어놓은 것       rt.jar 파일은 java9부터 사라짐           3.2 패키지의 선언   1 package 패키지명;      패키지는 소스파일의 첫 번째 문장으로 단 한번 선언   같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.   패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.       클래스 패스      클래스 파일(*.class)의 위치를 알려주는 경로        환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용       classpath(환경변수)에 패키지의 루트를 등록해줘야 함.           3.3 import문      클래스를 사용할 때 패키지 이름을 생략할 수 있다.   컴파일러에게 클래스가 속한 패키지를 알려준다.   java.lang 패키지의 클래스는 import 하지 않고도 사용할 수 있다(생략가능)            java.lang 패키지: String, Object, System, Thread…               3.4 import문의 선언   1 2 3 4 // 일반적인 소스파일(*.java)의 구성 1. package문 2. import문 3. 클래스 선언           import문을 선언하는 방법은 다음과 같다       1 2   import 패키지명.클래스명;   import 패키지명.*;           import문은 패키지문과 클래스선언의 사이에 선언한다.   import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음.   이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.       static import문(꼭 필요할때만 사용)      static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.   1 2 3 4 5 6 7 8 9 10 11 12 import static java.lang.System.out; import static java.lang.Math.*;  class Ex7_6 { \tpublic static void main(String[] args) { \t\t// System.out.println(Math.random()); \t\tout.println(random());  \t\t// System.out.println(Math.PI); \t\tout.println(PI); \t} }       4.제어자(modifier)   4.1 제어자란?           클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여       1 2   접근 제어자 public, protected, (default), private // 4개중 하나 사용가능   그 외 static, final, abstract, (native, transient, synchronized, volatile, strictfp)                하나의 대상에 여러 제어자를 같이 사용가능(단, 접근 제어자는 하나만 선택해서 사용가능)       1 2 3 4 5 6 7   public class ModifierTest {   \tpublic static final int WIDTH = 200;        \tpublic static void main(String[] args) {   \t\t// ..   \t}   }           접근제어자를 가장 먼저 쓴다 (관례적으로)           4.2 static - 클래스의, 공통적인           제어자     대상 \t의미           static \t멤버변수 \t1. 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.   2.  클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.   3.  클래스가 메모리에 로드될 때 생성된다.       \t메서드 \t1. 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.  2. static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.      1 2 3 4 5 6 7 8 9 10 11 12 class StaticTest { \tstatic int width = 200; // 클래스 변수(static 변수) \tstatic int height = 120; // 클래스 변수(static 변수)  \tstatic { // 클래스 초기화 블럭 \t\t// static 변수의 복잡한 초기화 수행 \t}  \tstatic int max(int a, int b) { // 클래스 메서드(static 메서드) \t\treturn a &gt; b ? a : b; \t} }           static int width = 200;       → 간단 초기화 (명시적 초기화)            static 메서드에서는 인스턴스 멤버들 사용할 수 없다.       → 인스턴스 멤버는 iv(인스턴스 변수), im(인스턴스 메서드) 을 의미       → 왜 인스턴스 멤버를 사용할 수 없을까?       ⇒ 인스턴스 멤버들은 객체를 생성 후 사용할 수 있기 때문에!            static 은 객체생성 없이 사용 가능함           4.3 final - 마지막의, 변경될 수 없는           제어자     대상 \t의미           final \t클래스 \t변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.  그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.       \t메서드 \t변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.       \t멤버변수, 지역변수 \t변수 앞에 final 이 붙으면, 값을 변경할 수 없는 상수가 된다.      1 2 3 4 5 6 7 8 final class FinalTest { // 조상이 될 수 없는 클래스 \tfinal int MAX_SIZE = 10; // 값을 변경할 수 없는 멤버변수(상수)  \tfinal void getMaxSize() { // 오버라이딩할 수 없는 메서드(변경불가) \t\tfinal int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수) \t\treturn MAX_SIZE; \t} }      오버라이딩: 조상메서드를 덮어쓰는 것       4.4 생성자를 이용한 final 멤버변수 초기화   final 이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 단 한번만 초기화 되도록 할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Card { \tfinal int NUMBER;\t\t// 상수지만 선언과 함께 초기화 하지 않고 \tfinal String KIND;\t\t// 생성자에서 단 한번만 초기화할 수 있다. \tstatic int width  = 100;\t \tstatic int height = 250;  \tCard(String kind, int num) {\t \t\tKIND = kind; \t\tNUMBER = num; \t}  \tCard() { \t\tthis(\"HEART\", 1); \t}  \tpublic String toString() { \t\treturn KIND +\" \"+ NUMBER; \t} }  class FinalCardTest { \tpublic static void main(String args[]) { \t\tCard c = new Card(\"HEART\", 10); //\t\tc.NUMBER = 5; : 에러발생! \t\tSystem.out.println(c.KIND); \t\tSystem.out.println(c.NUMBER); \t\tSystem.out.println(c); // System.out.println(c.toString()); \t} }       4.5 abstract - 추상의, 미완성의           제어자     대상 \t의미           abstract \t클래스 \t클래스 내에 추상 메서드가 선언되어 있음을 의미한다.       \t메서드 \t선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.      1 2 3 abstract class AbstractTest { // 추상 클래스(추상 메서드를 포함한 클래스) \tabstract void move(); // 추상 메서드(구현부가 없는 메서드) }   몸통(구현부)이 없는 메서드를 추상메서드라 하고 추상메서드 앞에는 abstract 를 붙인다.   추상메서드는 미완성 메서드(선언부만 있음), 추상메서드를 포함하는 클래스를 추상 클래스라 함       AbstractTest a = new AbstractTest();   → 에러. 추상클래스의 인스턴스 생성불가   추상클래스는 미완성 설계도 이기 때문에 객체 생성이 불가능하다!       추상클래스를 사용하려면 상속을 통해서 추상메서드를 완성해줘야함(몸통을 작성해야 함)   추상클래스를 상속받아서 완전한 클래스를 만든 후에 객체 생성 가능       4.6 접근 제어자(access modifier)   1 2 3 4 private   같은 클래스 내에서만 접근이 가능하다. (default) 같은 패키지 내에서만 접근이 가능하다. protected 같은 패키지 내에서, 그리고 다른 패키지 자손클래스에서 접근이 가능하다. public    접근 제한이 전혀 없다.   접근 범위가 넓은 쪽 순으로 나열   1 public &gt; protected &gt; (default) &gt; private       클래스 앞에는 public, (default) 만 가능   멤버들은 public, protected, (default), private 모두 가능       실습   MyParent.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package pkg1;  public class MyParent { // 접근제어자가 public \tprivate int prv;    // 같은 클래스 \tint dft;            // 같은 패키지 \tprotected int prt;  // 같은 패키지 + 자손(다른 패키지) \tpublic int pub;     // 접근제한 없음  \tpublic void printMembers() { \t\tSystem.out.println(prv); // OK \t\tSystem.out.println(dft); // OK \t\tSystem.out.println(prt); // OK \t\tSystem.out.println(pub); // OK \t} }  class MyParentTest { // 접근제어자가 (default) \tpublic static void main(String[] args) { \t\tMyParent p = new MyParent(); \t\tSystem.out.println(p.prv); // 에러. 같은 클래스가 아니기 때문에 \t\tSystem.out.println(p.dft); // OK \t\tSystem.out.println(p.prt); // OK \t\tSystem.out.println(p.pub); // OK \t} }   MyParentTest2.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package pkg2;  import pkg1.MyParent;  class MyChild extends MyParent { \tpublic void printMembers() { \t\tSystem.out.println(prv); // 에러. 같은 클래스, 같은 패키지 아니 때문에 \t\tSystem.out.println(dft); // 에러. 같은 패키지가 아니기 때문에 \t\tSystem.out.println(prt); // OK \t\tSystem.out.println(pub); // OK \t} }  public class MyParentTest2 { \tpublic static void main(String[] args) { \t\tMyParent p = new MyParent(); \t\tSystem.out.println(p.prv); // 에러. \t\tSystem.out.println(p.dft); // 에러. \t\tSystem.out.println(p.prt); // 에러. 자손이 아니기 때문에 \t\tSystem.out.println(p.pub); // OK \t} }       4.7 접근 제어자를 이용한 캡슐화   접근 제어자를 사용하는 이유           외부로부터 데이터를 보호하기 위해서            외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서       1 2 3 4 5 6 7 8 public class Time { \tpublic int hour; // 0~23 \tpublic int minute; // 0~59 \tpublic int second; // 0~59 }  Time t = new Time(); t.hour = 25; // 멤버변수에 직접 접근       1 2 3 4 5 6 7 8 9 10 11 12 public class Time { \tprivate int hour; // 접근 제어자를 private으로 하여 외부에서 직접 접근하지 못하도록 한다. \tprivate int minute; \tprivate int second;  \tpublic int getHour() { return hour; }  \tpublic void setHour(int hour) { \t\tif (hour &lt; 0 || hour &gt; 23) return; \t\tthis.hour = hour; \t} }   변수에 직접 접근을 막고 메서드를 통해서 접근 할 수 있도록 한다.   메서드를 통한 간접 접근 허용   → 접근제어자를 이용한 캡슐화       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Time { \tprivate int hour; // 0~23사이의 값을 가져야함. \tprivate int minute; \tprivate int second;  \tpublic void setHour(int hour) { \t\tif(isNotValidHour(hour)) return; \t\tthis.hour = hour; \t}  \t// 매개변수로 넘겨진 hour가 유효한지 확인해서 알려주는 메서드 \t// 내부에서만 쓰는 메서드이기 때문에 private 으로 사용 \tprivate boolean isNotValidHour(int hour) { \t\treturn hour &lt; 0 || hour &gt; 23; \t}  \tpublic int getHour() { return hour; } }  public class TimeTest { \tpublic static void main(String[] args) { \t\tTime t = new Time(); \t\t// t.hour = 100; \t\t// System.out.println(t.hour); \t\tt.setHour(21); \t\tSystem.out.println(t.getHour()); // 21  \t\tt.setHour(100); \t\tSystem.out.println(t.getHour()); // 21, 결과 안바뀜 \t} }   접근의 범위는 최대한 좁히는게 좋다       4.8 생성자의 접근 제어자       4.9 제어자(modifier)의 조합  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP6/",
        "teaser": ""
      },{
        "title": "객체지향개념(다형성, 참조변수의 형변환, instanceof연산자, 매개변수 다형성)",
        "excerpt":"5.다형성(polymorphism)   5.1 다형성이란?      여러가지 형태를 가질 수 있는 능력   조상 타입 참조 변수로 자손 타입 객체를 다루는 것(조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다)   1 2 3 4 5 6 7 8 9 10 11 12 13 class Tv { \tboolean power; \tint channel;  \tvoid power() { power = !power; } \tvoid channelUp() { ++channel; } \tvoid channelDown() { --channel; } }  class SmartTv extends Tv { \tString text; // 캡션(자막)을 보여 주기 위한 문자열 \tvoid caption() { /* 내용생략 */ } }   Tv: 부모(멤버변수 5개), SmartTv: 자식(멤버변수 7개)       원래는 아래와 같이 사용했는데,   Tv t = new Tv();   SmartTv s = new SmartTv();       다형성은 아래와 같이 사용   Tv t = new SmartTv(); // 타입 불규칙, 사용 가능!       객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?   1 2 3 4 5 SmartTv s = new SmartTv(); // 참조 변수와 인스턴스의 타입이 일치 // -&gt; 멤버가 7개이므로 7개의 기능이 있다 Tv t = new SmartTv(); // 조상 타입 참조변수로 자손 타입 인스턴스 참조 // -&gt; 멤버가 5개이므로 5개의 기능을 쓸 수 있다. // (자손에 7개의 기능이 있지만 버튼이 5개밖에 없으므로 5개의 기능만 쓸 수 있음)   부모는 자식에 비해 멤버가 같거나 적을 수 밖에 없다       잉? 멤버를 7개 쓸 수 있다가 5개 쓸 수 있는게 장점인가요?   → 장점이 될 수 있다.               자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.       1 2   Tv t = new SmartTv(); // 허용   SmartTv s = new Tv(); // 에러           기능이 7개인데 5개만 쓰는건 ok       기능이 5개인데 7개를 쓸 수 없음 error!           Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?   → 아니요. 일치하는 것이 보통이지만 일치 하지 않을 수도 있음.   Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?   → 참조변수로 사용할 수 있는 멤버의 갯수가 달라짐   Q. 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?   → 아니요. 허용되지 않음       5.2 참조변수의 형변환      사용할 수 있는 멤버의 갯수를 조절하는 것   조상 자손 관계의 참조변수는 서로 형변환 가능   1 2 자손타입 -&gt; 조상타입 : 형변환 생략가능 자손타입 &lt;- 조상타입 : 형변환 생략불가       1 2 3 class Car {} class FireEngine extends Car {} class Ambulance extends Car {}   Car 와 FireEngine 은 서로 형변환 가능   Car 와 Ambulance 는 서로 형변환 가능   FireEngine과 Ambulance는 서로 형변환 불가능! (둘 다 자식. 상속관계가 아니기 때문에)       1 2 3 4 5 FireEngine f = new FireEngine();  Car c = (Car)f; // OK. 조상인 Car타입으로 형변환(생략가능) FireEngine f2 = (FireEngine)c; // OK. 자손인 FireEngine타입으로 형변환(생략불가) Ambulance a = (Ambulance)f; // 에러. 상속관계가 아닌 클래스 간의 형변환 불가   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car { \tString color; \tint door;  \tvoid drive() { \t\tSystem.out.println(\"drive, Brrrr~\"); \t}  \tvoid stop() { \t\tSystem.out.println(\"stop!\"); \t} }  class FireEngine extends Car { \tvoid water() { \t\tSystem.out.println(\"water!!\"); \t} }   부모 멤버변수 4개 + 자식 멤버변수 1개 ⇒ 총 5개!   f 는 5개의 멤버변수에 접근 가능   c는 4개의 멤버변수에만 접근 가능(타입이 Car이기 때문에 리모컨 버튼이 4개 밖에 없음)   f2는 5개의 멤버변수에 접근 가능   a와 f는 둘 다 자식이므로 서로 형변환 불가능함 따라서, 에러 발생!       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car { \tString color; \tint door;  \tvoid drive() { \t\tSystem.out.println(\"drive, Brrrr~\"); \t}  \tvoid stop() { \t\tSystem.out.println(\"stop!\"); \t} }  class FireEngine extends Car { \tvoid water() { \t\tSystem.out.println(\"water!!\"); \t} }   1 2 3 4 5 6 7 8 9 10 11 12 13 class Ex7_7 { \tpublic static void main(String[] args) { \t\tCar car = null; \t\tFireEngine fe = new FireEngine(); \t\tFireEngine fe2 = null;  \t\tfe.water(); \t\tcar = fe; // car = (Car)fe;에서 형변환이 생략됨 \t\t// car.water(); // 컴파일 에러! Car타입의 참조변수로는 water()를 호출할 수 없다. \t\tfe2 = (FireEngine)car; // 자손타입 &lt;- 조상타입. 형변환 생략 불가 \t\tfe2.water(); \t} }   Car는 water()라는 멤버변수가 없다. 따라서 에러 발생한다   5개 → 4개 감소 안전. 생략가능   4개 → 5개 증가 안전하지 않음. 생략불가       예제1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Ex7_7 { \tpublic static void main(String args[]) { \t\tCar car = null; \t\tFireEngine fe = new FireEngine(); \t\tFireEngine fe2 = null;  \t\tfe.water(); \t\tcar = fe;    // car = (Car)fe;에서 형변환이 생략됨 //\t\tcar.water(); // 에러. Car타입의 참조변수인 car로는 water()를 사용불가. \t\tfe2 = (FireEngine)car; // 자손타입 ← 조상타입. 형변환 생략 불가 \t\tfe2.water(); \t} }  class Car { \tString color; \tint door;  \tvoid drive() { \t// 운전하는 기능 \t\tSystem.out.println(\"drive, Brrrr~\"); \t}  \tvoid stop() {  \t// 멈추는 기능\t \t\tSystem.out.println(\"stop!!!\");\t \t} }  class FireEngine extends Car {\t// 소방차 \tvoid water() {\t// 물을 뿌리는 기능 \t\tSystem.out.println(\"water!!!\"); \t} }   car.water();   → Car 에는 water()가 없어서 오류 발생함       예제2   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Ex7_7 { \tpublic static void main(String args[]) { \t\tCar car = null; \t\tFireEngine fe = null;  \t\tFireEngine fe2 = (FireEngine)car; // 조상 -&gt; 자손으로 형변환 \t\tCar car2 = (Car)fe2; // 자손 -&gt; 조상으로 형변환  \t\tcar2.drive(); // 에러. NullPointException 발생. \t} }  class Car { \tString color; \tint door;  \tvoid drive() { \t// 운전하는 기능 \t\tSystem.out.println(\"drive, Brrrr~\"); \t}  \tvoid stop() {  \t// 멈추는 기능\t \t\tSystem.out.println(\"stop!!!\");\t \t} }  class FireEngine extends Car {\t// 소방차 \tvoid water() {\t// 물을 뿌리는 기능 \t\tSystem.out.println(\"water!!!\"); \t} }   fe, car2 모두 null!   형 변환 할때 중요한건 실제 인스턴스가 무엇인지가 중요하다.       예제3   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Ex7_7 { \tpublic static void main(String args[]) { \t\tCar car = new Car(); \t\tFireEngine fe = (FireEngine)c; // 형변환 실행 에러. java.lang.ClassCastException \t\tfe.water(); \t} }  class Car { \tString color; \tint door;  \tvoid drive() { \t// 운전하는 기능 \t\tSystem.out.println(\"drive, Brrrr~\"); \t}  \tvoid stop() {  \t// 멈추는 기능\t \t\tSystem.out.println(\"stop!!!\");\t \t} }  class FireEngine extends Car {\t// 소방차 \tvoid water() {\t// 물을 뿌리는 기능 \t\tSystem.out.println(\"water!!!\"); \t} }   컴파일은 통과, 그러나 실행 중 형변환 오류 발생함   → 실제 인스턴스는 Car 이고 Car에는 water()가 없음. 따라서, 에러 발생!       결론   참조변수가 가리키는 실제 인스턴스가 뭔지 확인하고 그 멤버의 갯수를 확인!       5.3 instanceof연산자      참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환   형변환 전에 반드시 instanceof로 확인해야 함            확인. 형변환 해도 되는지: instanceof       형변환               1 2 3 4 5 6 7 8 9 10 11 void doWork(Car c) { \tif (c instanceof FireEngine) { // 1. 형변환이 가능한지 확인 \t\tFireEngine fe = (FireEngine)c; // 2. 형변환 \t\tfe.water(); \t\t// ... \t} else if (c instanceof Ambulance) { \t\tAmbulance a = (Ambulance)c; \t\ta.siren(); \t\t// ... \t} }   doWork(Car c)   → doWork(new Car())   → doWork(new  FireEngine())   → doWork(new Ambulance())   위의 3문장 모두 가능       1 2 3 4 5 FireEngine fe = new FireEngine();  System.out.println(fe instanceof Object);    // true System.out.println(fe instanceof Car);       // true System.out.println(fe instanceof FireEngine);// true   모두 true를 반환하는 이유는 FireEngine클래스는 Object클래스와 Car클래스의 자손 클래스이므로 조상의 멤버들을 상속받았기 때문에!   1 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.       Q. 참조변수의 형변환은 왜 하나요?   참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절하기 위해서   Q. instanceof연산자는 언제 사용하나요?   참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때       다형성      Tv t = new SmartTv(); (조상 ↔ 자손)   참조변수의 형변환 - 리모콘 바꾸기(사용가능한 멤버갯수 조절)   instanceof 연산자 - 형변환 가능여부 체크       다형성 장점      다형적 매개변수   하나의 배열로 여러종류 객체 다루기       5.5 매개변수의 다형성      참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.   한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하는 것   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Product { \tint price; \tint bonusPoint; }  class Tv extends Product {} class Computer extends Product {} class Audio extends Product {}  class Buyer { \tint money = 1000; \tint bonusPoint = 0;  \tvoid buy(Tv t) { \t\tmoney -= t.price; \t\tbonusPoint += t.bonusPoint; \t} \t \t// 오버로딩(메서드이름은 같고 매개변수 타입은 다름) \tvoid buy(Computer c) { \t\tmoney -= c.price; \t\tbonusPoint += c.bonusPoint; \t} \t \tvoid buy(Audio a) { \t\tmoney -= a.price; \t\tbonusPoint += a.bonusPoint; \t}  \t//...  }   제품이 계속 추가되면 코드가 너무 길어지고 중복이 발생함   따라서, 아래와 같이 수정       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Product { \tint price; \tint bonusPoint; }  class Tv extends Product {} class Computer extends Product {} class Audio extends Product {}  class Buyer { \tint money = 1000; \tint bonusPoint = 0;  \t/* 다형성 \t\tProduct p1 = new Tv(); \t\tProduct p2 = new Computer(); \t\tProduct p3 = new Audio(); \t*/ \tvoid buy(Product p) { \t\tmoney -= p.price; \t\tbonusPoint += p.bonusPoint; \t} }   1 2 3 4 5 6 7 Buyer b = new Buyer();  Tv tv = new Tv(); Computer com = new Computer();  b.buy(tv); b.buy(com);       예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Product { \tint price;\t\t\t// 제품의 가격 \tint bonusPoint;\t// 제품구매 시 제공하는 보너스점수  \tProduct(int price) { \t\tthis.price = price; \t\tbonusPoint = (int)(price/10.0);\t// 보너스점수는 제품가격의 10% \t} }  class Tv1 extends Product { \tTv1() { \t\t// 조상클래스의 생성자 Product(int price)를 호출한다. \t\tsuper(100);\t\t// Tv의 가격을 100만원으로 한다. \t}  \t// Object클래스의 toString()을 오버라이딩한다. \tpublic String toString() { return \"Tv\"; } }  class Computer extends Product { \tComputer() { super(200); }  \tpublic String toString() { return \"Computer\"; } }  class Buyer {\t// 고객, 물건을 사는 사람 \tint money = 1000;\t  // 소유금액 \tint bonusPoint = 0; // 보너스점수  \tvoid buy(Product p) { \t\tif(money &lt; p.price) { \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 살 수 없습니다.\"); \t\t\treturn; \t\t}  \t\tmoney -= p.price;            // 가진 돈에서 구입한 제품의 가격을 뺀다. \t\tbonusPoint += p.bonusPoint;  // 제품의 보너스 점수를 추가한다. \t\tSystem.out.println(p + \"을/를 구입하셨습니다.\"); \t\tSystem.out.println(p.toString() + \"을/를 구입하셨습니다.\"); \t} }  class Ex7_8 { \tpublic static void main(String args[]) { \t\tBuyer b = new Buyer();  \t\tb.buy(new Tv1()); // buy(Product p) \t\tb.buy(new Computer()); // buy(Product p)  \t\tSystem.out.println(\"현재 남은 돈은 \" + b.money + \"만원입니다.\"); \t\tSystem.out.println(\"현재 보너스점수는 \" + b.bonusPoint + \"점입니다.\"); \t} }   1 2 3 4 Tv을/를 구입하셨습니다. Computer을/를 구입하셨습니다. 현재 남은 돈은 700만원입니다. 현재 보너스점수는 30점입니다.   System.out.println(p + “을/를 구입하셨습니다.”);   System.out.println(p.toString() + “을/를 구입하셨습니다.”);   → 동일한 코드       5.6 여러 종류의 객체를 하나의 배열로 다루기      조상타입의 배열에 자손들의 객체를 담을 수 있다.      1 2 3 Product p1 = new Tv(); Product p2 = new Computer(); Product p3 = new Audio();          1 2 3 4 Product p[] = new Product[3]; p[0] = new Tv(); p[1] = new Computer(); p[2] = new Audio();       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Buyer { // 물건사는 사람 \tint money = 1000; \tint bonusPoint = 0;  \tProduct[] cart = new Product[10]; // 구입한 물건을 담을 배열 \t \tint i = 0;  \tvoid buy(Product p) { \t\tif(money &lt; p.price) { \t\t\tSystem.out.println(\"잔액부족\"); \t\t\treturn; \t\t}  \t\tmoney -= p.price; \t\tbonusPoint += p.bonusPoint; \t\tcart[i++] = p; \t} }      1 2 3 4 public class Vector extends AbstractList  \t\t\timplements List, Cloneable, java.io.Serializable { \tprotected Object elementData[]; }   Vector: 가변 배열 기능   Vector 클래스에는 모든 종류의 객체를 저장할 수 있다.       예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Product2 { \tint price;\t\t\t// 제품의 가격 \tint bonusPoint;\t// 제품구매 시 제공하는 보너스점수  \tProduct2(int price) { \t\tthis.price = price; \t\tbonusPoint = (int)(price/10.0); \t}  \tProduct2() {} // 기본 생성자 }  class Tv2 extends Product2 { \tTv2() {  super(100);\t }  \tpublic String toString() { return \"Tv\"; } }  class Computer2 extends Product2 { \tComputer2() { super(200); } \tpublic String toString() { return \"Computer\"; } }  class Audio2 extends Product2 { \tAudio2() { super(50); } \tpublic String toString() { return \"Audio\"; } }  class Buyer2 {\t\t\t  // 고객, 물건을 사는 사람 \tint money = 1000;\t  // 소유금액 \tint bonusPoint = 0; // 보너스점수 \tProduct2[] cart = new Product2[10];   // 구입한 제품을 저장하기 위한 배열 \tint i =0;\t\t\t  // Product배열에 사용될 카운터  \tvoid buy(Product2 p) { \t\tif(money &lt; p.price) { \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 살 수 없습니다.\"); \t\t\treturn; \t\t}  \t\tmoney -= p.price;             // 가진 돈에서 구입한 제품의 가격을 뺀다. \t\tbonusPoint += p.bonusPoint;   // 제품의 보너스 점수를 추가한다. \t\tcart[i++] = p;                // 제품을 Product[] cart에 저장한다. \t\tSystem.out.println(p + \"을/를 구입하셨습니다.\"); \t}  \tvoid summary() {\t              // 구매한 물품에 대한 정보를 요약해서 보여 준다. \t\tint sum = 0;                 // 구입한 물품의 가격합계 \t\tString itemList =\"\";         // 구입한 물품목록  \t\t// 반복문을 이용해서 구입한 물품의 총 가격과 목록을 만든다. \t\tfor(int i=0; i&lt;cart.length;i++) { \t\t\tif(cart[i]==null) break; \t\t\tsum += cart[i].price; \t\t\titemList += cart[i] + \", \"; \t\t} \t\tSystem.out.println(\"구입하신 물품의 총금액은 \" + sum + \"만원입니다.\"); \t\tSystem.out.println(\"구입하신 제품은 \" + itemList + \"입니다.\"); \t} }  class Ex7_9 { \tpublic static void main(String args[]) { \t\tBuyer2 b = new Buyer2();  \t\tb.buy(new Tv2()); \t\tb.buy(new Computer2()); \t\tb.buy(new Audio2()); \t\tb.summary(); \t} }     ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP7/",
        "teaser": ""
      },{
        "title": "REST API with SpringBoot(1)",
        "excerpt":"백기선님 강의 정리   REST API with SpringBoot(1)   REST API with SpringBoot(2)   REST API with SpringBoot(3)   REST API with SpringBoot(4)       REST      인터넷 상의 시스템 간의 상호 운용성을 제공하는 방법 중 하나   시스템 제 각각의 독립적인 진화를 보장하기 위한 방법       REST의 조건   1 2 3 4 5 6 Client-Server Stateless Cache Uniform Interface Layered System Code-on-Demand(optional)       대개, REST API가 아닌 이유는 Uniform Interface 조건을 만족하지 못하기 때문이다.       Uniform Interface 조건   1 2 3 4 Identification of resources Manipulation of resources through representations Self-descriptive messages Hypermedia as the engine of application state(HATEOAS)      Identification of resources            리소스가 URI로 식별이 되는지           Manipulation of resources through representations                     서버가 클라이언트에서 이해할 수 있는 형식으로 응답하는지           → json형식으로 정보를 표현해서 응답하는지                   Self-descriptive messages   Hypermedia as the engine of application state(HATEOAS)       대부분 3, 4번을 만족하지 못해 REST API가 아니다.       1. self-descriptive messages      메시지 스스로 메시지에 대한 설명이 가능해야 한다.   서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다.   확장 가능한 커뮤니케이션   방법1 - Media Type을 정의하는 방법 (Content-type으로 지정)   1 2 3 HTTP/1.1 200 OK Content-Type: application/ecsimsw.subways+json {\"id\":1, \"name\":\"잠실역\"}   방법2 - link header에 명세를 확인할 수 있는 링크를 넣음   1 2 3 4 HTTP/1.1 200 OK Content-Type: application/json Link: &lt;https://ecsimsw.com/docs/subway&gt;; rel=\"profile\" {\"id\":1, \"name\":\"잠실역\"}   → 브라우저들이 아직 스팩을 지원하지 않는다. 따라서, 대안으로 HAL의 링크 데이터에 profile 링크 추가       2. HATEOAS      하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다.   링크 정보를 동적으로 바꿀 수 있다.   방법1 - 데이터에 링크 제공 (HAL)   HAL: Hypertext Application Language 으로 json,xml코드 내의 외부 리소스에 대한 링크를 추가하기 위한 특별한 데이터 타입      application/hal+json   application/hal+xml   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 {   \"data\": { // HAL JSON의 리소스 필드     \"id\": 1000,     \"name\": \"게시글 1\",     \"content\": \"HAL JSON을 이용한 예시 JSON\"   },   \"_links\": { // HAL JSON의 링크 필드     \"self\": {       \"href\": \"http://localhost:8080/api/article/1000\" // 현재 api 주소     },     \"profile\": {       \"href\": \"http://localhost:8080/docs#query-article\" // 해당 api의 문서     },     \"next\": {       \"href\": \"http://localhost:8080/api/article/1001\" // article 의 다음 api 주소     },     \"prev\": {       \"href\": \"http://localhost:8080/api/article/999\" // article의 이전 api 주소     }   } }   방법2 - 링크 헤더나 Location을 제공   1 2 3 4 5 6 HTTP/1.1 200 OK Content-Type: application/json Link:&lt;/subways/1/times&gt;; rel=\"times\",      &lt;/subways/1/detail&gt;; rel=\"detail\"  {\"id\":1,\"name\":\"잠실역\"}  ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API"],
        "url": "/spring/Java-REST-API(1)/",
        "teaser": ""
      },{
        "title": "REST API with SpringBoot(2)",
        "excerpt":"백기선님 강의 정리   REST API with SpringBoot(1)   REST API with SpringBoot(2)   REST API with SpringBoot(3)   REST API with SpringBoot(4)       project dependencies          Event 도메인 구현   events/Event.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package me.whiteship.demoinflearnrestapi.events;  import lombok.*;  import javax.persistence.*; import java.time.LocalDateTime;  @Entity @Builder @AllArgsConstructor @NoArgsConstructor @Getter @Setter @EqualsAndHashCode(of = \"id\") public class Event {      @Id     @GeneratedValue     private Integer id;     private String name;     private String description;     private LocalDateTime beginEnrollmentDatetime;     private LocalDateTime closeEnrollmentDatetime;     private LocalDateTime beginEventDatetime;     private LocalDateTime endEventDatetime;     private String location;     private int basePrice;     private int maxPrice;     private int limitIfEnrollment;     private boolean offline;     private boolean free;      @Enumerated(EnumType.STRING)     private EventStatus eventStatus; }   events/EventStatus.java   1 2 3 4 5 6 package me.whiteship.demoinflearnrestapi.events;  public enum EventStatus {      DRAFT, PUBLISHED, BEGAN_ENROLLMENT }       생성자를 자동 생성해주는 Lombok 어노테이션      @NoArgsConstructor: 파라미터가 없는 기본 생성자   @AllArgsConstructor: 모든 필드 값을 파라미터로 받는 생성자   @RequiredArgsConstructor: final이나 @NonNull 인 필드 값만 파라미터로 받는 생성자       @EqualsAndHashCode   equals와 hashcode를 자동으로 생성해주는 어노테이션      equals: 두 객체의 내용이 같은지, 동등성을 비교   hashcode: 두 객체가 같은 객체인지, 동일성을 비교   exclude: toString의 exclude와 마찬가지로 포함시키지 않으려면 ‘exclude={필드명}’ 작성   of: 연관관계가 복잡해질 때, stack overflow가 발생할 수 있기 때문에 id 값만 주로 사용       @Data를 사용할 때 주의할 점   하나의 어노테이션으로 많은 메소드를 자동으로 생성하면 편리한 것이 사실이지만, ORM(Object Relational Mapping)에서 주의해야 함   서로 무한 반복 호출이 진행되면서 stack overflow를 유발할 수 있으므로 몇라인 길어지더라도 @Getter, @Setter, @ToString 등 따로 사용하는게 좋음       @Builder를 사용할 때 @AllArgsConstructor가 필요한 이유?   빌더는 필드의 초기화 작업을 도와주는 역할을 하는데 @NoArgsConstructor 와 같이 생성자에 멤버변수가 존재하지 않으면 의미가 없다. 따라서 @Builder를 사용할 때 @AllArgsConstructor를 정의하거나 전체 멤버변수를 갖는 생성자를 만들어야한다.       Event 테스트 구현   events/EventControllerTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package me.whiteship.demoinflearnrestapi.events;  import com.fasterxml.jackson.databind.ObjectMapper; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mockito; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.hateoas.MediaTypes; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc;  import java.time.LocalDateTime;  import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  @RunWith(SpringRunner.class) @WebMvcTest public class EventControllerTests {      @Autowired     MockMvc mockMvc;      @Autowired     ObjectMapper objectMapper;      @MockBean     EventRepository eventRepository;      @Test     public void createEvent() throws Exception {         Event event = Event.builder()                 .name(\"Spring\")                 .description(\"REST API development with Spring\")                 .beginEnrollmentDatetime(LocalDateTime.of(2022, 1, 18, 14, 21, 22))                 .closeEnrollmentDatetime(LocalDateTime.of(2022, 1, 19, 14, 21, 22))                 .beginEventDatetime(LocalDateTime.of(2022, 1, 25, 14, 21, 22))                 .endEventDatetime(LocalDateTime.of(2022, 1, 26, 14, 21, 22))                 .basePrice(100)                 .maxPrice(200)                 .limitIfEnrollment(100)                 .location(\"강남역\")                 .build();          event.setId(10);         Mockito.when(eventRepository.save(event)).thenReturn(event);          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaTypes.HAL_JSON)                 .content(objectMapper.writeValueAsString(event)))                 .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음                 .andExpect(status().isCreated())                 .andExpect(jsonPath(\"id\").exists())                 .andExpect(header().exists(HttpHeaders.LOCATION))                 .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_VALUE));     }  }        @WebMvcTest      MVC를 위한 테스트, 컨트롤러가 예상대로 동작하는 테스트하는데 사용   @SpringBootTest 보다 가벼운 테스트가 가능   MockBean, MockMVC를 자동 구성하여 테스트 가능하도록 함   스프링 부트 슬라이스 테스트       @Autowired MockMvc mockMvc;      스프링 MVC 테스트 핵심 클래스   웹 서버를 띄우지 않고도 스프링 MVC (DispatcherServlet)가 요청을 처리하는 과정을 확인할 수 있기 때문에 컨트롤러 테스트용으로 자주 쓰임       mockMvc의 메소드           perform()       요청을 전송하는 역할. 결과로 ResultActions 객체를 받으며, ResultActions 객체는 리턴 값을 검증하고 확인 할 수 있는 andExpect() 메소드를 제공해줌.            get(), post(), put(), delete()       HTTP메소드를 결정할 수 있음. 인자로는 경로를 보내줌            andExpect()       응답을 검증하는 역할              상태코드(status())       뷰(view()): 리턴하는 뷰 이름을 검증       리다이렉트(redirect()): 리다이렉트 응답을 검증       모델 정보(model()): 컨트롤러에서 저장한 모델들의 정보 검증       응답 정보 검증(content()): 응답에 대한 정보를 검증해줌                andDo(print())       요청/응답 전체 메세지를 확인할 수 있음           ObjectMapper   Object → Serialize(직렬화) → JSON   JSON → Deserialize(역직렬화) → Object       Mockito 란?   단위 테스트를 위한 Java mocking framework   Mockito.when().thenReturn(): 결과에 따라 특정 값을 반환   Mockito.when().thenThrow(): 결과에 따라 에러 발생 시킴   1 2 3 4 5 // get(0)이 호출되면 \"first\"를 반환합니다. when(mockedList.get(0)).thenReturn(\"first\");  // get(1)이 호출되면 RuntimeException 에러를 발생합니다. when(mockedList.get(1)).thenThrow(new RuntimeException());       events/EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package me.whiteship.demoinflearnrestapi.events;  import lombok.RequiredArgsConstructor; import org.springframework.hateoas.MediaTypes; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping;  import java.net.URI;  import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;  @Controller @RequestMapping(value = \"/api/events\", produces = MediaTypes.HAL_JSON_VALUE) @RequiredArgsConstructor public class EventController {      private final EventRepository eventRepository;      @PostMapping     public ResponseEntity createEvent(@RequestBody Event event) {         Event newEvent = this.eventRepository.save(event);         URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri();         event.setId(10);         return ResponseEntity.created(createdUri).body(event);     } }       HATEOAS 란?      REST API의 필수 구성요소 중 한가지   특정 API 요청 시 리소스 정보를 받아 볼 수 있는데, 이때 리소스 정보 뿐만 아니라 리소스에 대한 다양한 링크 정보를 리소스 정보와 함께 반환하는 것을 의미   HATEOAS를 적용하면 API 요청 시, Resource와 Links를 함께 반환 받을 수 있음   예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import org.springframework.hateoas.MediaTypes; import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import java.net.URI; import java.util.IdentityHashMap; import java.util.Map;  import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;  @RestController @RequestMapping(value = \"/api/member\", produces = MediaTypes.HAL_JSON_VALUE) public class MemberController {      private Map&lt;Integer, Member&gt; db = new IdentityHashMap&lt;&gt;();     private Integer id = 1;      @PostMapping     public ResponseEntity createMember(@RequestBody Member member) {         member.setId(id++);          /*             /api/member         */         WebMvcLinkBuilder listLink= linkTo(MemberController.class);                  /*             /api/member/{id}         */         WebMvcLinkBuilder selfLink = listLink.slash(member.getId());          //hateoas model 객체 생성         MemberModel memberModel = new MemberModel(member);          //list link         memberModel.add(listLink.withRel(\"list\"));          //self link         memberModel.add(selfLink.withSelfRel());          //update link         memberModel.add(selfLink.withRel(\"update\"));          return ResponseEntity.created(selfLink.toUri()).body(memberModel);     } }   POST /api/member 요청 시 HAL_JSON 방식으로 리소스를 반환 (HAL이란 Hypertext Application Language의 약자로 JSON 또는 XML 코드 내의 외부 리소스에 대한 링크와 같은 하이퍼 미디어를 정의하기 위한 표준 규칙)   반환 정보는 생성된 Member 정보와 Member와 관련된 링크 정보로 구성됨   링크 정보는 list, self, update 정보를 담고 있음       결과     ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API"],
        "url": "/spring/JAVA-REST-API(2)/",
        "teaser": ""
      },{
        "title": "REST API with SpringBoot(3)",
        "excerpt":"백기선님 강의 정리   REST API with SpringBoot(1)   REST API with SpringBoot(2)   REST API with SpringBoot(3)   REST API with SpringBoot(4)       Event 생성 API 구현: 입력값 제한하기   dto를 사용하여 입력값을 제한하고 dto ↔ entity 를 변경할 땐 modelMapper 를 사용함       ModelMapper란?   어떤 Object에 있는 필드값들을 Object로 Mapping 시켜줌   즉, dto to entity를 일일히 정의할 필요없음       주의!   ModelMapper는 해당 클래스의 기본 생성자를 이용해 객체를 생성하고 setter를 이용해 매핑을 한다. 따라서, setter 어노테이션을 붙이지 않으면 json으로 null이 반환된다.       [참고]   ModelMapper를 사용하면서 setter를 사용하고 싶지 않다면 다음과 같이 빈으로 등록해주면 된다   → Access level 이 public인데 이를 Private level로 바꾸면 setter 없이도 필드명이 같을 때 자동 매핑 처리 할 수 있음   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package me.yessm.airbnbjava.config;  import org.modelmapper.ModelMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  @Configuration public class Config {     @Bean     public ModelMapper modelMapper() {         ModelMapper modelMapper = new ModelMapper();         modelMapper.getConfiguration()                 .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE)                 .setFieldMatchingEnabled(true);         return modelMapper;     } }       pom.xml 에 추가   1 2 3 4 5 6 &lt;!-- https://mvnrepository.com/artifact/org.modelmapper/modelmapper --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;     &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;     &lt;version&gt;2.4.5&lt;/version&gt; &lt;/dependency&gt;   EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 ...  private final ModelMapper modelMapper;  ...  \tEvent event = modelMapper.map(eventDto, Event.class);  \t/* 위의 코드와 아래 코드는 같다. \tEvent event = Event.builder()                 .name(eventDto.getName())                 .description(eventDto.getDescription())                 ...                 .build();*/       입력값을 제한하기 위해 entity 대신 DTO를 사용   DTO 를 사용하는 이유?      엔티티 내부 구현을 캡슐화할 수 있다   화면에 필요한 데이터를 선별할 수 있다.   순환참조를 예방할 수 있다.   validation 코드와 모델링 코드를 분리할 수 있다.       @WebMvcTest는 슬라이싱 테스트   → 통합테스트를 전환함(@SpringBootTest)       EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package me.whiteship.demoinflearnrestapi.events;  import lombok.RequiredArgsConstructor; import org.modelmapper.ModelMapper; import org.springframework.hateoas.MediaTypes; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping;  import java.net.URI;  import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;  @Controller @RequestMapping(value = \"/api/events\", produces = MediaTypes.HAL_JSON_VALUE) @RequiredArgsConstructor public class EventController {      private final EventRepository eventRepository;      private final ModelMapper modelMapper;      @PostMapping     public ResponseEntity createEvent(@RequestBody EventDto eventDto) {         Event event = modelMapper.map(eventDto, Event.class);         Event newEvent = eventRepository.save(event);         URI createdUri =linkTo(EventController.class).slash(newEvent.getId()).toUri();         return ResponseEntity.created(createdUri).body(event);     } }    EventControllerTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package me.whiteship.demoinflearnrestapi.events;  import com.fasterxml.jackson.databind.ObjectMapper; import org.hamcrest.Matchers; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mockito; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.hateoas.MediaTypes; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc;  import java.time.LocalDateTime;  import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  @RunWith(SpringRunner.class) @WebMvcTest public class EventControllerTests {      @Autowired     MockMvc mockMvc;      @Autowired     ObjectMapper objectMapper;      @MockBean     EventRepository eventRepository;      @Test     public void createEvent() throws Exception {         Event event = Event.builder()                 .id(100)                 .name(\"Spring\")                 .description(\"REST API development with Spring\")                 .beginEnrollmentDatetime(LocalDateTime.of(2022, 1, 18, 14, 21, 22))                 .closeEnrollmentDatetime(LocalDateTime.of(2022, 1, 19, 14, 21, 22))                 .beginEventDatetime(LocalDateTime.of(2022, 1, 25, 14, 21, 22))                 .endEventDatetime(LocalDateTime.of(2022, 1, 26, 14, 21, 22))                 .basePrice(100)                 .maxPrice(200)                 .limitIfEnrollment(100)                 .location(\"강남역\")                 .free(true)                 .offline(false)                 .eventStatus(EventStatus.PUBLISHED)                 .build();          Mockito.when(eventRepository.save(event)).thenReturn(event);          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaTypes.HAL_JSON)                 .content(objectMapper.writeValueAsString(event)))                 .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음                 .andExpect(status().isCreated())                 .andExpect(jsonPath(\"id\").exists())                 .andExpect(header().exists(HttpHeaders.LOCATION))                 .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_VALUE))                 .andExpect(jsonPath(\"id\").value(Matchers.not(100)))                 .andExpect(jsonPath(\"free\").value(Matchers.not(true)))                 .andExpect(jsonPath(\"eventStatus\").value(Matchers.not(EventStatus.DRAFT)));     }  }   이렇게 코드를 작성하면 newEvent.getId() 부분에서 NullPointException이 발생함   → why?   모키토에서 작성한 eventRepository.save(event)가 호출되면 event 를 반환한다는 코드   newEvent 객체와 test코드에서 작성한 event 객체는 다른 객체이기 때문에 save()를 호출해도 반환되는 값이 null. 따라서, 오류 발생       Event 생성 API 구현: Bad Request 처리하기   입력값 이외에 에러 발생, 입력값이 비어있는 경우 에러 발생   입력 값이 정해진 값 이외에 다른 값이 들어왔을 경우      무시하는 방법: 유연한 방법   에러를 발생시키는 방법: Bad Request 발생       application.properties 설정   1 spring.jackson.deserialization.fail-on-unknown-properties=true   EventControllerTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \t \t...  \t@Test     @DisplayName(\"입력 받을 수 없는 값을 사용한 경우에 에러가 발생하는 테스트\")     public void createEvent_Bad_Request() throws Exception {         Event event = Event.builder()                 .id(100)                 .name(\"Spring\")                 .description(\"REST API development with Spring\")                 .beginEnrollmentDateTime(LocalDateTime.of(2022, 1, 18, 14, 21, 22))                 .closeEnrollmentDateTime(LocalDateTime.of(2022, 1, 19, 14, 21, 22))                 .beginEventDateTime(LocalDateTime.of(2022, 1, 25, 14, 21, 22))                 .endEventDateTime(LocalDateTime.of(2022, 1, 26, 14, 21, 22))                 .basePrice(100)                 .maxPrice(200)                 .limitIfEnrollment(100)                 .location(\"강남역\")                 .free(true)                 .offline(false)                 .eventStatus(EventStatus.PUBLISHED)                 .build();          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaTypes.HAL_JSON)                 .content(objectMapper.writeValueAsString(event)))                 .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음                 .andExpect(status().isBadRequest());     }  \t\t@Test     @DisplayName(\"입력 값이 비어있는 경우에 에러가 발생하는 테스트\")     public void createEvent_Bad_Request_Empty_Input() throws Exception {         EventDto eventDto = EventDto.builder().build();          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .content(objectMapper.writeValueAsString(eventDto)))                 .andExpect(status().isBadRequest());     }  \t...   EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package me.whiteship.demoinflearnrestapi.events;  ...  @Controller @RequestMapping(value = \"/api/events\", produces = MediaTypes.HAL_JSON_VALUE) @RequiredArgsConstructor public class EventController {      private final EventRepository eventRepository;      private final ModelMapper modelMapper;      private final EventValidator eventValidator;      @PostMapping     public ResponseEntity createEvent(@RequestBody @Validated EventDto eventDto, Errors errors) {         if (errors.hasErrors()) {             return ResponseEntity.badRequest().build();         }          ...     } }   @Valid 또는 @Validated 어노테이션 추가   → 유효성 검증 진행   @Valid는 controller 에서만 동작, 다른 계층에서는 검증이 되지 않는다   다른 계층에서 검증을 진행하기 위해선 @Validated 를 사용   (요청 파라미터의 유효성 검증은 컨트롤러에서 처리하고 서비스나 리포지토리 계층에서는 유효성 검증을 하지 않는 것이 바람직함)       의존성 추가(gradle, maven)   build.gradle   1 implementation 'org.springframework.boot:spring-boot-starter-validation'   pom.xml   1 2 3 4 5 6 \t\t&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;             &lt;version&gt;2.6.2&lt;/version&gt;         &lt;/dependency&gt;       컨트롤러에서 Request 객체 앞에 @Validate(@Valid) 어노테이션을 사용하고, Errors 를 통해 유효성 검사 적합 여부를 확인   Errors는 반드시 Request 객체 바로 뒤에 위치해야 한다.   (두개의 객체를 유효성 검사한다면 각각의 객체 뒤에 Errors 존재해야 함)   hasErrors() 메서드를 통해 에러 return       EventDto.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package me.whiteship.demoinflearnrestapi.events;  import com.sun.istack.NotNull; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor;  import javax.validation.constraints.Min; import javax.validation.constraints.NotEmpty; import java.time.LocalDateTime;  @Builder @NoArgsConstructor @AllArgsConstructor @Data public class EventDto {      @NotEmpty     private String name;     @NotEmpty     private String description;     @NotNull     private LocalDateTime beginEnrollmentDateTime;     @NotNull     private LocalDateTime closeEnrollmentDateTime;     @NotNull     private LocalDateTime beginEventDateTime;     @NotNull     private LocalDateTime endEventDateTime;     private String location;     @Min(0)     private int basePrice;     @Min(0)     private int maxPrice;     @Min(0)     private int limitIfEnrollment;  }   JSR 표준 스펙은 다양한 제약 조건 어노테이션을 제공하고 있는데, 대표적인 어노테이션으로는 다음과 같은 것들이 있다.      @NotNull: 해당 값이 null이 아닌지 검증함   @NotEmpty: 해당 값이 null이 아니고, 빈 스트링(“”) 아닌지 검증함(“ “은 허용됨)   @NotBlank: 해당 값이 null이 아니고, 공백(““과 “ “ 모두 포함)이 아닌지 검증함   @AssertTrue: 해당 값이 true인지 검증함   @Size: 해당 값이 주어진 값 사이에 해당하는지 검증함(String, Collection, Map, Array에도 적용 가능)   @Min: 해당 값이 주어진 값보다 작지 않은지 검증함   @Max: 해당 값이 주어진 값보다 크지 않은지 검증함       입력값이 잘못된 경우 에러 발생   EventValidator.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package me.whiteship.demoinflearnrestapi.events;  import org.springframework.stereotype.Component; import org.springframework.validation.Errors;  import java.time.LocalDateTime;  @Component public class EventValidator {      public void validate(EventDto eventDto, Errors errors) {         if (eventDto.getBasePrice() &gt; eventDto.getMaxPrice() &amp;&amp; eventDto.getMaxPrice() &gt; 0) {             errors.rejectValue(\"basePrice\", \"wrongValue\", \"BasePrice is wrong.\");             errors.rejectValue(\"maxPrice\", \"wrongValue\", \"MaxPrice is wrong.\");         }          LocalDateTime endEventDateTime = eventDto.getEndEventDateTime();         if(endEventDateTime.isBefore(eventDto.getBeginEventDateTime()) ||                 endEventDateTime.isBefore(eventDto.getCloseEnrollmentDateTime()) ||                 endEventDateTime.isBefore(eventDto.getBeginEnrollmentDateTime())) {             errors.rejectValue(\"endEventDateTime\", \"wrongValue\", \"EndEventDateTime is wrong.\");         }          // TODO beginEventDateTime         // TODO CloseEndrollmentDateTime     } }   @Component를 이용해 빈으로 등록해주고 EventController 에서 의존성 주입해서 사용   EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Controller @RequestMapping(value = \"/api/events\", produces = MediaTypes.HAL_JSON_VALUE) @RequiredArgsConstructor public class EventController {      ...      private final EventValidator eventValidator;      @PostMapping     public ResponseEntity createEvent(@RequestBody @Validated EventDto eventDto, Errors errors) {         ...          eventValidator.validate(eventDto, errors);         if (errors.hasErrors()) {             return ResponseEntity.badRequest().build();         }  \t\t\t\t...  \t\t} }       테스트 설명용 어노테이션 생성   TestDescription.java   1 2 3 4 5 6 7 8 9 10 11 12 13 package me.whiteship.demoinflearnrestapi.common;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface TestDescription {      String value(); }   EventControllerTests.java   1 2 3 4 5 6 ...  // 커스텀 어노테이션 @TestDescription(\"정상적으로 이벤트를 생성하는 테스트\")  ...       @Target   Java compiler가 annotation이 어디에 적용될지 결정하기 위해 사용   1 2 3 4 5 6 7 8 9 10 ElementType.PACKAGE : 패키지 선언 ElementType.TYPE : 타입 선언 ElementType.ANNOTATION_TYPE : 어노테이션 타입 선언 ElementType.CONSTRUCTOR : 생성자 선언 ElementType.FIELD : 멤버 변수 선언 ElementType.LOCAL_VARIABLE : 지역 변수 선언 ElementType.METHOD : 메서드 선언 ElementType.PARAMETER : 전달인자 선언 ElementType.TYPE_PARAMETER : 전달인자 타입 선언 ElementType.TYPE_USE : 타입 선언   @Retention   실제로 적용되고 유지되는 범위를 의미   1 2 3 4 5 6 // 컴파일 이후에도 JVM에 의해서 계속 참조가 가능. 리플렉션, 로깅에 많이 사용 RetentionPolicy.RUNTIME // 컴파일러가 클래스를 참조할 때까지 유효 RetentionPolicy.CLASS // 컴파일 전까지만 유효. 컴파일 이후에는 사라짐 RetentionPolicy.SOURCE   커스텀 어노테이션을 생성해도 되지만 Junit에서 지원해주는 @DisplayName을 사용해도 된다.  ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API","TEST CODE"],
        "url": "/spring/Java-REST-API(3)/",
        "teaser": ""
      },{
        "title": "스프링 HATEOAS",
        "excerpt":"백기선님 강의 정리   REST API with SpringBoot(1)   REST API with SpringBoot(2)   REST API with SpringBoot(3)   REST API with SpringBoot(4)       REST가 잘 적용된 API라면 응답에 HATEOAS를 지켜야 한다       HATEOAS란?   REST API에서 클라이언트에 리소스를 넘겨줄 때 특정 부가적인 리소스의 링크 정보를 넘겨줌   links 요소를 통해 href 값의 형태로 보내주면 자원 상태에 대한 처리를 링크에 있는 URL을 통해 처리할 수 있게 된다.       HATEOAS 링크에 들어가는 정보는 현재 Resource의 관계이자 링크의 레퍼런스 정보인 REL과 하이퍼링크인 HREF 두 정보가 들어간다.   1 2 3 4 5 6 7 8 9 10 11 12 // 예시 \"_links\":{ \t\"self\":{ \t\t\"href\":\"http://localhost/api/events/1\" \t}, \t\"query-events\":{ \t\t\"href\":\"http://localhost/api/events\" \t}, \t\"update-event\":{ \t\t\"href\":\"http://localhost/api/events/1\" \t} }          링크를 만드는 기능            문자열을 가지고 만들기       컨트롤러와 메소드로 만들기           리소스를 만드는 기능            리소스: 데이터(응답본문) + 링크           링크 찾아주는 기능            traverson       LinkDiscoverers           링크            HREF       REL(relation, 관계)                    self           profile           update-event           query-events           …                               참고)      ResourceSupport is now RepresentationModel   Resource is now EntityModel   Resources is now CollectionModel   PagedResources is now PagedModel       테스트 코드   링크 정보를 제공하는 테스트 코드를 추가      self: 리소스에 대한 링크   query-events: 이벤트 목록에 대한 링크   update-event: 이벤트 수정에 대한 링크   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \t\t...  \t\t@Test     @DisplayName(\"정상적으로 이벤트를 생성하는 테스트\")     @TestDescription(\"정상적으로 이벤트를 생성하는 테스트\")     public void createEvent() throws Exception {         EventDto event = EventDto.builder()                 .name(\"Spring\")                 ...                 .build();          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaTypes.HAL_JSON)                 .content(objectMapper.writeValueAsString(event)))                 .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음                 ...                 .andExpect(jsonPath(\"_links.self\").exists()) // 3가지의 링크가 응답으로 오길 기다                 .andExpect(jsonPath(\"_links.query-events\").exists())                 .andExpect(jsonPath(\"_links.update-event\").exists());       EventResource   RepresentationModel를 상속받고 Event 객체를 주입받아 Getter 메서드를 활용하여 제공하는 방법   EventResource.java - 첫번째 방법   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package me.whiteship.demoinflearnrestapi.events;  import com.fasterxml.jackson.annotation.JsonUnwrapped; import org.springframework.hateoas.EntityModel; import org.springframework.hateoas.Link; import org.springframework.hateoas.RepresentationModel;  public class EventResource extends RepresentationModel {      @JsonUnwrapped     private Event event;      public EventResource(Event event) {         this.event = event;     }      public Event getEvent() {         return event;     } }   @JsonUnwrapped 을 사용하는 이유?   응답을 보낼 때 jackson(ObjectMapper)을 사용하여 serialization을 진행   즉, BeanSerializer를 사용하는데 BeanSerializer는 기본적으로 필드명을 사용. 따라서, Test Assertion조건에 맞지않음   응답 내부에 event가 존재하고 event에 정보가 있는 구조   → @JsonUnwrapped는 property를 serialize/deserialize 과정에서 평탄화(flattened)한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 예시 */  /* @JsonUnwrapped 적용 전 */ {   \"id\" : 1,   \"name\" : {     \"firstName\" : \"seungmi\",     \"lastName\" : \"noh\"   } }  /* @JsonUnwrapped 적용 전 */ {   \"id\" : 1,   \"firstName\" : \"seungmi\",   \"lastName\" : \"noh\" }   EventResource.java - 두번째 방법   1 2 3 4 5 6 7 public class EventResource extends EntityModel&lt;Event&gt; {      public EventResource(Event event, Link... links) {         super(event, Arrays.asList(links));         add(linkTo(EventController.class).slash(event.getId()).withSelfRel());     } }   RepresentationModel 하위 클래스에 EntityModel 라는 클래스가 존재   T에 해당하는 데이터가 content로 매핑 되는데 getContent() 메소드에 @JsonUnwrapped가 붙어있기 때문에 unwrap 된다.   따라서, 위의 코드처럼 두번째 방법을 사용해도 된다.       EventController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @PostMapping     public ResponseEntity createEvent(@RequestBody @Validated EventDto eventDto, Errors errors) {         if (errors.hasErrors()) {             return ResponseEntity.badRequest().body(errors);         }          eventValidator.validate(eventDto, errors);         if (errors.hasErrors()) {             return ResponseEntity.badRequest().body(errors);         }          Event event = modelMapper.map(eventDto, Event.class);         event.update();         Event newEvent = eventRepository.save(event);         WebMvcLinkBuilder selfLinkBuilder = linkTo(EventController.class).slash(newEvent.getId());         URI createdUri = selfLinkBuilder.toUri();         EventResource eventResource = new EventResource(event);         eventResource.add(linkTo(EventController.class).withRel(\"query-events\"));         eventResource.add(selfLinkBuilder.withRel(\"update-event\"));         return ResponseEntity.created(createdUri).body(eventResource);     }   withRel(): 이 링크가 리소스와 어떤 관계에 있는지 관계를 정의 할 수 있다   withSelRel(): 리소스에 대한 링크를 type-safe한 method로 제공한다  ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API","TEST CODE","HATEOAS"],
        "url": "/spring/Java-HATEOAS/",
        "teaser": ""
      },{
        "title": "REST API with SpringBoot(4)",
        "excerpt":"백기선님 강의 정리   REST API with SpringBoot(1)   REST API with SpringBoot(2)   REST API with SpringBoot(3)   REST API with SpringBoot(4)       Event 생성 API 구현: Bad Request 응답 본문 만들기   serialization: ‘객체 → json’ 으로 변환   deserialization: ‘json → 객체’ 로 변환       body에 Bad Request에 대한 응답을 넣고 싶은데 관련 에러는 Errors에 담겨 있다   그런데, body에 error를 담으려고 하면 에러가 발생한다!   원인은 error를 json으로 변환할 수 없기 때문에..   그렇다면 왜 event 객체는 body에 담을 수 있었을까?   → event는 objectMapper를 사용해서 객체에서 json으로 변환하는데 이때 bean serialization을 사용해서 자바빈 스팩을 준수했기 때문에 변환할수 있었던것..       따라서, 아래 코드와 같이 error를 serialization 해주는 코드를 작성해야한다.       common/ErrorsSerializer.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package me.whiteship.demoinflearnrestapi.common;  import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import org.springframework.boot.jackson.JsonComponent; import org.springframework.validation.Errors;  import java.io.IOException;  @JsonComponent public class ErrorsSerializer extends JsonSerializer&lt;Errors&gt; {      @Override     public void serialize(Errors errors, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {         jsonGenerator.writeStartArray();         errors.getFieldErrors().forEach(e -&gt; {             try {                 jsonGenerator.writeStartObject();                 jsonGenerator.writeStringField(\"field\", e.getField());                 jsonGenerator.writeStringField(\"objectName\", e.getObjectName());                 jsonGenerator.writeStringField(\"code\", e.getCode());                 jsonGenerator.writeStringField(\"defaultMessage\", e.getDefaultMessage());                 Object rejectedValue = e.getRejectedValue();                 if (rejectedValue != null) {                     jsonGenerator.writeStringField(\"rejectedValue\", rejectedValue.toString());                 }                 jsonGenerator.writeEndObject();             } catch (IOException e1) {                 e1.printStackTrace();             }         });          errors.getGlobalErrors().forEach(e -&gt; {             try {                 jsonGenerator.writeStartObject();                 jsonGenerator.writeStringField(\"objectName\", e.getObjectName());                 jsonGenerator.writeStringField(\"code\", e.getCode());                 jsonGenerator.writeStringField(\"defaultMessage\", e.getDefaultMessage());                 jsonGenerator.writeEndObject();             } catch (IOException e1) {                 e1.printStackTrace();             }         });         jsonGenerator.writeEndArray();     } }       @JsonComponent   ObjectMapper 에 Custom Serializer를 등록해 주어야하는데 Spring Boot에서 제공하는 @JsonComponent를 사용하면 손쉽게 등록이 가능하다.   Json Parser Online       Event 생성 API 구현: 비즈니스 로직 적용   event.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ...  public void update() {     // Update free     if (this.basePrice == 0 &amp;&amp; this.maxPrice == 0) {         this.free = true;     } else {         this.free = false;     }      // Update offline     if (this.location == null || this.location.isBlank()) {         this.offline = false;     } else {         this.offline = true;     } }  ...   entity test code 작성   EventTest.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \t...  \t@Test     public void testFree() {         // Given         Event event = Event.builder()                 .basePrice(0)                 .maxPrice(0)                 .build();          // When         event.update();          // Then         assertThat(event.isFree()).isTrue();          // Given         event = Event.builder()                 .basePrice(100)                 .maxPrice(0)                 .build();          // When         event.update();          // Then         assertThat(event.isFree()).isFalse();          // Given         event = Event.builder()                 .basePrice(0)                 .maxPrice(100)                 .build();          // When         event.update();          // Then         assertThat(event.isFree()).isFalse();     }  \t...   위의 코드처럼 작성해도 되지만 중복이 발생하기 때문에 보기에 좋지 않다   JUnitParams 를 이용하여 중복코드를 줄이고 테스트코드를 작성할 수 있다.       Event 생성 API 구현: 매개변수를 이용한 테스트   dependency 추가   pom.xml   1 2 3 4 5 6 &lt;dependency&gt;     &lt;groupId&gt;pl.pragmatists&lt;/groupId&gt;     &lt;artifactId&gt;JUnitParams&lt;/artifactId&gt;     &lt;version&gt;1.1.1&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;   EventTest.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package me.whiteship.demoinflearnrestapi.events;  import junitparams.JUnitParamsRunner;  import junitparams.Parameters;  import org.junit.Test; import org.junit.runner.RunWith;  import static org.assertj.core.api.Assertions.assertThat;  @RunWith(JUnitParamsRunner.class) public class EventTest {      ...      //parametersFor: 컨벤션     private Object[] parametersForTestFree() {         return new Object[]{                 new Object[]{0, 0, true},                 new Object[]{100, 0, false},                 new Object[]{0, 100, false},                 new Object[]{100, 200, false}         };     }      @Test     @Parameters(method = \"parametersForTestFree\")     public void testFree(int basePrice, int maxPrice, boolean isFree) {         // Given         Event event = Event.builder()                 .basePrice(basePrice)                 .maxPrice(maxPrice)                 .build();          // When         event.update();          // Then         assertThat(event.isFree()).isEqualTo(isFree);     }      private Object[] parametersForTestOffline() {         return new Object[]{                 new Object[]{\"강남\", true},                 new Object[]{null, false},                 new Object[]{\"\", false}         };     }      @Test     @Parameters     public void testOffline(String location, boolean isOffline) {         // Given         Event event = Event.builder()                 .location(location)                 .build();          // When         event.update();          // Then         assertThat(event.isOffline()).isEqualTo(isOffline);     } }   parametersFor테스트코드명   → 이렇게 작성하면 알아서 맵핑해준다.(코드 컨벤션, 규약)  ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API","TEST CODE"],
        "url": "/spring/Java-REST-API(4)/",
        "teaser": ""
      },{
        "title": "스프링 REST Docs",
        "excerpt":"스프링 REST Docs란?   지금까지 개발을 진행하면서 API 명세에 대한 정보 문서화 또는 Swagger 사용을 해왔습니다.   매번 API 개발을 할 때마다 명세에 대한 정보를 문서화를 하였고,   Swagger 사용을 하면 매번 Controller, DTO 단에 Swagger 어노테이션을 추가해야 하니 코드가 보기가 좋지 않았습니다.   그러다가 API 명세서를 자동화해주는 것을 찾다가 Spring Rest Docs 찾게 되어, Spring Rest Docs를 적용하게 되었습니다.       스프링 REST Docs 장점   코드에 영향이 없다. 따라서, 코드가 바뀌어도 문서를 따로 수정할 필요없이 자동으로 변경된다.       plugin, dependency 추가   Maven - pom.xml   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \t\t\t\t\t\t&lt;plugin&gt;                 &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;                 &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.5.3&lt;/version&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;id&gt;generate-docs&lt;/id&gt;                         &lt;phase&gt;prepare-package&lt;/phase&gt;                         &lt;goals&gt;                             &lt;goal&gt;process-asciidoc&lt;/goal&gt;                         &lt;/goals&gt;                         &lt;configuration&gt;                             &lt;backend&gt;html&lt;/backend&gt;                             &lt;doctype&gt;book&lt;/doctype&gt;                         &lt;/configuration&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;                 &lt;dependencies&gt;                     &lt;dependency&gt;                         &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;                         &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt;                         &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;                     &lt;/dependency&gt;                 &lt;/dependencies&gt;             &lt;/plugin&gt;             &lt;plugin&gt;                 &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                 &lt;version&gt;2.7&lt;/version&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;id&gt;copy-resources&lt;/id&gt;                         &lt;phase&gt;prepare-package&lt;/phase&gt;                         &lt;goals&gt;                             &lt;goal&gt;copy-resources&lt;/goal&gt;                         &lt;/goals&gt;                         &lt;configuration&gt;                             &lt;outputDirectory&gt;                                 ${project.build.outputDirectory}/static/docs                             &lt;/outputDirectory&gt;                             &lt;resources&gt;                                 &lt;resource&gt;                                     &lt;directory&gt;                                         ${project.build.directory}/generated-docs                                     &lt;/directory&gt;                                 &lt;/resource&gt;                             &lt;/resources&gt;                         &lt;/configuration&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;   docs 조각: ./target/generated-snippets//.adoc   docs build: ./target/classes/static/docs/index.html       Gradle - build.gradle (7버전)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 plugins { \tid 'org.springframework.boot' version '2.5.8' \tid 'io.spring.dependency-management' version '1.0.11.RELEASE' \tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\" \t// Spring REST Docs \tid 'org.asciidoctor.jvm.convert' version '3.3.2' \tid 'java' }  group = 'com.debrains' version = '0.0.1-SNAPSHOT' sourceCompatibility = '11'  configurations { \tcompileOnly { \t\textendsFrom annotationProcessor \t} \t// Spring REST Docs \tasciidoctorExtensions }  repositories { \tmavenCentral() }  dependencies {  \t...  \t// Spring REST Docs \tasciidoctorExtensions 'org.springframework.restdocs:spring-restdocs-asciidoctor' \ttestImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'  \t...  }  test { \tuseJUnitPlatform() }  ...  // Spring REST Docs ext { \tsnippetsDir = file('build/generated-snippets') }  test { \toutputs.dir snippetsDir }  asciidoctor { \tconfigurations 'asciidoctorExtensions' \tinputs.dir snippetsDir \tdependsOn test }  bootJar { \tdependsOn asciidoctor \tfrom (\"${asciidoctor.outputDir}/html5\") { \t\tinto 'static/docs' \t} }   docs 조각: ./build/generated-snippets//.adoc   docs build: ./build/docs/asciidoc/index.html       스프링 REST Docs 요청/응답 본문 문서화   EventControllerTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package me.whiteship.demoinflearnrestapi.events;  ...  import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;  ...  @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc @AutoConfigureRestDocs public class EventControllerTests {      @Autowired     MockMvc mockMvc;      @Autowired     ObjectMapper objectMapper;      @Test     @DisplayName(\"정상적으로 이벤트를 생성하는 테스트\")     public void createEvent() throws Exception {         EventDto event = EventDto.builder()                 ...                 .build();          mockMvc.perform(post(\"/api/events/\")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaTypes.HAL_JSON)                 .content(objectMapper.writeValueAsString(event)))                 .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음                 ...                 .andDo(document(\"create-event\"));     } \t... }   @AutoConfigureRestDocs 어노테이션, andDo(document(“create-event”));   문서는 생성되지만 포맷팅이 안되어 보기에 안좋다   1 2 3 4 5 6 7 8 9 [source,http,options=\"nowrap\"] ---- HTTP/1.1 201 Created Location: http://localhost:8080/api/events/1 Content-Type: application/hal+json Content-Length: 565  {\"id\":1,\"name\":\"Spring\",\"description\":\"REST API development with Spring\",\"beginEnrollmentDateTime\":\"2022-01-18T14:21:22\",\"closeEnrollmentDateTime\":\"2022-01-19T14:21:22\",\"beginEventDateTime\":\"2022-01-25T14:21:22\",\"endEventDateTime\":\"2022-01-26T14:21:22\",\"location\":\"강남역\",\"basePrice\":100,\"maxPrice\":200,\"limitIfEnrollment\":100,\"offline\":true,\"free\":false,\"eventStatus\":\"DRAFT\",\"_links\":{\"self\":{\"href\":\"http://localhost:8080/api/events/1\"},\"query-events\":{\"href\":\"http://localhost:8080/api/events\"},\"update-event\":{\"href\":\"http://localhost:8080/api/events/1\"}}} ----      따라서, 아래와 같이 빈하나를 만들어주고 EventControllerTests.java 에 빈을 등록해줌   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package me.whiteship.demoinflearnrestapi.common;  import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.context.annotation.Bean;  import static org.springframework.restdocs.operation.preprocess.Preprocessors.prettyPrint;  @TestConfiguration public class RestDocsConfiguration {      @Bean     public RestDocsMockMvcConfigurationCustomizer restDocsMockMvcConfigurationCustomizer() {         return configurer -&gt; configurer.operationPreprocessors()                 .withRequestDefaults(prettyPrint())                 .withResponseDefaults(prettyPrint());     } }   EventControllerTests.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package me.whiteship.demoinflearnrestapi.events;  ...  import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;  ...  @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc @AutoConfigureRestDocs @Import(RestDocsConfiguration.class) public class EventControllerTests {  \t\t...  }   그럼 포맷팅되어 이쁘게 나옴   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 [source,http,options=\"nowrap\"] ---- HTTP/1.1 201 Created Location: http://localhost:8080/api/events/1 Content-Type: application/hal+json Content-Length: 733  {   \"id\" : 1,   \"name\" : \"Spring\",   \"description\" : \"REST API development with Spring\",   \"beginEnrollmentDateTime\" : \"2022-01-18T14:21:22\",   \"closeEnrollmentDateTime\" : \"2022-01-19T14:21:22\",   \"beginEventDateTime\" : \"2022-01-25T14:21:22\",   \"endEventDateTime\" : \"2022-01-26T14:21:22\",   \"location\" : \"강남역\",   \"basePrice\" : 100,   \"maxPrice\" : 200,   \"limitIfEnrollment\" : 100,   \"offline\" : true,   \"free\" : false,   \"eventStatus\" : \"DRAFT\",   \"_links\" : {     \"self\" : {       \"href\" : \"http://localhost:8080/api/events/1\"     },     \"query-events\" : {       \"href\" : \"http://localhost:8080/api/events\"     },     \"update-event\" : {       \"href\" : \"http://localhost:8080/api/events/1\"     }   } } ----       스프링 REST Docs 링크 문서화, 요청/응답 헤더,필드 문서화   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \tmockMvc.perform(post(\"/api/events/\")         .contentType(MediaType.APPLICATION_JSON)         .accept(MediaTypes.HAL_JSON)         .content(objectMapper.writeValueAsString(event)))         .andDo(print()) // 어떤 요청과 응답을 받았는지 알 수 있음         .andExpect(status().isCreated())         .andExpect(jsonPath(\"id\").exists())         .andExpect(header().exists(HttpHeaders.LOCATION))         .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_VALUE))         .andExpect(jsonPath(\"id\").value(Matchers.not(100)))         .andExpect(jsonPath(\"free\").value(false))         .andExpect(jsonPath(\"offline\").value(true))         .andExpect(jsonPath(\"eventStatus\").value(Matchers.not(EventStatus.DRAFT)))         .andDo(document(\"create-event\",                 links(                         linkWithRel(\"self\").description(\"link to self\"),                         linkWithRel(\"query-events\").description(\"link to query events\"),                         linkWithRel(\"update-event\").description(\"link to update an existing\")                 ),                 requestHeaders(                         headerWithName(HttpHeaders.ACCEPT).description(\"accept header\"),                         headerWithName(HttpHeaders.CONTENT_TYPE).description(\"content type\")                 ),                 requestFields(                         fieldWithPath(\"name\").description(\"Name of new event\"),                         fieldWithPath(\"description\").description(\"description of new event\"),                         fieldWithPath(\"beginEnrollmentDateTime\").description(\"date time of begin of new event\"),                         fieldWithPath(\"closeEnrollmentDateTime\").description(\"date time of close of new event\"),                         fieldWithPath(\"beginEventDateTime\").description(\"date time of begin of new event\"),                         fieldWithPath(\"endEventDateTime\").description(\"date time of end of new event\"),                         fieldWithPath(\"location\").description(\"location of new event\"),                         fieldWithPath(\"basePrice\").description(\"base price of new event\"),                         fieldWithPath(\"maxPrice\").description(\"max price of new event\"),                         fieldWithPath(\"limitIfEnrollment\").description(\"limit of enrollment\")                 ),                 responseHeaders(                         headerWithName(HttpHeaders.LOCATION).description(\"location header\"),                         headerWithName(HttpHeaders.CONTENT_TYPE).description(\"content type\")                 ), \t\t\t\t//relaxedResponseFields(                 responseFields(                         fieldWithPath(\"id\").description(\"identifier of new event\"),                         fieldWithPath(\"name\").description(\"Name of new event\"),                         fieldWithPath(\"description\").description(\"description of new event\"),                         fieldWithPath(\"beginEnrollmentDateTime\").description(\"date time of begin of new event\"),                         fieldWithPath(\"closeEnrollmentDateTime\").description(\"date time of close of new event\"),                         fieldWithPath(\"beginEventDateTime\").description(\"date time of begin of new event\"),                         fieldWithPath(\"endEventDateTime\").description(\"date time of end of new event\"),                         fieldWithPath(\"location\").description(\"location of new event\"),                         fieldWithPath(\"basePrice\").description(\"base price of new event\"),                         fieldWithPath(\"maxPrice\").description(\"max price of new event\"),                         fieldWithPath(\"limitIfEnrollment\").description(\"limit of enrollment\"),                         fieldWithPath(\"free\").description(\"it tells is this event is free or not\"),                         fieldWithPath(\"offline\").description(\"it tells is this offline is free or not\"),                         fieldWithPath(\"eventStatus\").description(\"event status\"), \t\t\t\t\t\tfieldWithPath(\"_links.self.href\").description(\"link to self\"),                         fieldWithPath(\"_links.query-events.href\").description(\"link to query events\"),                         fieldWithPath(\"_links.update-event.href\").description(\"link to update event\")                 )         ));       responseFields 를 쓰면 오류가 발생한다   응답에는 links도 포함된다고 생각하는데 links에 대한 정의가 없기 때문에 오류 발생   responseFields 대신 relaxedResponseFields 를 써줄수 있다.       relaxed prefix(접두어) 를 사용할 때      장점: 문서 일부분만 테스트 할 수 있다.   단점: 정확한 문서를 생성하지 못한다.       응답 필드에 links 에 대한 정보를 다시 써줘야하는 번거로움이 있지만 relaxed 는 가급적 사용하지 않는 것을 권장함       src&gt;main&gt;asciidoc&gt;index.adoc 생성   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 = REST API Guide 백기선; :doctype: book :icons: font :source-highlighter: highlightjs :toc: left :toclevels: 4 :sectlinks: :operation-curl-request-title: Example request :operation-http-response-title: Example response  [[overview]] = 개요  [[overview-http-verbs]] == HTTP 동사  본 REST API에서 사용하는 HTTP 동사(verbs)는 가능한한 표준 HTTP와 REST 규약을 따릅니다.  |=== | 동사 | 용례  | `GET` | 리소스를 가져올 때 사용  | `POST` | 새 리소스를 만들 때 사용  | `PUT` | 기존 리소스를 수정할 때 사용  | `PATCH` | 기존 리소스의 일부를 수정할 때 사용  | `DELETE` | 기존 리소스를 삭제할 때 사용 |===  [[overview-http-status-codes]] == HTTP 상태 코드  본 REST API에서 사용하는 HTTP 상태 코드는 가능한한 표준 HTTP와 REST 규약을 따릅니다.  |=== | 상태 코드 | 용례  | `200 OK` | 요청을 성공적으로 처리함  | `201 Created` | 새 리소스를 성공적으로 생성함. 응답의 `Location` 헤더에 해당 리소스의 URI가 담겨있다.  | `204 No Content` | 기존 리소스를 성공적으로 수정함.  | `400 Bad Request` | 잘못된 요청을 보낸 경우. 응답 본문에 더 오류에 대한 정보가 담겨있다.  | `404 Not Found` | 요청한 리소스가 없음. |===  [[overview-errors]] == 오류  에러 응답이 발생했을 때 (상태 코드 &gt;= 400), 본문에 해당 문제를 기술한 JSON 객체가 담겨있다. 에러 객체는 다음의 구조를 따른다.  include::{snippets}/errors/response-fields.adoc[]  예를 들어, 잘못된 요청으로 이벤트를 만들려고 했을 때 다음과 같은 `400 Bad Request` 응답을 받는다.  include::{snippets}/errors/http-response.adoc[]  [[overview-hypermedia]] == 하이퍼미디어  본 REST API는 하이퍼미디어와 사용하며 응답에 담겨있는 리소스는 다른 리소스에 대한 링크를 가지고 있다. 응답은 http://stateless.co/hal_specification.html[Hypertext Application from resource to resource. Language (HAL)] 형식을 따른다. 링크는 `_links`라는 키로 제공한다. 본 API의 사용자(클라이언트)는 URI를 직접 생성하지 않아야 하며, 리소스에서 제공하는 링크를 사용해야 한다.  [[resources]] = 리소스  [[resources-index]] == 인덱스  인덱스는 서비스 진입점을 제공한다.  [[resources-index-access]] === 인덱스 조회  `GET` 요청을 사용하여 인덱스에 접근할 수 있다.  operation::index[snippets='response-body,http-response,links']  [[resources-events]] == 이벤트  이벤트 리소스는 이벤트를 만들거나 조회할 때 사용한다.  [[resources-events-list]] === 이벤트 목록 조회  `GET` 요청을 사용하여 서비스의 모든 이벤트를 조회할 수 있다.  operation::get-events[snippets='response-fields,curl-request,http-response,links']  [[resources-events-create]] === 이벤트 생성  `POST` 요청을 사용해서 새 이벤트를 만들 수 있다.  operation::create-event[snippets='request-fields,curl-request,http-request,request-headers,http-response,response-headers,response-fields,links']  [[resources-events-get]] === 이벤트 조회  `Get` 요청을 사용해서 기존 이벤트 하나를 조회할 수 있다.  operation::get-event[snippets='request-fields,curl-request,http-response,links']  [[resources-events-update]] === 이벤트 수정  `PUT` 요청을 사용해서 기존 이벤트를 수정할 수 있다.  operation::update-event[snippets='request-fields,curl-request,http-response,links']       EventController.java   profile 관련 코드 추가 (테스트 코드에도 추가해주기)   1 eventResource.add(Link.of(\"/docs/index.html#resources-events-create\").withRel(\"profile\"));       maven&gt;Lifecycle&gt;package 실행하면 target/classes/static/docs 에 index.html 파일이 생성된다.       http://localhost:8080/docs/index.html 로 접속하면 REST 문서 작성 내용을 볼 수 있다.  ","categories": ["Spring"],
        "tags": ["Spring","Java","REST API","TEST CODE"],
        "url": "/spring/Java-Spring-REST-Docs/",
        "teaser": ""
      },{
        "title": "객체지향개념(추상클래스, 추상메서드, 추상클래스의 작성, 인터페이스, 인터페이스 장점, 인터페이스 이해, 디폴트 메서드)",
        "excerpt":"6. 추상 클래스(abstract class)   6.1 추상클래스란?      미완성(부족한) 설계도. 미완성 메서드를 갖고 있는 클래스   1 2 3 4 abstract class Player { // 추상클래스(미완성 클래스) \tabstract void play(int pos); // 추상메서드(몸통{}이 없는 미완성 메서드) \tabstract void stop(); // 추상메서드 }       클래스 또는 메서드 앞에 abstract 를 붙이면 추상 클래스 또는 추상 메서드인 것을 알 수 있다.          다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가.   1 Player p = new Player(); // 에러. 추상 클래스의 인스턴스 생성 불가          상속을 통해 추상 메서드를 완성해야 인스턴스 생성가능   1 2 3 4 5 6 7 class AudioPlayer extends Player { \tvoid play(int pos) { /* 내용 생략 */ } // 추상 메서드 구현 \tvoid stop() { /* 내용 생략 */ } // 추상 메서드 구현(구현이란 추상 메서드 몸통 만들기) }  AudioPlayer ap = new AudioPlayer(); // OK. 인스턴스 생성됨 Player ap = new AudioPlayer(); // 다형성 (Plyer = 부모, AudioPlayer **= 자손**)       6.2 추상 메서드(abstract method)      미완성 메서드. 구현부(몸통, {})가 없는 메서드   1 2 /* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */ abstract 리턴타입 메서드이름();       미완성 메서드를 사용하는 이유?   메서드의 내용이 상속받는 클래스에 따라 달라질 수 있음.   따라서, 조상 클래스 → 선언부 + 주석 작성(어떤 기능을 수행할지)   실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것.          꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우 추상 메서드를 사용한다   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class Player { \tabstract void play(int pos); // 추상메서드 \tabstract void stop(); // 추상메서드 }  class AudioPlayer extends Player { \tvoid play(int pos) { /* 내용 생략 */ } // 추상메서드를 구현 \tvoid stop() { /* 내용 생략 */ } // 추상메서드를 구현 }  // 아래는 일부만 구현. 따라서, 미완성이기 때문에 추상메서드가 있다는걸 알려주기 위해 abstract 붙임 abstract class AbstractPlayer extends Player { \tvoid play(int pos) { /* 내용 생략 */ } // 추상메서드 구현 \t// abstract void stop(); // 이게 있는거. }          추상 메서드 호출 가능 (호출할 때는 선언부만 필요)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 abstract class Player { \tboolean pause; // iv \tint currentPos; // iv  \tPlayer() { // 추상 클래스도 생성자가 있어야 한다. \t\tpause = false; \t\tcurrentPos = 0; \t}  \tabstract void play(int pos); // 추상메서드 \tabstract void stop(); // 추상메서드  \tvoid play() { \t\t// 호출 \t\tplay(currentPos); // 추상메서드를 사용할 수 있다. \t} }       추상클래스는 일반 클래스와 똑같다(지역변수, 생성자 등). 단지, 추상메서드가 포함되었을 뿐!       추상메서드를 호출하면 오류나는거 아닌가?   → 오류 발생하지 않음!      상속을 통해서 자손이 완성   자손 객체 생성       6.2.1 추상으로 만드는 이유!   강요하기 위해서! abstract 를 사용하면 나중에 구현부를 작성해야 한다는 사실을 인식하여 자신의클래스에 맞게 구현할 것이다.       6.3 추상클래스의 작성       추상클래스 = 미완성 설계도(미완성 메서드 포함)   추상메서드 = 미완성 메서드 = 몸통 없는 메서드          여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.       기존 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Marine { \tint x, y; // 현재 위치 \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ } \tvoid stop() { /* 현재 위치에 정지 */ } \tvoid stimPack() { /* 스팀팩을 사용 */ } }  class Tank { \tint x, y; // 현재 위치 \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ } \tvoid stop() { /* 현재 위치에 정지 */ } \tvoid changeMode() { /* 공격모드를 변환 */ } }  class Dropship { \tint x, y; // 현재 위치 \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ } \tvoid stop() { /* 현재 위치에 정지 */ } \tvoid load() { /* 선택된 대상을 태운다 */ } \tvoid unload() { /* 선택된 대상을 내린다 */ } }       추상클래스를 적용한 코드: 공통 부분을 추출, 코드의 중복을 제거   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract class Unit { \tint x, y; \tabstract void move(int x, int y); \tvoid stop() { /* 현재 위치에 정지 */ } }  class Marine extends Unit { \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }; \tvoid stimPack() { /* 스팀팩을 사용 */ }; }  class Tank extends Unit { \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }; \tvoid changeMode() { /* 공격모드를 변환 */ }; }  class Dropship extends Unit { \tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }; \tvoid load() { /* 선택된 대상을 태운다 */ }; \tvoid unload() { /* 선택된 대상을 내린다 */ }; }   abstract void move(int x, int y); 대신 abstract 없애고  void move(int x, int y) { }; 작성할 수도 있다. 그러나, abstract를 사용하지 않으면 move가 구현되어있다고 생각하고 구현을 안할 수도 있다. 따라서, 직관적으로 abstract를 붙이는게 좋다.       정상 코드: 다형성의 장점도 나옴   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 아래 코드는 그 다음 4줄의 코드와 같다. // Unit[] group = { new Marine(), new Tank(), new Dropship() }; Unit[] group = new Unit[3]; group[0] = new Marine(); group[1] = new Tank(); group[2] = new Dropship();  for(int i=0; i&lt;group.length; i++) { \tgroup[i].move(100, 200); // 추상메서드를 호출하는 것이 아니라 각자 구현된 메서드를 호출 }  // group의 타입은 Unit[] / group[0], group[1], group[2]의 타입은 Unit // group[0], group[1], group[2]: 참조변수(리모콘) group[0].move(100, 200); // Marine객체의 move 호출 group[1].move(100, 200); // Tank객체의 move 호출 group[2].move(100, 200); // Dropship객체의 move 호출          오류 코드   1 2 3 4 5 6 7 8 Object[] group = new Object[3]; group[0] = new Marine(); group[1] = new Tank(); group[2] = new Dropship();  for(int i=0; i&lt;group.length; i++) { \tgroup[i].move(100, 200); // 에러 발생. Object클래스에는 move메서드가 없다 }          6.3.1 추상화 ↔ 구체화      추상화된 코드는 구체화된 코드보다 유연하다. 변경에 유리   1 2 3 GregorianCalendar cal = new GregorianCalendar(); // 구체적(분명, 명확)  Calendar cal = Calendar.getInstance(); // 추상적(불분명)   1 2 3 4 public static Calendar getInstance(Locale aLocale) { \t// 지역에 따라 캘린더 다르게 가져옴 \treturn createCalendar(TimeZone.getDefault(), aLocale); }       7. 인터페이스(interface)   7.1 인터페이스란?      일종의 추상클래스, 추상 메서드의 집합 (핵심!)   static 메서드, 디폴트 메서드, 상수 등도 인터페이스에 속함 (부수적인 것)   구현된 것이 전혀 없는 설계도. 껍데기(모든 멤버가 public)       메서드를 이용해 변수에 접근 → 캡슐화       7.1.1 추상클래스와 인터페이스의 차이   추상 클래스: 일반 클래스인데 추상 메서드를 가지고 있는 것, 생성자 및 iv가 있다.   인터페이스: 구현된 것이 없고 추상메서드만 나열   추상클래스는 미완성 설계도라 한다면, 인터페이스는 기본 설계도라 할 수 있다.       7.2 인터페이스의 작성   1 2 3 4 interface 인터페이스이름 { \tpublic static final 타입 상수이름 = 값; // 상수, iv와 cv는 가질 수 없음 \tpublic abstract 메서드이름(매개변수목록); // 추상메서드 }   인터페이스 멤버들 제약사항      모든 멤버변수는 public static final, 생략할 수 있다   모든 메서드는 public abstract, 생략할 수 있다 (단, static 메서드, 디폴트 메서드 제외)       1 2 3 4 5 6 7 8 9 10 11 12 13 interface PlayingCard { \t// 상수 시작 \tpublic static final int SPADE = 4; \tfinal int DIAMOND = 3; \tstatic int HEART = 2; \tint CLOVER = 1; // public, static, final 생략가능 \t// 상수 끝  \t// 추상메서드 시작 \tpublic abstract String getCardNumber(); \tString getCardKind(); // public, abstract 생략가능 \t// 추상메서드 끝 }       7.3 인터페이스의 상속      인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상 아님)   다중 상속이 가능 (추상메서드는 충돌해도 문제 없음)            다중 상속의 문제점은 선언부가 같고 내용이 달라 어느쪽을 상속받을지 결정할 수 없다는 점(충돌 발생)       그런데, 추상메서드의 경우 몸통이 없기 때문에 충돌이 발생하지 않는다.           1 2 3 4 5 6 7 8 9 interface Fightable extends Movable, Attackable {}  interface Movable { \tvoid move(int x, int y); }  interface Attackable { \tvoid attack(Unit u); }       7.4 인터페이스의 구현      인터페이스에 정의된 추상 메서드를 완성하는 것   1 2 3 class 클래스이름 implements 인터페이스이름 { \t// 인터페이스에 정의된 추상메서드를 모두 구현해야 한다. }       1 2 3 4 5 6 7 8 9 interface Fightable { \tvoid move(int x, int y); \tvoid attack(Unit u); }  class Fighter implements Fightable { \tpublic void move(int x, int y) { /* 내용 생략 */ } \tpublic void attack(Unit u) { /* 내용 생략 */ } }   class Fighter implements Fightable 은 Fighter 클래스는 Fightable 인터페이스를 구현 이라고 말할 수 있다.          일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함   1 2 3 4 abstract class Fighter implements Fightable { \tpublic void move(int x, int y) { /* 내용 생략 */ } \t// public abstract void attack(Unit u); // 이것이 생략된거.. }       Q. 인터페이스란?   추상메서드의 집합 (그 밖에 상수, static 메서드, 디폴트 메서드가 있다. 그러나 이들은 핵심이 아니다. 추상메서드가 핵심!)   Q. 인터페이스의 구현이란?   인터페이스의 추상메서드 몸통만들기(미완성 설계도 완성하기)   1 2 3 4 5 6 class AudioPlayer extends Player {}  class Fighter implements Fightable {}  // AudioPlayer, Fighter: 완성된 설계도 // Player, Fightable: 미완성 설계도   Q. 추상 클래스와 인터페이스의 공통점   추상메서드를 가지고 있다. (미완성 설계도)   Q. 추상 클래스와 인터페이스의 차이점   인터페이스는 iv(인스턴스 변수)를 가질 수 없다.       7.5 인터페이스를 이용한 다중상속       7.6 인터페이스를 이용한 다형성   다형성: 조상 참조변수로 자손 객체를 가리키는것   1 Tv t = new SmartTv();       인터페이스도 다형성이 성립한다.   1 2 Fightable f = (Fightable) new Fighter(); Fightable f = new Fighter();          인터페이스도 구현 클래스의 부모? yes   인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능   1 2 3 4 5 6 7 8 9 10 11 12 interface Fightable { \tvoid move(int x, int y); \tvoid attack(Fightable f); }  class Fighter extends Unit implements Fightable { \tpublic void move(int x, int y) { /* 내용생략 */ } \tpublic void attack(Fightable f) { /* 내용생략 */ } }  Unit u = new Fighter(); Fightable f = new Fighter();   Unit: 조상클래스 / Fighter: 자손객체 / Fightable: 인터페이스 (구현)               인터페이스를 메서드의 리턴타입으로 지정할 수 있다.       → 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미       1 2 3 4 5 6 7 8 9 10 11 12 13 // Fightable 인터페이스를 구현한 클래스의 인스턴스를 반환 // 다형성으로 인해 Fighter 반환이 가능 Fightable method() { \t... \tFighter f = new Fighter(); \treturn f; \t// return (Fightable) f; }  class Fighter extends Unit implements Fightable { \tpublic void move(int x, int y) { /* 내용생략 */ } \tpublic void attack(Fightable f) { /* 내용생략 */ } }   class Fighter implements Fightable: Fighter클래스가 Fightable(인터페이스)을 구현   (Fightable: 조상 / Fighter: 자손)       예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 abstract class Unit { \tint x, y; \tabstract void move(int x, int y); \tvoid stop() { \t\tSystem.out.println(\"멈춥니다.\"); \t} }  // 인터페이스의 모든 메서드는 public abstract. 예외없이 interface Fightable { \tvoid move(int x, int y); // public abstract가 생략됨 \tvoid attack(Fightable f); // public abstract가 생략됨 }  class Fighter extends Unit implements Fightable { \t// 오버라이딩 규칙: 조상(public)보다 접근제어자가 범위가 좁으면 안된다. \tpublic void move(int x, int y) { \t\tSystem.out.println(\"[\"+x+\",\"+y+\"]로 이동\"); \t} \tpublic void attack(Fightable f) { \t\tSystem.out.println(f+\"를 공격\"); \t}  \tFightable getFightable() { \t\tFighter f = new Fighter(); // Fighter를 생성해서 반환 \t\treturn (Fightable)f; \t} }  public class FighterTest { \tpublic static void main(String[] args) { \t\tFightable f = new Fighter(); \t\tf.move(100, 200); \t\tf.attack(new Fighter()); \t\t// f.stop(); // Fightable에는 stop()이 없어서 호출불가  \t\tUnit u = new Fighter(); \t\tu.move(100, 200); \t\t// u.attack(new Fighter()); // Unit에는 attack()이 없어서 호출불가  \t\tFightable f2 = f.getFightable(); \t} }   리턴 타입이 Fightable 인 것은 Fightable 인터페이스를 구현한 객체를 반환한다. 는 뜻!       7.7 인터페이스의 장점      개발 시간을 단축할 수 있다.   변경에 유리한 유연한 설계가 가능하다.   표준화가 가능하다.   서로 관계없는 클래스들을 관계를 맺어줄 수 있다.       상속계층도      Unit 클래스: 최고 조상   유닛의 종류는 지상유닛(GroundUnit), 공중유닛(AirUnit)       1 2 3 4 5 6 7 void repair(Tank t) { \t// Tank를 수리 }  void repair(Dropship d) { \t// Dropship을 수리 }   위와 같이 작성하면 Unit의 개수만큼 오버로딩해야 함.       이를 피하기 위해 공통 조상으로 한다고 해도 최소 2개의 메서드가 필요함.   1 2 3 4 5 6 7 void repair(GroundUnit gu) { \t// 매개변수로 넘겨진 지상유닛을 수리함 }  void repair(AirUnit au) { \t// 매개변수로 넘겨진 공중유닛을 수리함 }   그리고  Marine과 같이 기계화 유닛이 아닌 클래스도 포함될 수 있기 때문에 repair메서드의 매개변수로 GroundUnit은 부적절함!       위의 문제를 해결하기 위해 Repairable이라는 인터페이스를 정의   1 2 3 4 5 6 7 8 9 10 11 12 13 interface Repairable {}  class SCV extends GroupUnit implements Repairable { \t// .. }  class Tank extends GroupUnit implements Repairable { \t// .. }  class Dropship extends GroupUnit implements Repairable { \t// .. }   이제 위 3개의 클래스는 같은 인터페이스를 구현했다는 공통점이 생김!   → 서로 관계없는 클래스들을 관계를 맺어줌       repair 메서드의 매개변수를 Repairable로 선언   1 2 3 void repair(Repairable r) { \t// 매개변수로 넘겨받은 유닛을 수리한다. }   Repairable r : 인터페이스 Repairable를 구현한 멤버들만 들어와라       7.8 인터페이스의 이해   interface = inter(~사이, between) + face(얼굴)      두 대상(객체)간의 연결, 대화, 소통을 돕는 중간 역할을 한다.   선언(설계)와 구현을 분리시킬 수 있게 한다.   1 2 3 4 5 class B { \tpublic void method() { \t\tSystem.out.println(\"methodInB\"); \t} }   위의 코드를 아래와 같이 분리할 수 있다.   1 2 3 4 // 선언부 interface I { \tpublic void method(); }   1 2 3 4 5 6 // 구현부 class B implements I { \tpublic void method() { \t\tSystem.out.println(\"methodInB\"); \t} }      인터페이스 덕분에 B가 변경되어도 A는 안바꿀 수 있게 된다.(느슨한 결합)       직접적인 관계의 두 클래스(A-B)   → 강한 결합 : A가 B를 사용(A가 B를 의존).          간접적인 관계의 두 클래스(A-I-B)   → 느슨한 결합 : 변경에 유리하고 유연한 코드가 된다.          1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class A { \tpublic void method(B b) { \t// public void method(C b) { // C를 사용할 때 \t\tb.method(); \t} }  class B { \tpublic void mehotd() { \t\tSystem.out.println(\"B클래스의 메서드\"); \t} }  class C { \tpublic void mehotd() { \t\tSystem.out.println(\"C클래스의 메서드\"); \t} }  public class InterfaceTest { \tpublic static void main(String[] args) { \t\tA a = new A(); \t\ta.method(new B()); // A가 B를 사용(의존) \t\t// a.method(new C()); // A가 C를 사용(의존) \t} }   main을 수정하면 A클래스도 수정해야 함 (클래스 A의 변화가 있음)       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class A { \tpublic void method(I i) { // 인터페이스 I를 구현한 멤버들만 들어와라 \t\ti.method(); \t} }  // B클래스의 선언과 구현을 분리 interface I { \tpublic void method(); }  class B implements I { \tpublic void mehotd() { \t\tSystem.out.println(\"B클래스의 메서드\"); \t} }  class C implements I { \tpublic void mehotd() { \t\tSystem.out.println(\"C클래스의 메서드\"); \t} }  public class InterfaceTest { \tpublic static void main(String[] args) { \t\tA a = new A(); \t\ta.method(new C()); // A가 B를 사용(의존) \t} }   main을 수정해도 인터페이스를 사용하면 A클래스를 수정할 필요가 없음 (클래스 A의 변화가 없음)       7.8.1 디폴트 메서드와 static 메서드   기존의 인터페이스는 추상 메서드만 존재.       아래와 같은 가정을 하였을때 인터페이스의 원칙에 의해 ClassA, ClassB, ClassC 에 모두 methodA를 구현해야 함.      총 3개의 ClassA, ClassB, ClassC 클래스가 InterfaceA를 구현하고 있다.   이때, 요구사항이 추가. InterfaceA에 특정 추상 메서드 methodA 가 추가됨   이를 해결하기 위해 default 메서드 사용       디폴트 메서드와 static 메서드      인터페이스에 디폴트 메서드, static 메서드 추가 기능        인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움       해결책 ⇒ 디폴트 메서드(default method)       디폴트 메서드는 인스턴스 메서드(인터페이스 원칙 위반)   1 2 3 4 interface MyInterface { \tvoid method(); \tvoid newMethod(); // 추상 메서드 }   1 2 3 4 interface MyInterface { \tvoid method(); \tdefault void newMethod(); // 추상 메서드 }               디폴트 메서드가 기존의 메서드와 충돌할 때의 해결책       → 직접 오버라이딩하면 해결됨       1 2 3 4 1. 여러 인터페이스의 디폴트 메서드 간의 충돌  - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다. 2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌  - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP8/",
        "teaser": ""
      },{
        "title": "DIP, OCP와 의존관계 주입(DI)",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   DIP, OCP를 지키기 위해선 다형성만으론 부족하다. 의존관계 주입(DI) 개념이 필요하다.   의존관계 주입에 대해 알아보기 전에 아래 요구사항과 그에 따른 코드 흐름을 살펴보자.       요구사항 정의서와 설계   회원 도메인 설계      회원을 가입하고 조회할 수 있다   회원은 일반과 VIP 두가지 등급이 있다   회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다 (미확정)   주문과 할인      회원은 상품을 주문할 수 있다   회원 등급에 따라 할인 정책을 적용할 수 있다   할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용한다 (나중에 변경 될 수 있다)   할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용할지 않을 수도 있다. (미확정)         요구사항 정의서를 보면 미확정된 요구사항이 있어 구현하기 어려운 점이 있다. 하지만, 우리에겐 객체 지향 설계 방법이 있다. 인터페이스, 구현체 형식으로 설계를 하고 나중에 변경된 구현체는 갈아끼우자.       회원 저장소   1 2 3 4 5 6 7 8 package hello.core.member;  public interface MemberRepository {      void save(Member member);      Member findById(Long memberId); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package hello.core.member;  import java.util.HashMap; import java.util.Map;  public class MemoryMemberRepository implements MemberRepository {      private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();      @Override     public void save(Member member) {         store.put(member.getId(), member);     }      @Override     public Member findById(Long memberId) {         return store.get(memberId);     } }   회원 데이터에 대한 저장 부분이 아직 미확정이지만 개발은 진행해야 하므로 가장 단순한 메모리 회원 저장소를 구현해서 개발을 진행한다.       회원 서비스   1 2 3 4 5 6 7 8 package hello.core.member;  public interface MemberService {      void join(Member member);      Member findMember(Long memberId); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package hello.core.member;  public class MemberServiceImpl implements MemberService {      private final MemberRepository memberRepository = new MemoryMemberRepository();      @Override     public void join(Member member) {         memberRepository.save(member);     }      @Override     public Member findMember(Long memberId) {         return memberRepository.findById(memberId);     } }       할인 정책   1 2 3 4 5 6 7 8 package hello.core.discount;  import hello.core.member.Member;  public interface DiscountPolicy {      int discount(Member member, int price); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package hello.core.discount;  import hello.core.member.Grade; import hello.core.member.Member;  public class FixDiscountPolicy implements DiscountPolicy {      private int discountFixAmount = 1000; // 1000원 할인      @Override     public int discount(Member member, int price) {         if (member.getGrade() == Grade.VIP) {             return discountFixAmount;         } else {             return 0;         }     } }       주문 서비스   1 2 3 4 5 6 package hello.core.order;  public interface OrderService {      Order createOrder(Long memberId, String itemName, int itemPrice); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package hello.core.order;  import hello.core.discount.DiscountPolicy; import hello.core.discount.FixDiscountPolicy; import hello.core.member.Member; import hello.core.member.MemberRepository; import hello.core.member.MemoryMemberRepository;  public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository = new MemoryMemberRepository();      private final DiscountPolicy discountPolicy = new FixDiscountPolicy();      @Override     public Order createOrder(Long memberId, String itemName, int itemPrice) {         Member member = memberRepository.findById(memberId);         int discountPrice = discountPolicy.discount(member, itemPrice);          return new Order(memberId, itemName, itemPrice, discountPrice);     } }       [참고] OrderServiceImpl.createOrder() 메소드   1 int discountPrice = discountPolicy.discount(member, itemPrice);   아래 코드는 discountPolicy에게 할인된 가격을 알아서 계산해서 return 해달라는 코드이다. 이 코드는 단일책임원칙(SRP)을 매우 잘 지킨 코드이다. 만약, 할인 정책이 바뀌더라도 할인 쪽 코드만 변경하면 되고 주문 관련 코드는 변경할 필요가 없다. (만일, 단일책임원칙을 적용하지 않고 주문 쪽 코드에 할인 정책까지 같이 작성했다면 할인 정책 변경 시 주문 코드를 변경해야 되므로 단일책임원칙에 위배된다.)       현재까지 코드는 주문 생성 요청이 오면, 회원 정보를 조회하고 할인 정책을 적용한 다음 주문 객체를 생성해서 반환한다. 메모리 회원 리포지토리와 고정 금액 할인 정책을 구현체로 생성한다. 즉, 역할(인터페이스)과 구현(구현체)을 분리하여 작성했기 때문에 앞에서 말한 DIP를 지켰다.   그런데, 요구사항에 변경이 생겨도 DIP와 OCP원칙을 지킬 수 있을까? 이 부분에 대해 생각을 하면서 다음 요구사항 변경을 살펴보자.       새로운 할인 정책 개발      고정 금액 할인이 아닌 정률%할인으로 변경하고 싶다   예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데, 이번에 새로 나온 정책은 10%로 지정해두면 고객이 10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인       새로운 할인 정책에 대한 구현체   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package hello.core.discount;  import hello.core.member.Grade; import hello.core.member.Member;  public class RateDiscountPolicy implements DiscountPolicy {      private int discountPercent = 10; // 10% 할인      @Override     public int discount(Member member, int price) {         if (member.getGrade() == Grade.VIP) {             return price * discountPercent / 100;         } else {             return 0;         }     } }       우리는 분명 DIP원칙(인터페이스, 구현체)을 지키면서 코드를 작성하였다. 그런데, 새로운 할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 고쳐야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package hello.core.order;  import hello.core.discount.DiscountPolicy; import hello.core.discount.FixDiscountPolicy; import hello.core.discount.RateDiscountPolicy; import hello.core.member.Member; import hello.core.member.MemberRepository; import hello.core.member.MemoryMemberRepository;  public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository = new MemoryMemberRepository();  //    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();     private final DiscountPolicy discountPolicy = new RateDiscountPolicy();      ... }   문제가 생겼다. 우리는 역할과 구현을 충실하게 분리했고 다형성을 활용하여 인터페이스와 구현 객체를 분리했다. 그런데, DIP와 OCP를 위반했다.       1. DIP 위반   OrderServiceImpl 은 DiscountPolicy에만 의존하는 것이 아닌 FixDiscountPolicy 와 RateDiscountPolicy에도 의존한다. 즉, 추상에만 의존하는 것이 아닌 구체에도 의존하고 있다.      추상(인터페이스) 의존: DiscountPolicy   구체(구현) 클래스: FixDiscountPolicy, RateDiscountPolicy   2. OCP 위반   고정금액할인에서 정률%할인으로 변경 시 OrderServiceImpl을 변경해야 한다. 따라서, 지금 코드는 기능을 확장해서 변경하면 클라이언트 코드에 영향을 준다.            참고   OCP는 확장엔 열려있으나 변경에는 닫혀있어야 한다는 뜻, DIP는 구현 클래스에 의존하지 않고 인터페이스에 의존해야한다는 뜻이다.         위의 DIP, OCP 위반 문제들을 해결하려면 클라이언트(OrderServiceImpl)가 인터페이스에만 의존하도록 설계를 변경하면 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package hello.core.order;  import hello.core.discount.DiscountPolicy; import hello.core.member.Member; import hello.core.member.MemberRepository; import hello.core.member.MemoryMemberRepository;  public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository = new MemoryMemberRepository();      private DiscountPolicy discountPolicy;      @Override     public Order createOrder(Long memberId, String itemName, int itemPrice) {         Member member = memberRepository.findById(memberId);         int discountPrice = discountPolicy.discount(member, itemPrice);          return new Order(memberId, itemName, itemPrice, discountPrice);     } }   그러나, 실행하면 discountPolicy에 대한 구현체가 없기 때문에 NullPointException 발생한다.   이 문제를 해결하려면 누군가 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해주어야 한다.       관심사의 분리   관심사를 분리해야 한다. 애플리케이션을 연극에 비유하면 다음과 같다.      애플리케이션 - 연극   인터페이스 - 배역   구현체 - 담당 배우   AppConfig - 공연 기획       AppConfig 등장   구현 객체를 생성하고 연결(주입)하는 책임을 가지는 별도의 설정 클래스를 만들자   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package hello.core;  import hello.core.discount.FixDiscountPolicy; import hello.core.member.MemberService; import hello.core.member.MemberServiceImpl; import hello.core.member.MemoryMemberRepository; import hello.core.order.OrderService; import hello.core.order.OrderServiceImpl;  public class AppConfig {      public MemberService memberService() {         return new MemberServiceImpl(new MemoryMemberRepository());     }      public OrderService orderService() {         return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());     } }   AppConfig에 애플리케이션의 실제 동작에 필요한 구현 객체를 생성      MemberServiceImpl   MemoryMemberRepository   OrderServiceImpl   FixDiscountPolicy   AppConfig는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입(연결)      MemberServiceImpl → MemoryMemberRepository   OrderServiceImpl → MemoryMemberRepository, FixDiscountPolicy       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package hello.core.member;  public class MemberServiceImpl implements MemberService {      private final MemberRepository memberRepository;      public MemberServiceImpl(MemberRepository memberRepository) {         this.memberRepository = memberRepository;     }      @Override     public void join(Member member) {         memberRepository.save(member);     }      @Override     public Member findMember(Long memberId) {         return memberRepository.findById(memberId);     } }   이제 MemberServiceImpl은 MemoryMemberRepository에 의존하지 않는다. 단지, MemberRepository 인터페이스만 의존한다. 그리고 MemberServiceImpl 입장에서 생성자를 통해 어떤 구현 객체가 들어올지(주입될지) 알 수 없고 MemberServiceImpl의 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부(’AppConfig’)에서 결정된다. MemberServiceImpl은 이제부터 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중한다.          위 그림을 살펴보면 AppConfig가 MemberServiceImpl 객체와 MemoryMemberRepository 객체를 생성한다. 객체의 생성과 연결은 AppConfig가 담당한다.   이를 통해 얻은 것은 두가지이다.      DIP 완성: MemberServiceImpl은 MemberRepository인 추상에만 의존하면 된다. (구체 클래스는 신경쓰지 않아도 된다.)   관심사의 분리: 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리되었다.          AppConfig 객체는 memoryMemberRepository 객체를 생성하고 그 참조값을 memberServiceImpl을 생성하면서 생성자로 전달한다. 클라이언트인 memberServiceImpl 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것 같다고 해서 DI(Dependency Injection) 의존관계 주입이라고 한다.       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package hello.core.order;  import hello.core.discount.DiscountPolicy; import hello.core.member.Member; import hello.core.member.MemberRepository;  public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository;     private final DiscountPolicy discountPolicy;      public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {         this.memberRepository = memberRepository;         this.discountPolicy = discountPolicy;     }      @Override     public Order createOrder(Long memberId, String itemName, int itemPrice) {         Member member = memberRepository.findById(memberId);         int discountPrice = discountPolicy.discount(member, itemPrice);          return new Order(memberId, itemName, itemPrice, discountPrice);     } }   OrderServiceImpl은 FixDiscountPolicy를 의존하지 않는다. (DiscountPolicy 인터페이스에만 의존) OrderServiceImpl은 이제 실행에만 집중하고 OrderServiceImpl의 생성자를 통해 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다. OrderServiceImpl에는 MemoryMemberRepository, FixDiscountPolicy 객체의 의존관계가 주입된다.       정리      AppConfig를 통해서 관심사를 확실하게 분리   AppConfig는 공연 기획자   AppConfig는 구체 클래스를 선택한다. 애플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.   이제 각 배우들은 담당 기능을 실행하는 책임만 지면 된다.   OrderServiceImpl은 기능을 실행하는 책임만 지면 된다.       AppConfig 리팩토링   위에서 작성한 AppConfig의 문제점은 역할과 구현이 명확히 구분되지 않는 것과 new MemoryMemberRepository()가 중복된다는 점이다.   따라서, 아래코드와 같이 리팩토링 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package hello.core;  import hello.core.discount.DiscountPolicy; import hello.core.discount.FixDiscountPolicy; import hello.core.member.MemberService; import hello.core.member.MemberServiceImpl; import hello.core.member.MemoryMemberRepository; import hello.core.order.OrderService; import hello.core.order.OrderServiceImpl;  public class AppConfig {      public MemberService memberService() {         return new MemberServiceImpl(memberRepository());     }      private MemoryMemberRepository memberRepository() {         return new MemoryMemberRepository();     }      public OrderService orderService() {         return new OrderServiceImpl(memberRepository(), discountPolicy());     }      public DiscountPolicy discountPolicy() {         return new FixDiscountPolicy();     } }   new MemoryMemberRepository() 이 부분이 중복 제거되었다. 이제 MemoryMemberRepository 를 다른 구현체로 변경할 때 한 부분만 변경하면 된다. 또한, 리팩토링된 AppConfig를 보면 역할과 구현 클래스가 한눈에 들어온다. 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.      역할: 메소드 리턴 타입   구현: 구현체       새로운 구조와 할인 정책 적용   이제 새로운 할인 정책을 도입해도 AppConfig만 변경하면 된다.   변경: FixDiscountPolicy → RateDiscountPolicy         이제 새로운 구조와 할인 정책을 적용해도 사용 영역의 코드는 변경할 필요 없이 구성 영역의 코드만 바꾸면 된다. DIP, OCP를 만족한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package hello.core;  import hello.core.discount.DiscountPolicy; import hello.core.discount.FixDiscountPolicy; import hello.core.member.MemberService; import hello.core.member.MemberServiceImpl; import hello.core.member.MemoryMemberRepository; import hello.core.order.OrderService; import hello.core.order.OrderServiceImpl;  public class AppConfig {      public MemberService memberService() {         return new MemberServiceImpl(memberRepository());     }      private MemoryMemberRepository memberRepository() {         return new MemoryMemberRepository();     }      public OrderService orderService() {         return new OrderServiceImpl(memberRepository(), discountPolicy());     }      public DiscountPolicy discountPolicy() {         // return new FixDiscountPolicy();         return new RateDiscountPolicy();     } }   AppConfig에서 할인 정책 역할을 담당하는 구현을 Fix → Rate 객체로 변경했다. 이제는 할인 정책을 변경해도 AppConfig만 변경하면 된다. 클라이언트 코드인 OrderServiceImpl를 포함해서 사용 영역의 어떤 코드도 변경할 필요가 없다.   구성 영역은 당연히 변경된다. 구성 역할을 담당하는 AppConfig를 애플리케이션이라는 공연의 기획자로 생각하자. 공연 기획자는 공연 참여자인 구현 객체들을 모두 알아야 한다.       전체 흐름 정리   지금까지의 흐름을 정리해보자.      새로운 할인 정책 개발   새로운 할인 정책 적용과 문제점   관심사의 분리   AppConfig 리팩터링   새로운 구조와 할인 정책 적용       새로운 할인 정책 개발   다형성 덕분에 새로운 정률 할인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없음       새로운 할인 정책 적용과 문제점   새로 개발한 정률 할인 정책을 적용하려고 하니 클라이언트 코드인 주문 서비스 구현체도 함께 변경해야함 주문 서비스 클라이언트가 인터페이스인 DiscountPolicy 뿐만 아니라, 구체 클래스인 FixDiscountPolicy도 함께 의존 → DIP 위반       관심사의 분리      애플리케이션을 하나의 공연으로 생각   기존에는 클라이언트가 의존하는 서버 구현 객체를 직접 생성하고, 실행함   비유를 하면 기존에는 남자 주인공 배우가 공연도 하고, 동시에 여자 주인공도 직접 초빙하는 다양한 책임을 가지고 있음   공연을 구성하고, 담당 배우를 섭외하고, 지정하는 책임을 담당하는 별도의 공연 기획자가 나올 시점   공연 기획자인 AppConfig가 등장   AppConfig는 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임   이제부터 클라이언트 객체는 자신의 역할을 실행하는 것만 집중, 권한이 줄어듬(책임이 명확해짐)   1 2 3 4 5 6 7 8 9 10 public class AppConfig {      public MemberService memberService() {         return new MemberServiceImpl(new MemoryMemberRepository());     }      public OrderService orderService() {         return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());     } }      AppConfig 리팩터링      구성 정보에서 역할과 구현을 명확하게 분리   역할이 잘 드러남   중복 제거   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AppConfig {      public MemberService memberService() {         return new MemberServiceImpl(memberRepository());     }      private MemoryMemberRepository memberRepository() {         return new MemoryMemberRepository();     }      public OrderService orderService() {         return new OrderServiceImpl(memberRepository(), discountPolicy());     }      public DiscountPolicy discountPolicy() {         return new FixDiscountPolicy();     } }       새로운 구조와 할인 정책 적용      정액 할인 정책 정률% 할인 정책으로 변경   AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(Configuration)하는 영역으로 분리   할인 정책을 변경해도 AppConfig가 있는 구성 영역만 변경하면 됨, 사용 영역은 변경할 필요가 없음. 물론 클라이언트 코드인 주문 서비스 코드도 변경하지 않음       객체지향설계 원칙 5가지 중 위의 코드들에서 적용된 원칙은 3가지이다.   1. SRP 단일 책임 원칙   SRP 원칙은 한 클래스는 하나의 책임만 가져야 한다는 것이다. 클라이언트 객체(OrderServiceImpl)는 직접 구현 객체를 생성, 연결, 실행하는 너무 많은 책임을 가지고 있었다. SRP 단일 책임 원칙을 따르면서 관심사를 분리하고 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당하였다. 즉, 클라이언트 객체는 실행하는 책임만 담당하게 되었다.   2. DIP 의존관계 역전 원칙   DIP 원칙은 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다는 것이다. 새로운 할인 정책을 개발하니 클라이언트 코드의 변경이 불가피했다. OrderServiceImpl은 DiscountPolicy(추상)를 의존하는 동시에 FixDiscountPolicy(구체)도 의존했기 때문이다. 이를 AppConfig를 생성해서 클라이언트는 구체에 의존하지 않도록 설계하고 클라이언트 코드에 의존관계를 주입했다.   3. OCP   OCP 원칙은 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다는 것이다. 다형성을 사용하고 클라이언트가 DIP를 지킨다. 또한, 애플리케이션을 사용영역과 구성영역으로 나누고 AppConfig를 통해 의존관계를 주입하므로 새로운 정책으로 변경한다고 해서 클라이언트의 코드를 변경할 필요가 없어졌다. 즉, 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있고 구성영역만 수정하면 된다.  ","categories": ["Spring"],
        "tags": ["Spring","Java"],
        "url": "/spring/Spring-DIP-OCP-DI/",
        "teaser": ""
      },{
        "title": "IoC(제어의 역전)와 DI(의존관계 주입)",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   제어의 역전(IoC, Inversion of Control)   AppConfig를 사용하기 전에는 클라이언트 구현 객체가 서버 구현 객체를 생성, 연결, 실행했다. 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.   반면에, AppConfig 등장 이후 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램의 제어 흐름은 AppConfig가 가져갔다. 예를 들어, OrderServiceImpl은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다.   이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.   프레임워크 vs 라이브러리      프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다.            예) JUnit           반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.            예) 자바 객체를 xml, json으로 바꿀때는 라이브러리를 import하여 직접 호출           의존관계 주입(DI, Dependency Injection)   아래 예제를 살펴보면 OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다. OrderServiceImpl 입장에서 보면 DiscountPolicy에 어떤 구현 객체가 사용될지 모른다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package hello.core.order;  import hello.core.discount.DiscountPolicy; import hello.core.member.Member; import hello.core.member.MemberRepository;  public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository;     private final DiscountPolicy discountPolicy;      public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {         this.memberRepository = memberRepository;         this.discountPolicy = discountPolicy;     }      ... }   의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.   정적인 클래스 의존관계   정적인 클래스 의존관계는 클래스가 사용하는 import를 보고 의존관계를 쉽게 판단할 수 있다. 따라서, 애플리케이션을 실행하지 않아도 코드만 보고 분석할 수 있다. OrderServiceImpl은 MemberRepository, DiscountPolicy에 의존한다는 것을 파악할 수 있지만 실제 어떤 객체가 OrderServiceImpl에 주입 될지 알 수 없다.      동적인 객체(인스턴스) 의존 관계   정적인 클래스 의존관계와 다르게 동적인 객체 의존관계는 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다. 애플리케이션 실행 시점(런타임)에 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다. 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다. 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 호출하는 대상의 타입 인스턴스를 변경할 수 있다. 정리하자면, 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다. 이 부분은 의존관계 주입의 장점이다.   DI 컨테이너   AppConfig처럼 객체를 생성, 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 하는데 최근에는 의존관계 주입에 초점을 맞추어 주로 DI 컨테이너라 한다.   스프링 컨테이너   현재까진 순수한 자바코드로 DI를 적용했다. 이제 스프링을 사용해보자.      @Configuration: 설정정보에 붙이게 되있음   @Bean을 붙이면 스프링 컨테이너라는 곳에 등록됨   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration public class AppConfig {      @Bean     public MemberService memberService() {         return new MemberServiceImpl(memberRepository());     }      @Bean     public MemoryMemberRepository memberRepository() {         return new MemoryMemberRepository();     }      @Bean     public OrderService orderService() {         return new OrderServiceImpl(memberRepository(), discountPolicy());     }      @Bean     public DiscountPolicy discountPolicy() {         return new FixDiscountPolicy();     } }   스프링 컨테이너 테스트 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MemberApp {      public static void main(String[] args) {         ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);         MemberService memberService = applicationContext.getBean(\"memberService\", MemberService.class);          Member member = new Member(1L, \"memberA\", Grade.VIP);         memberService.join(member);          Member findMember = memberService.findMember(1L);         System.out.println(\"new Member: \" + member.getName());         System.out.println(\"find Member: \" + findMember.getName());     } }   기존에는 AppConfig를 사용해서 DI를 했지만, 이제부턴 스프링 컨테이너를 통해서 DI를 사용한다.   ApplicationContext을 스프링 컨테이너라 한다. 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성) 정보로 사용하며 @Bean을 붙인 메서드는 모두 스프링 컨테이너에 등록된다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다. 스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다. (memberService, orderService)   이전에는 개발자가 필요한 객체를 AppConfig를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾을 수 있다. 기존에는 개발자가 직접 객체를 생성하고 DI를 했지만 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.   내용 요약      할인 정책 개발: 인터페이스와 구현체 분리, 다형성 활용하여 코드 작성함   새로운 할인 정책 개발: 인터페이스와 구현체를 분리한 덕에 코드 작성에는 문제가 없었음. 다만, 새로운 정책을 적용할 경우 구체클래스가 변경됨 → OCP, DIP 위반!   AppConfig를 작성하여 역할과 책임을 분리. AppConfig가 어떤 객체를 주입할지 결정함.   이제 구현객체는 자신의 로직을 실행하는 역할만 함. 어떤 객체가 주입될지 모름. 이를 제어의 역전(IoC)라 함. (제어의 역전: 프로그램의 제어 흐름을 외부에서 관리하는 것)   의존관계는 정적인 의존관계(import 보고 알수 있는), 동적인 의존관계(애플리케이션 실행 시점에 객체 인스턴스의 참조가 연결)가 있는데 동적인 의존관계를 의존관계 주입이라 함.   그리고 AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너(DI 컨테이너)라 함. (여기까지 순수한 자바 코드로 DI를 적용함.)   스프링으로 전환, AppConfig에 @Configuration, 메서드에 @Bean을 붙임. 이렇게 하면 스프링 컨테이너에 스프링 빈으로 등록됨.   스프링 컨테이너(ApplicationContext)를 사용하면 기존에 개발자가 직접 객체 생성하고 DI를 했지만 이젠 스프링컨테이너에 객체를 스프링 빈으로 등록, 스프링 컨테이너에서 스프링 빈을 찾아서 사용.  ","categories": ["Spring"],
        "tags": ["Spring","Java"],
        "url": "/spring/Spring-IoC-DI/",
        "teaser": ""
      },{
        "title": "싱글톤 컨테이너",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   싱글톤 패턴   싱글톤 패턴 등장배경   웹 애플리케이션은 사용자의 요청이 많으며 동시에 요청을 한다. 만약, 스프링 없는 순수한 DI 컨테이너를 사용하면 클라이언트가 요청을 할 때마다 객체가 생성된다. 따라서, 메모리 낭비가 매우 심하다.   순수한 DI 컨테이너 테스트   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test @DisplayName(\"스프링 없는 순수한 DI 컨테이너\") void pureContainer(){     AppConfig appConfig = new AppConfig();      MemberService memberService1 = appConfig.memberService();     MemberService memberService2 = appConfig.memberService();      // 참조값이 다른 것을 확인     System.out.println(\"memberService1 = \" + memberService1);     System.out.println(\"memberService2 = \" + memberService2);      // memberService1 != memberService2     assertThat(memberService1).isNotSameAs(memberService2); }   1 2 memberService1 = com.study.core.member.MemberServiceImpl@13b6aecc memberService2 = com.study.core.member.MemberServiceImpl@158a8276   이를 해결하기 위해서 해당 객체를 하나만 생성한 후 공유하도록 설계해야 하는데 이러한 패턴을 싱글톤 패턴이라 한다.   싱글톤 패턴이란?   싱글톤 패턴이란 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴으로 싱글톤 패턴이 적용되면 객체 인스턴스를 2개 이상 생성하지 못하도록 막는다. (private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막는다.)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package hello.core.singleton;  public class SingletonService {  \t\t// #1     private static final SingletonService instance = new SingletonService();  \t\t// #2     public static SingletonService getInstance() {         return instance;     }      // #3     private SingletonService() {     }      public void logic() {         System.out.println(\"싱글톤 객체 로직 호출\");     } }      static 영역에 객체 instance를 딱 1개만 생성해둔다. static으로 되있으면 클래스가 메모리에 로드될 때 단 한번만 수행하고 static 영역에 하나만 올라간다.   public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다. 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.   private 생성자를 통해 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.   싱글톤 패턴을 사용한 테스트 코드   1 2 3 4 5 6 7 8 9 10 11 @Test @DisplayName(\"싱글톤 패턴을 적용한 객체 사용\") void singletonServiceTest() {     SingletonService singletonService1 = SingletonService.getInstance();     SingletonService singletonService2 = SingletonService.getInstance();      System.out.println(\"singletonService1 = \" + singletonService1);     System.out.println(\"singletonService2 = \" + singletonService2);      Assertions.assertThat(singletonService1).isSameAs(singletonService2); }   1 2 singletonService1 = com.study.core.singleton.SingletonService@66d18979 singletonService2 = com.study.core.singleton.SingletonService@66d18979   private로 new 키워드를 막아두었기 때문에 getInstance() 메서드 사용했다. 호출할 때 마다 같은 객체 인스턴스를 반환하는 것을 확인할 수 있다.   싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 싱글톤 패턴은 다음과 같은 수 많은 문제점들을 가지고 있다.   싱글톤 패턴 문제점      싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.   의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.   클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.   테스트하기 어렵다.   내부 속성을 변경하거나 초기화 하기 어렵다.   private 생성자로 자식 클래스를 만들기 어렵다.   결론적으로 유연성이 떨어진다.   안티패턴으로 불리기도 한다.      참고   여기서 DIP 원칙을 위반했다고 한 것이 싱글톤 패턴이 무조건 DIP 원칙을 위반한다는 것은 아니다.     이러한 문제점들을 해결하기 위해 싱글톤 컨테이너를 사용한다.   싱글톤 컨테이너   싱글톤 컨테이너란?   스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리한다. 즉, 객체를 하나만 생성해서 관리한다. 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.   스프링 컨테이너는 위에서 설명했던 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다는 점과 DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다는 점 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test @DisplayName(\"스프링 컨테이너와 싱글톤\") void springContainer() {     ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);     MemberService memberService1 = ac.getBean(\"memberService\", MemberService.class);     MemberService memberService2 = ac.getBean(\"memberService\", MemberService.class);      // 참조값이 같은 것을 확인     System.out.println(\"memberService1 = \" + memberService1);     System.out.println(\"memberService2 = \" + memberService2);      // memberService1 == memberService2     assertThat(memberService1).isSameAs(memberService2); }   1 2 memberService1 = com.study.core.member.MemberServiceImpl@c2db68f memberService2 = com.study.core.member.MemberServiceImpl@c2db68f   스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.      참고   스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. 자세한 내용은 뒤에 빈 스코프에서 설명하겠다.     싱글톤 방식의 주의점   객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안되고 무상태(stateless)로 설계해야 한다. 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있기 때문이다.   무상태(stateless)      특정 클라이언트에 의존적인 필드가 있으면 안된다.   특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.   가급적 읽기만 가능해야 한다.   필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.   CGLIB 바이트코드 조작   @Configuration과 싱글톤   아래 코드는 AppConfig 설정파일로 @Configuration과 @Bean이 있기 때문에 싱글톤이 적용되어있다. 그런데 호출되는 의존관계를 보면 싱글톤이 깨지는 것처럼 보인다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Configuration public class AppConfig {      // memberService -&gt; MemoryMemberRepository     // orderService -&gt; MemoryMemberRepository      @Bean     public MemberService memberService() {         return new MemberServiceImpl(memberRepository());     }      @Bean     public MemoryMemberRepository memberRepository() {         return new MemoryMemberRepository();     }      @Bean     public OrderService orderService() {         return new OrderServiceImpl(memberRepository(), discountPolicy());     }      @Bean     public DiscountPolicy discountPolicy() {         return new FixDiscountPolicy();     } }   memberService(), orderService() 둘 다 MemoryMemberRepository()가 생성되면서 싱글톤이 깨지는 것처럼 보인다. 그러나, 테스트를 해보면 모두 같은 객체를 호출하고 있다. 이처럼 싱글톤을 보장할 수 있는 이유는  @Configuration을 통해 바이트코드 조작 라이브러리를 사용하기 때문이다.   @Configuration과 바이트코드 조작   스프링 컨테이너는 싱글톤 레지스트리다. 따라서, 스프링 빈이 싱글톤이 되도록 보장해주어야 하는데 스프링이 자바 코드까지 조작하긴 어렵다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.   AppConfig 클래스 정보를 출력하는 테스트코드   1 2 3 4 5 6 7 @Test void configurationDeep() {     ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);     AppConfig bean = ac.getBean(AppConfig.class);      System.out.println(\"bean = \" + bean.getClass()); }   1 bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$4730a6f2   순수한 클래스라면 class hello.core.AppConfig가 출력되어야 하지만, 예상과는 다르게 클래스 명에 xxxCGLIB가 붙는다. 이것은 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록했기 때문이다. (AppConfig를 상속받은 AppConfig@CGLIB)   그 임의의 다른 클래스가 바로 싱글톤이 보장되도록 해준다. 아마도 다음과 같이 바이트 코드를 조작해서 작성되어 있을 것이다.   AppConfig@CGLIB 예상 코드   1 2 3 4 5 6 7 8 9 10 @Bean public MemberRepository memberRepository() {       if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면?) {         return 스프링 컨테이너에서 찾아서 반환;     } else { //스프링 컨테이너에 없으면         기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록         return 반환;     } }   @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. 덕분에 싱글톤이 보장된다.   @Configuration을 적용하지 않고 @Bean만 적용하면 어떻게 될까?   @Configuration을 붙이면 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장하지만 만약, @Bean만 적용하면 어떻게 될까?   1 2 3 4 //@Configuration 삭제 public class AppConfig {  }   1 bean = class hello.core.AppConfig   이 출력 결과를 통해서 AppConfig가 CGLIB 기술 없이 순수한 AppConfig로 스프링 빈에 등록된 것을 확인할 수 있다. 즉, @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다. 스프링 설정 정보는 항상 @Configuration을 사용하자.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-Singleton/",
        "teaser": ""
      },{
        "title": "컴포넌트 스캔",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   컴포넌트 스캔과 의존관계 자동 주입   스프링은 자바 코드의 @Bean이나 XML의 &lt;bean&gt; 같은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공하며, 의존관계를 자동으로 주입하는 @Autowired 기능을 제공한다.   컴포넌트 스캔   1 2 3 4 5 @ComponentScan(         excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class)) public class AutoAppConfig {     // 기존과 다르게 비어있음 }   컴포넌트 스캔을 사용하려면 먼저 @ComponentScan을 설정 정보에 붙여주면 된다. 컴포넌트 스캔은 이름 그대로 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.   이제 구체 클래스들(MemoryMemberRespository, RateDiscountPolicy, MemberServiceImpl, OrderServiceImpl)이 컴포넌트 스캔의 대상이 되도록 @Component 애노테이션을 입력한다.      참고   excludeFilters를 사용한 이유는 기존의 설정 정보인 AppConfig를 컴포넌트 스캔 대상에서 제외해야 하기 때문이다. AppConfig에는 @Configuration가 붙어있는데, 이러면 설정 정보도 자동으로 컴포넌트 스캔의 대상이 되므로 충돌이 발생한다.        참고   excludeFilters를 사용하면 @Configuration이 붙은 클래스를 제외한다고 했는데 AutoAppConfig도 @Configuration 붙어있다. 하지만 제외대상이 아니다. 그 이유는 @ComponentScan이 붙어 있기 때문이다.        참고   @Configuration이 컴포넌트 스캔의 대상이 된 이유도 @Configuration 소스코드를 열어보면 @Component 애노테이션이 붙어있기 때문이다.     의존관계 자동 주입   AppConfig에서는 @Bean으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다. 이제는 이런 설정 정보 자체가 없기 때문에, 의존관계 주입도 각 클래스 안에서 해결해야 한다.   @Autowired는 의존관계를 자동으로 주입해준다. 생성자에 @Autowired를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다. 또한, @Autowired를 사용하면 생성자에서 여러 의존관계도 한번에 주입 받을 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 @Component public class MemberServiceImpl implements MemberService {      private final MemberRepository memberRepository;  \t\t// getBean(MemberRepository.class)와 동일     @Autowired     public MemberServiceImpl(MemberRepository memberRepository) {         this.memberRepository = memberRepository;     } \t\t... }   1 2 3 4 5 6 7 8 9 10 11 12 13 @Component public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository;     private final DiscountPolicy discountPolicy;      @Autowired     public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {         this.memberRepository = memberRepository;         this.discountPolicy = discountPolicy;     }     ... }   테스트 코드를 통해 정상적으로 스프링 빈에 등록되었는지와 의존관계 주입이 되었는지를 확인할 수 있다.   1 2 3 4 5 6 @Test void basicScan() {     ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class);     MemberService memberService = ac.getBean(MemberService.class);     assertThat(memberService).isInstanceOf(MemberService.class); }   컴포넌트 스캔, 자동 의존관계 주입의 동작 흐름   @ComponentScan      @ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.   스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다. (MemberServiceImpl 클래스 → memberServiceImpl)   만약 스프링 빈의 이름을 직접 지정하고 싶으면 @Component(”빈 이름”) 로 이름을 부여하면 된다.   @Autowired 의존관계 자동 주입      생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.        이때, 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다. 예를 들어, MemberServiceImpl 생성자에 @Autowired가 붙어있으면 스프링 컨테이너에 있는 memberRepository와 같은 타입이 있는지 찾는다.       1 2 3 4 5 6 7 8 9 10   @Component   public class MemberServiceImpl implements MemberService {            private final MemberRepository memberRepository;            @Autowired       public MemberServiceImpl(MemberRepository memberRepository) {           this.memberRepository = memberRepository;       }   }           탐색 위치와 기본 스캔 대상   탐색할 패키지의 시작 위치 지정   컴포넌트 스캔의 시작 위치를 지정하여 탐색하도록 할 수 있다. 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.           basePackages: 탐색할 패키지의 시작위치 지정, 해당 패키지를 포함한 하위 패키지 모두 탐색       1 2 3 4 5 6 7 8   @ComponentScan(       basePackages = \"hello.core.member\",   )        // 시작 위치를 여러개 지정할 수도 있음   @ComponentScan(       basePackages = {\"hello.core\", \"hello.service\"}   )                basePackageClasses: 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.       권장하는 방법   패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것을 권장한다. 프로젝트 메인 설정 정보는 프로젝트를 대표하는 정보이기 때문에 시작 루트 위치에 두는 것이 좋다.   예시) com.hello, com.hello.service, com.hello.repository 와 같은 프로젝트 구조를 가지고 있다면, com.hello (시작 루트)에 메인 설정 정보를 두고 basePackages는 생략한다.   참고로, 스프링 부트의 경우에도 대표 시작 정보인 @SpringBootApplication을 프로젝트 시작 루트 위치에 두는 것이 관례이다. (또한, @SpringBootApplication 안에 @ComponentScan이 들어있다.)   컴포넌트 스캔 기본 대상   컴포넌트 스캔의 대상은 다음과 같다.      @Component: 컴포넌트 스캔에서 사용   @Controller: 스프링 MVC 컨트롤러에서 사용 및 인식   @Service: 스프링 비즈니스 로직에서 사용, 개발자들이 비즈니스 계층을 인식하는데 도움이 됨 (비즈니스 계층을 인식하는데 도움을 줄 뿐, 특별한 처리를 하지 않는다.)   @Repository: 스프링 데이터 접근 계층에서 사용 및 인식하고 데이터 계층의 예외를 스프링 예외로 변환해줌   @Configuration: 스프링 설정 정보에서 사용 및 인식, 스프링 빈이 싱글톤을 유지하도록 추가 처리함   해당 클래스들의 소스코드를 보면 @Component를 포함하고 있다.   1 2 3 4 5 6 7 8 9 10 11 @Component public @interface Controller { }  @Component public @interface Service { }  @Component public @interface Configuration { }      참고   사실 애노테이션에는 상속관계라는 것이 없다. 그래서 이렇게 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다.        참고   useDefaultFilters 옵션은 기본으로 켜져있는데, 이 옵션을 끄면 기본 스캔 대상들이 제외된다. (그냥 이런 옵션이 있구나 정도 알고 넘어가자.)     필터   includeFilters   컴포넌트 스캔 대상을 추가로 지정   excludeFilters   컴포넌트 스캔에서 제회할 대상을 지정   FilterType 옵션      ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.   ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.   ASPECTJ: AspectJ 패턴 사용   REGEX: 정규 표현식   CUSTOM: TypeFilter이라는 인터페이스를 구현해서 처리      참고   @Component면 충분하기 때문에, includeFilters 를 사용할 일은 거의 없다. excludeFilters는 여러가지 이유로 간혹 사용할 때가 있지만 많지는 않다. 특히 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기보다는 스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장하고, 선호하는 편이다.     중복 등록과 충돌   컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까?           자동 빈 등록 vs 자동 빈 등록       → ConflictingBeanDefinitionException 예외 발생            수동 빈 등록 vs 자동 빈 등록       → 수동 빈이 우선권을 가짐       그러나, 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 변경되었다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-ComponentScan/",
        "teaser": ""
      },{
        "title": "Java, 테스트 코드 작성 - JUnit 5",
        "excerpt":"1. JUnit 5 소개   1.1 JUnit 5란?      자바 개발자가 가장 많이 사용하는 테스팅 프레임워크            단위 테스트를 작성하는 자바 개발자 93%가 JUnit을 사용           자바 8 이상을 필요로 함       1.2 Junit 5의 세부 모듈 3가지      JUnit Platform: 테스트 코드를 실행해주는 런처를 제공. TestEngine API 제공   Jupiter: TestEngine API 구현체로 JUnit 5를 제공   Vintage: JUnit 4와 3을 지원하는 TestEngine 구현체       2. JUnit 5: 시작하기   2.2+ 버전의 스프링 부트 프로젝트는 기본으로 JUnit 5 의존성 추가되어 따로 설정할게 없다.   maven dependency   1 2 3 4 5 6 &lt;dependency&gt;     &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;     &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;     &lt;version&gt;5.5.2&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;          참고 Junit 5부터는 public을 안붙여도 된다. (리플렉션을 사용하기 때문에 public 을 굳이 붙일 필요가 없어짐)         2.1 기본 어노테이션   어노테이션을 사용하는 메소드를 구현할 때는 반드시 static을 붙여야 한다. default 는 되고 private 은 안된다. 그리고 리턴타입이 있으면 안됨.   → 기본적으로 static void 써야한다고 생각하자       2.1.1 @Test   테스트 메서드임을 나타내는 어노테이션   2.1.2 @BeforeAll / @AfterAll   beforeAll 어노테이션: 테스트 클래스 안에 있는 모든 테스트가 실행되기 전 딱 한번 호출 됨   afterAll 어노테이션: 테스트 클래스 안에 있는 모든 테스트가 실행된 후 딱 한번 호출 됨   2.1.3 @BeforeEach / @AfterEach   beforeEach 어노테이션: 각각의 테스트 메서드가 실행되기 전 호출 됨   afterEach 어노테이션: 각각의 테스트 메서드가 실행된 후 호출 됨   2.1.4 @Disabled   테스트 어노테이션이 있어도 Disabled 어노테이션이 붙어있다면 테스트코드가 실행되지 않음       테스트 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package me.yes.thejavatest;  import org.junit.jupiter.api.*;  import static org.junit.jupiter.api.Assertions.*;  class StudyTest {      @Test     void create() {         Study study = new Study();         assertNotNull(study);         System.out.println(\"create\");     }      @Test     void create1() {         System.out.println(\"create1\");     }      @BeforeAll     static void beforeAll() {         System.out.println(\"before all\");     }      @AfterAll     static void afterAll() {         System.out.println(\"after all\");     }      @BeforeEach     void beforeEach() {         System.out.println(\"before each\");     }      @AfterEach     void afterEach() {         System.out.println(\"after each\");     }      @Test     @Disabled     void create2() {         System.out.println(\"create2\");     }  }       3. JUnit 5: 테스트 이름 표기하기      @DisplayNameGeneration   @DisplayName       테스트 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package me.yes.thejavatest;  import org.junit.jupiter.api.*;  import static org.junit.jupiter.api.Assertions.*;  @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class) class StudyTest {      @Test     @DisplayName(\"스터디 만들기\")     void create() {         Study study = new Study();         assertNotNull(study);         System.out.println(\"create\");     } }       4. JUnit 5: Assertion   org.junit.jupiter.api.Assertions.* 를 사용       4.1 자주 사용하는 Assert문   4.1.1 assertEquals(expected, actual)      실제 값이 기대한 값과 같은지 확인   기대하는 값을 왼쪽에 실제 나오는 값을 오른쪽에 적어줌 (필수는 아니지만 api가 의도하는 바는 그렇다)       람다식으로 표현하는 이유      테스트가 실패 했을 때만 연산 (람다식을 사용하지 않은 코드는 테스트를 실패하던 성공하던 무조건 실행)   문자열 연산의 비용이 조금 걱정이 될 때는 람다식을 쓰는게 유리 (성능을 신경쓰는 입장에서)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 assertEquals(StudyStatus.DRAFT, study.getStatus(), \"스터디를 처음 만들면 상태값이 DRAFT여야 한다.\"); assertEquals(StudyStatus.DRAFT, study.getStatus(), () -&gt; \"스터디를 처음 만들면 상태값이 DRAFT여야 한다.\");  assertEquals(StudyStatus.DRAFT, study.getStatus(),          \"스터디를 처음 만들면 상태값이 \" + StudyStatus.DRAFT + \"여야 한다.\"); assertEquals(StudyStatus.DRAFT, study.getStatus(),         () -&gt; \"스터디를 처음 만들면 상태값이 \" + StudyStatus.DRAFT + \"여야 한다.\");  assertEquals(StudyStatus.DRAFT, study.getStatus(), new Supplier&lt;String&gt;() {     @Override     public String get() {         return \"스터디를 처음 만들면 \" + StudyStatus.DRAFT + \" 상태다.\";     } });       4.1.2 assertNotNull(actual)   값이 null이 아닌지 확인       4.1.3 assertTrue(boolean)   다음 조건이 참(true)인지 확인       4.1.4 assertAll(executablesl…)   모든 확인 구문 확인   테스트는 순차적으로 실행되기 때문에 위에서 테스트가 깨지면 그 다음 assert문으로 넘어가지 않지만 이를 동시에 알 수 있는 방법이 있다.   각각 assert문을 실행 할 수도 있지만 모든 assert문의 결과를 한번에 알고 싶을 때 assertAll을 사용해서 람다식으로 표현하면 assert문을 한번에 실행 할 수 있다.   1 2 3 4 5 assertAll(         () -&gt; assertNotNull(study),         () -&gt; assertEquals(StudyStatus.DRAFT, study.getStatus(), () -&gt; \"스터디를 처음 만들면 상태값이 DRAFT여야 한다.\"),         () -&gt; assertTrue(study.getLimit() &gt; 0, \"스터디 최대 참석 가능 인원은 0보다 커야 한다.\") );       4.1.5 assertThrows(expectedType, executable)   예외 발생 확인   1 2 3 IllegalArgumentException exception =         assertThrows(IllegalArgumentException.class, () -&gt; new Study(-10)); assertEquals(\"limit은 0보다 커야 한다.\", exception.getMessage());       4.1.6 assertTimeout(duration, executable)   특정 시간 안에 실행이 완료되는지 확인   위의 코드는 테스트가 끝날때까지 테스트가 끝나지 않는다. 즉, 실제 테스트에 오래걸리는 코드가 있다면 그 코드가 끝날때까지 끝나지 않는다. 그러나, 이렇게 하는 것은 비효율적이다. 실제 100밀리세컨드가 끝나면 그냥 테스트가 실패하게 만들고 싶다.(이게 효율적이니까)   그럴때 사용하는 것이 assertTimeoutPreemptively() 이다. (Preemptively: 즉각적인)   그러나, assertTimeoutPreemptively()는 주의해서 사용해야한다. ThreadLocal과 관련해 예상하지 못한 예외가 발생할 수 있다.   1 2 3 4 5 6 7 8 9 assertTimeout(Duration.ofMillis(100), () -&gt; {     new Study(10);     Thread.sleep(300); });  assertTimeoutPreemptively(Duration.ofMillis(100), () -&gt; {     new Study(10);     Thread.sleep(300); });          ThreadLocal이란?         4.2 org.assertj.core.api.Assertions.assertThat   1 2 Study actual = new Study(10); assertThat(actual.getLimit()).isGreaterThan(0);   이렇게 테스트 하는 방법도 있다.       5. JUnit 5: 조건에 따라 테스트 실행하기   특정한 조건을 만족하는 경우에 테스트를 실행하는 방법       org.junit.jupiter.api.Assumptions      assumeTrue(조건)   assumingThat(조건, 테스트)   @Enabled 와 @Disabled      OnOS   OnJre   IfEnvironmentVariable   If       테스트 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package me.yes.thejavatest;  import org.junit.jupiter.api.*; import org.junit.jupiter.api.condition.*;  import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assumptions.assumeTrue; import static org.junit.jupiter.api.Assumptions.assumingThat;  class StudyTest {      @Test     @DisplayName(\"스터디 만들기\")     @EnabledOnOs({OS.MAC, OS.LINUX})     @EnabledOnJre({JRE.JAVA_8, JRE.JAVA_9, JRE.JAVA_10, JRE.JAVA_11})     @EnabledIfEnvironmentVariable(named = \"TEST_ENV\", matches = \"LOCAL\")     void create() {         String test_env = System.getenv(\"TEST_ENV\");          assumeTrue(\"LOCAL\".equalsIgnoreCase(test_env));          assumingThat(\"LOCAL\".equalsIgnoreCase(test_env), () -&gt; {             Study actual = new Study(10);             assertThat(actual.getLimit()).isGreaterThan(0);         });      } }       6. JUnit 5: 태깅과 필터링   테스트 그룹을 만들고 원하는 테스트 그룹만 테스트를 실행할 수 있는 기능          1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test @DisplayName(\"스터디 만들기 fast\") @Tag(\"fast\") void create_new_study() {      Study actual = new Study(10);     assertThat(actual.getLimit()).isGreaterThan(0); }  @Test @DisplayName(\"스터디 만들기 slow\") @Tag(\"slow\") void create_new_study_again() {     System.out.println(\"create1\"); }       메이븐에서 테스트 필터링 하는 방법   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31     &lt;profiles&gt;         &lt;profile&gt;             &lt;id&gt;default&lt;/id&gt;             &lt;activation&gt;                 &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;             &lt;/activation&gt;             &lt;build&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                         &lt;configuration&gt;                             &lt;groups&gt;fast&lt;/groups&gt;                         &lt;/configuration&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;         &lt;profile&gt;             &lt;id&gt;ci&lt;/id&gt;             &lt;build&gt;                 &lt;plugins&gt;                     &lt;plugin&gt;                         &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                         &lt;configuration&gt;                             &lt;groups&gt;fast | slow&lt;/groups&gt;                         &lt;/configuration&gt;                     &lt;/plugin&gt;                 &lt;/plugins&gt;             &lt;/build&gt;         &lt;/profile&gt;     &lt;/profiles&gt;       7. JUnit 5: 커스텀 태그   JUnit 5 애노테이션을 조합하여 커스텀 태그를 만들 수 있다.   FastTest.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package me.yes.thejavatest;  import org.junit.jupiter.api.Tag; import org.junit.jupiter.api.Test;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Test @Tag(\"fast\") public @interface FastTest { }   위에서 생성한 FastTest 어노테이션은 아래와 같이 쓸 수 있다.   1 2 3 4 5 6 @FastTest @DisplayName(\"스터디 만들기 fast\") void create_new_study() {     Study actual = new Study(10);     assertThat(actual.getLimit()).isGreaterThan(0); }       8. JUnit 5: 테스트 반복하기   @RepeatedTest      반복 횟수와 반복 테스트 이름을 설정할 수 있다.            {displayName}       {currentRepetition}       {totalRepetitions}           RepetitionInfo 타입의 인자를 받을 수 있다.   1 2 3 4 5 @DisplayName(\"스터디 만들기\") @RepeatedTest(value = 10, name = \"{displayName}, {currentRepetition}/{totalRepetitions}\") void repeatTest(RepetitionInfo repetitionInfo) {     System.out.println(\"test\" + repetitionInfo.getCurrentRepetition() + \"/\" + repetitionInfo.getTotalRepetitions()); }       @ParameterizedTest      테스트에 여러 다른 매개변수를 대입해가며 반복 실행한다.            {displayName}       {index}       {arguments}       {0}, {1}, …           1 2 3 4 5 6 @DisplayName(\"스터디 만들기\") @ParameterizedTest(name = \"{index} {displayName} message={0}\") @ValueSource(strings = {\"날씨가\", \"많이\", \"추워지고\", \"있네요.\"}) void parameterizedTest(String message) {     System.out.println(message); }       1 2 3 4 5 6 7 @DisplayName(\"스터디 만들기\") @ParameterizedTest(name = \"{index} {displayName} message={0}\") @ValueSource(strings = {\"날씨가\", \"많이\", \"추워지고\", \"있네요.\"}) @NullAndEmptySource void parameterizedTest(String message) {     System.out.println(message); }       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @DisplayName(\"스터디 만들기\") @ParameterizedTest(name = \"{index} {displayName} message={0}\") @ValueSource(ints = {10, 20, 40}) void parameterizedTest(@ConvertWith(StudyConverter.class) Study study) {     System.out.println(study.getLimit()); }  static class StudyConverter extends SimpleArgumentConverter {      @Override     protected Object convert(Object o, Class&lt;?&gt; aClass) throws ArgumentConversionException {         assertEquals(Study.class, aClass, \"Can only be convert to Study\");         return new Study(Integer.parseInt(o.toString()));     } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @DisplayName(\"스터디 만들기\") @ParameterizedTest(name = \"{index} {displayName} message={0}\") @CsvSource({\"10, '자바 스터디'\", \"20, 스프링\"}) void parameterizedTest(@ConvertWith(StudyConverter.class) Study study) {     System.out.println(study.getLimit()); }  static class StudyConverter extends SimpleArgumentConverter {      @Override     protected Object convert(Object o, Class&lt;?&gt; aClass) throws ArgumentConversionException {         assertEquals(Study.class, aClass, \"Can only be convert to Study\");         return new Study(Integer.parseInt(o.toString()));     } }       10. JUnit 5: 테스트 인스턴스   JUnit의 기본 전략은 테스트 메소드 마다 테스트 인스턴스를 새로 만든다.   → 테스트간의 의존성을 낮추기 위해..!      이것이 기본 전략   테스트 메소드를 독립적으로 실행하여 예상치 못한 오류를 방지하기 위함   이 전략을 JUnit 5에서 변경할 수 있다.   예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class StudyTest {     int value = 1;      @FastTest     @DisplayName(\"스터디 만들기 fast\")     void create_new_study() {         System.out.println(this);         System.out.println(value++);         Study actual = new Study(1);         assertThat(actual.getLimit()).isGreaterThan(0);     }      @SlowTest     @DisplayName(\"스터디 만들기 slow\")     void create_new_study_again() {         System.out.println(this);         System.out.println(\"create1 \" + value++);     } }   결과   1 2 3 4 5 6 7 // 테스트마다 객체가 다름을 아래의 해쉬값을 통해 알 수 있다  me.yes.thejavatest.StudyTest@17f7cd29 1  me.yes.thejavatest.StudyTest@581ac8a8 create1 1       아래의 어노테이션을 사용하면 테스트 클래스 당 인스턴스를 하나만 만들어 공유 할 수도 있다.       @TestInstance(Lifecycle.PER_CLASS)      테스트 클래스 당 인스턴스를 하나만 만들어 사용한다.   경우에 따라, 테스트 간에 공유하는 모든 상태를 @BeforeEach 또는 @AfterEach에서 초기화 할 필요가 있다.   @TestInstance 어노테이션을 사용하면 @BeforeAll과 @AfterAll을 static 으로 정의할 필요가 없다. 인스턴스 메소드 또는 인터페이스에 정의한 default 메소드로 정의할 수 있다.       11. JUnit5: 테스트 순서   실행할 테스트 메소드 특정한 순서에 의해 실행되지만 어떻게 그 순서를 정하는지는 의도적으로 분명하지 않는다. (테스트 인스턴스를 테스트마다 새로 만드는 것과 같은 이유)       단위 테스트는 순서에 의존하면 안되고 테스트간의 독립성이 있어야 한다.       하지만, 경우에 따라 특정 순서대로 테스트를 실행하고 싶을 때도 있다. 그 경우에는 테스트 메소드를 원하는 순서에 따라 실행하도록 @TestInstance(Lifecycle.PER_CLASS)와 함께 @TestMethodOrder를 사용할 수 있다.      MethodOrderer 구현체를 설정   기본 구현체            Alphanumeric       OrderAnnotation       Random                  참고) 반드시 TestInstance 와 같이 써야하는 것은 아니다.         1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @TestInstance(TestInstance.Lifecycle.PER_CLASS) @TestMethodOrder(MethodOrderer.OrderAnnotation.class) class StudyTest {     int value = 1;      @Order(2)     @FastTest     @DisplayName(\"스터디 만들기 fast\")     void create_new_study() {         System.out.println(this);         System.out.println(value++);         Study actual = new Study(1);         assertThat(actual.getLimit()).isGreaterThan(0);     }      @Order(1)     @SlowTest     @DisplayName(\"스터디 만들기 slow\")     void create_new_study_again() {         System.out.println(this);         System.out.println(\"create1 \" + value++);     }      @BeforeAll     void beforeAll() {         System.out.println(\"before all\");     }      @AfterAll     void afterAll() {         System.out.println(\"after all\");     } }   12. JUnit 5: junit-platform.properties   JUnit 설정파일로 클래스패스 루트(src/test/resources/)에 넣어두면 적용된다.   junit-platform.properties   1 2 3 4 5 6 7 8 9 10 11 # 테스트 인스턴스 라이프사이클 설정 junit.jupiter.testinstance.lifecycle.default = per_class  # 확장팩 자동 감지 기능 junit.jupiter.extensions.autodetection.enabled = true  # @Disabled 무시하고 실행하기 junit.jupiter.conditions.deactivate = org.junit.*DisabledCondition  # 테스트 이름 표기 전략 설정 junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores       13. JUnit 5: 확장 모델   JUnit 4의 확장 모델은 @RunWith(Runner), TestRule, MethodRule   JUnit 5의 확장 모델은 Extension       아래 코드는 테스트의 실행시간이 오래 걸릴 경우 SlowTest 어노테이션을 붙이라는 메시지를 알려주는 확장팩? 이다   FindSlowTestExtension.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package me.yes.thejavatest;  import org.junit.jupiter.api.extension.AfterTestExecutionCallback; import org.junit.jupiter.api.extension.BeforeTestExecutionCallback; import org.junit.jupiter.api.extension.ExtensionContext;  import java.lang.reflect.Method;  public class FindSlowTestExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {      private static final long THRESHOLD = 1000L;      @Override     public void beforeTestExecution(ExtensionContext context) throws Exception {         ExtensionContext.Store store = getStore(context);         store.put(\"START_TIME\", System.currentTimeMillis());     }      @Override     public void afterTestExecution(ExtensionContext context) throws Exception {         Method requiredTestMethod = context.getRequiredTestMethod();         SlowTest annotation = requiredTestMethod.getAnnotation(SlowTest.class);          String testMethodName = context.getRequiredTestMethod().getName();         ExtensionContext.Store store = getStore(context);         long start_time = store.remove(\"START_TIME\", long.class);         long duration = System.currentTimeMillis() - start_time;         if (duration &gt; THRESHOLD &amp;&amp; annotation == null) {             System.out.printf(\"Please consider mark method [%s] with @SlowTest.\\n\", testMethodName);         }     }      private ExtensionContext.Store getStore(ExtensionContext context) {         String testClassName = context.getRequiredTestClass().getName();         String testMethodName = context.getRequiredTestMethod().getName();         return context.getStore(ExtensionContext.Namespace.create(testClassName, testMethodName));     } }       확장팩 등록 방법   선언적인 등록 @ExtendWith   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @ExtendWith(FindSlowTestExtension.class) @TestMethodOrder(MethodOrderer.OrderAnnotation.class) class StudyTest {      int value = 1;      @Order(2)     @FastTest     @DisplayName(\"스터디 만들기 fast\")     void create_new_study() {         System.out.println(this);         System.out.println(value++);         Study actual = new Study(1);         assertThat(actual.getLimit()).isGreaterThan(0);     }      @Order(1)     @Test     @DisplayName(\"스터디 만들기 slow\")     @Disabled     void create_new_study_again() throws InterruptedException {         Thread.sleep(1005L);         System.out.println(this);         System.out.println(\"create1 \" + value++);     } }   결과   1 2 3 me.yes.thejavatest.StudyTest@f2ff811 create1 1 Please consider mark method [create_new_study_again] with @SlowTest.       프로그래밍 등록 @RegisterExtension   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @TestMethodOrder(MethodOrderer.OrderAnnotation.class) class StudyTest {      int value = 1;      @RegisterExtension     static FindSlowTestExtension findSlowTestExtension = new FindSlowTestExtension(1000L);      @Order(2)     @FastTest     @DisplayName(\"스터디 만들기 fast\")     void create_new_study() {         System.out.println(this);         System.out.println(value++);         Study actual = new Study(1);         assertThat(actual.getLimit()).isGreaterThan(0);     }      @Order(1)     @Test     @DisplayName(\"스터디 만들기 slow\")     @Disabled     void create_new_study_again() throws InterruptedException {         Thread.sleep(1005L);         System.out.println(this);         System.out.println(\"create1 \" + value++);     } }  ","categories": ["Spring"],
        "tags": ["Spring","Java","JUnit5"],
        "url": "/spring/Java-JUnit5/",
        "teaser": ""
      },{
        "title": "JPA N+1 문제",
        "excerpt":"JPA를 사용하다 보면 의도하지 않았지만 select 쿼리가 여러 개 발생하는 현상을 볼 수 있다. 이러한 현상을 N+1 문제라고 부르는데 이 문제가 왜 발생하는지와 이에 대한 해결 방법을 알아보자.   N+1 문제란?   간단히 말하자면, 조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개 더 발생하는 문제이다.   이 문제는 연관관계가 있는 엔티티간에 발생한다. 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(N) 만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상이다.   N+1 예제   다음은 N+1 문제를 설명하기 위한 예제이다.      Team 엔티티, User 엔티티   Team과 User는 양방향 일대다 연관관계   1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Getter @Setter public class Team {      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     @Column(name = \"team_id\")     private Long id;     private String name;      @OneToMany(mappedBy = \"team\")     private List&lt;User&gt; users = new ArrayList&lt;&gt;(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Getter @Setter public class User {      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     @Column(name = \"user_id\")     private Long id;     private String username;      @ManyToOne     @JoinColumn(name = \"team_id\")     private Team team; }      참고 FetchType은 Default로 *ToMany 에서는 Lazy Loading, *ToOne 에서는 Eager Loading로 지정된다. default 옵션을 사용해도 명시해주는 것이 협업하는 다른 개발자가 보기에 좋다.     테스트 데이터로 2개의 팀을 만들고 각 팀에 2명의 사용자를 넣겠다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class JpaProblem {      public static void main(String[] args) {          EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();         tx.begin();          try {             Team team = null;             for (int i = 0; i &lt; 2; i++) {                 team = new Team();                 team.setName(\"team\" + i);                 em.persist(team);             }              for (int j = 0; j &lt; 2; j++) {                 User user = new User();                 user.setUsername(\"member\" + j);                 user.setTeam(team);                 em.persist(user);             }             em.flush();             em.clear();              List&lt;User&gt; users = em.createQuery(\"select u from User u\", User.class)                     .getResultList();             tx.commit();         } catch (Exception e) {             tx.rollback();             e.printStackTrace();         } finally {             em.close();         }         emf.close();     } }   Fetch 모드가 EAGER인 경우   1 2 3 4 5 6 7 public class User {     ...      @ManyToOne(fetch = FetchType.EAGER)     @JoinColumn(name = \"team_id\")     private Team team; }   1 2 3 4 Hibernate: /* select u from User u */ select  user0_.user_id as user_id1_1_, user0_.team_id as team_id3_1_, user0_.username as username2_1_ from User user0_ Hibernate: select team0_.team_id as team_id1_0_0_, team0_.name as name2_0_0_ from Team team0_ where team0_.team_id=? Hibernate: select team0_.team_id as team_id1_0_0_, team0_.name as name2_0_0_ from Team team0_ where team0_.team_id=?      user를 조회하는 select문이 발생한다.   user를 조회하는 쿼리가 team을 조회한 row 만큼 select문을 호출한다.   FetchType.EAGER에서 N+1 문제가 발생했다.   N+1 문제는 즉시로딩에서 발생?   NO! N+1 문제는 FetchType으로 인해 발생하는 문제가 아니다. 지연로딩으로 변경해도 N+1 문제는 발생한다.   Fetch 모드가 Lazy인 경우   1 2 3 4 5 6 7 public class User {     ...      @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"team_id\")     private Team team; }   1 Hibernate: /* select u from User u */ select user0_.user_id as user_id1_1_, user0_.team_id as team_id3_1_, user0_.username as username2_1_ from User user0_      user를 조회하는 select문이 발생한다.   쿼리문이 하나만 호출되었다. 그렇다면 N+1 문제가 해결된 것일까? 아쉽게도 해결된 것이 아니다.🥲  지연로딩으로 설정했다는 것은 연관관계 데이터를 프록시 객체로 바인딩한 것이다. 실제 연관관계의 엔티티를 호출 시 team에 대한 쿼리문이 발생한다.   결국, 즉시로딩과 지연로딩은 동일한 결과가 발생한다. FetchType을 변경하는 것은 단지 N+1 발생 시점을 연관관계 데이터를 사용하는 시점으로 미룰지, 아니면 초기 데이터 로드 시점에 가져올지의 차이이다.   그렇다면, N+1은 왜 발생하는 것일까?   발생 원인   N+1 문제가 발생하는 이유는 JPQL에서 찾을 수 있다. JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 실행한다. 따라서, 위의 User 엔티티와 Team 엔티티가 연관관계가 있음에도 JPQL 입장에선 연관관계 데이터를 무시하고 해당 엔티티를 기준으로 쿼리를 조회한다. (select * from User) 그렇기 때문에 연관된 엔티티 데이터가 필요한 경우, FetchType으로 지정한 시점에 별도로 조회하게 된다.   해결 방안   해결방안으론 다음과 같은 방법이 있다. 하나씩 살펴보자.      JPQL Fetch Join 사용   EntityGraph 애노테이션   Batch Size   JPQL Fetch Join 사용   우리가 원하는 코드는 ‘select * from Team left join User on User.team_id = Team.id’ 이다. JPQL의 fetch join을 사용하면 우리가 원하는 쿼리를 생성할 수 있다.   1 2 List&lt;Team&gt; teams = em.createQuery(\"select t from Team t left join fetch t.users\", Team.class)                     .getResultList();   1 Hibernate: /* select t from Team t left join fetch t.users */ select team0_.team_id as team_id1_0_0_, users1_.user_id as user_id1_1_1_, team0_.name as name2_0_0_, users1_.team_id as team_id3_1_1_, users1_.username as username2_1_1_, users1_.team_id as team_id3_1_0__, users1_.user_id as user_id1_1_0__ from Team team0_ left outer join User users1_ on team0_.team_id=users1_.team_id   로그를 살펴보면 원하는 대로 조회하는 쿼리문 한 개가 발생하는 것을 확인할 수 있다.   하지만, fetch join도 단점이 있다. 우선 우리가 연관관계로 설정해놓은 FetchType을 사용할 수 없다는 것이다. fetch join을 사용하게 되면 데이터 호출 시점에 모든 연관관계의 데이터를 가져오기 때문에 FetchType을 Lazy로 설정하는 것이 무의미하다.   또한, 페이징 쿼리를 사용할 수 없다는 점과 2개 이상의 Collection join이 안된다는 단점이 있다.   @EntityGraph 애노테이션   JPQL에서 fetch join을 하게 되면 하드코딩 하게 된다는 단점이 있다. 이를 최소화 하고 싶을 때 @EntityGraph를 사용한다. 그냥 이런게 있구나만 알아두고 사용하지 말자. (너무 복잡하다.)   1 2 3 @EntityGraph(attributePaths = {\"articles\"}, type = EntityGraphType.FETCH) @Query(\"select distinct u from User u left join u.articles\") List&lt;User&gt; findAllEntityGraph();      참고 Fetch Join과 EntityGraph 주의할 점     Fetch Join과 EntityGraph는 JPQL을 사용하여 JOIN문을 호출한다는 공통점이 있다. 또한, 공통적으로 카테시안 곱(Cartesian Product)이 발생하여 중복 데이터가 존재할 수 있다. 그러므로 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야 한다.     중복된 데이터를 제거할 수 있는 방법은 다음과 같다.          컬렉션을 Set을 사용하게 되면 중복을 허용하지 않는 자료구조이기 때문에 중복된 데이터를 제거할 수 있다.     JPQL을 사용하기 때문에 distinct를 사용하여 중복된 데이터를 조회하지 않을 수 있다.      Batch Size   이 옵션은 정확히는 N+1 문제를 해결하기보단 N+1 문제가 발생해도 IN 방식으로 데이터를 가져올 수 있는 방법이다. 이렇게 하면 100번 일어날 N+1 문제를 1번만 더 조회하는 방식으로 성능을 최적화할 수 있다.   1 2 3 4 5 select * from user where team_id = ? select * from user where team_id = ?  # Batch Size 사용 시 select * from user where team_id in (?,?);   Batch Size에 관련된 옵션은 application.yml에서 설정하면 된다. 설정 하나만 세팅하면 아래와 같이 in 절로 쿼리가 나간다.   1 2 3 4 5 spring:   jpa:     properties:       hibernate:         default_batch_fetch_size: 1000   Batch Size는 앞서 fetch join에서 단점이었던 페이징 처리와 Collection Join이 가능하다. 하지만, Batch Size는 최적화 데이터 사이즈를 알기 쉽지 않다는 단점이 있다.   QueryBuilder   Query를 실행하도록 지원해주는 다양한 플러그인이 있는데 대표적으로 Mybatis, QueryDSL, JDBC Template 등이 있다. 이를 사용하면 로직에 최적화된 쿼리를 구현할 수 있다.   1 2 // QueryDSL로 구현한 예제 return from(team).leftJoin(team.users, user).fetchJoin();   실무에서 N+1 문제를 방지하는 방법   우선 연관관계 설정은 FetchType을 모두 지연로딩으로 설정한다. 그리고 성능 최적화가 필요한 부분에서는 Fetch Join을 사용한다. 기본적으로 Batch Size의 값은 1000이하로 설정한다. (최적화 데이터 사이즈를 알긴 어렵다.) JPA 만으로 실제 비즈니스 로직을 모두 구현하긴 어려우므로 QueryDSL을 함께 사용하는 것이 좋은 방법이 될 수 있다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-N+1/",
        "teaser": ""
      },{
        "title": "JWT(Json Web Token) 인증",
        "excerpt":"1. REST API 인증 기법      Basic 인증   Bearer 인증   JSON 웹 토큰       1.1 Basic 인증   Basic 인증이란      상태가 없는 웹 애플리케이션(Todo 앱)에서 인증을 구현하는 가장 간단한 방법       Basic 인증 절차      모든 HTTP 요청에 아이디와 비밀번호를 같이 보냄   최초 로그인 후 HTTP 요청 헤더의 Authorization: ‘Basic &lt;ID&gt;:&lt;Password&gt;’ 처럼 Base64로 인코딩한 문자열을 함께 보냄       Basic Auth 예   1 Authorization : Basic a2FpemVuOjEyMzQ1 (ID:Password)      HTTP 요청을 수신한 서버는 인코딩된 문자열을 디코딩하여 아이디와 비밀번호가 일치하면 요청받은 일을 수행하고, 아니면 거부함       Basic 인증의 단점      아이디와 비밀번호를 노출한다.            디코딩을 통해 아이디와 비밀번호를 확인할 수 있다.       따라서 보안을 위해 반드시 HTTPS를 사용해야 한다.           사용자를 로그아웃시킬 수 없다            모든 요청이 일종의 로그인 요청이기 때문       여러 디바이스에서 로그인이 가능한 경우 한꺼번에 로그아웃을 하거나 디바이스 별로 로그아웃을 할 수 있는 기능을 Basic 인증은 제공하기 힘들다           사용자 계정 정보가 있는 저장 장소(인증 서버, 인증 DB)의 경우 과부하가 걸릴 확률이 높다            큰 서비스일 수록 문제 발생           인증 서버가 단일 장애점(시스템의 한 부분이 오류가 나는 경우 전체 시스템을 가동 불가하게 함)       1.2 토큰 기반 인증   토큰 기반 인증이란?      토큰은 최초 로그인 시 서버가 만들어 줌.   서버가 토큰을 만들어 반환하면 클라이언트는 이후 요청에 아이디와 비밀번호 대신 토큰을 넘겨 자신이 인증된 사용자임을 알림   토큰 기반 요청은 헤더에 Authorization: Bearer &lt;TOKEN&gt; 명시   Bearer Token 예   1 Authorization: Bearer eyJhbGciOiJIUzUMyIsInJvbGUiOiJST0xFX1VTRVIiLCJpc3MiOiJkZ       토큰 기반 인증 장점      Basic Auth 에 비해 보안 측면에서 안전하다   서버가 토큰을 마음대로 생성할 수 있으므로 사용자의 인가 정보, 유효 시간을 정해 관리할 수 있다   디바이스마다 다른 토큰을 생성해 주고 유효 시간을 다르게 정하거나 임의로 로그아웃을 할 수 있다       토큰 기반 인증 단점   Basic 인증에서 마주한 스케일 문제를 해결할 수 없다. 즉,  토큰 이용만으로 스케일 문제를 해결할 수 없다       1.3 JSON 웹 토큰 (JWT)   전자 서명된 토큰 중 하나가 JSON 웹 토큰 (JWT)   서버에서 전자 서명된 토큰을 이용하면 인증에 따른 스케일 문제를 해결할 수 있다   JWT 토큰은 {header}.{payload}.{signature}   JWT 예   1 Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIzMyIsInJvbGUiOiJST0xFX1VTRVIiLCJpc3MiOiJkZWJyYWlucyIsImlhdCI6MTY0NzQ3NjgzMSwiZXhwIjoxNjQ3NDgwNDMxfQ.IXv1DKfaBNGWzTPEzuinyJV789PnWg8EwZQAI6GVCwYvbb6KQKmevvScHPjIHde8fwVz2J2zGcLAuh2QLqUSmw       JWT 를 디코딩하면 다음과 같다   1 2 3 4 5 6 7 8 9 10 11 12 { // header \t\"typ\": \"JWT\", \t\"alg\": \"HS512\" }. { // payload \t\"sub\": \"absdcsdfdfsdfds\", \t\"iss\": \"demo app\", \t\"exp\": 1595733647, \t\"iat\": 1595733657 }. IXv1DKfaBNGWzTPEzuinyJV789PnWg8EwZQAI6GVCwYvbb6KQKmevvScHPjIHde8fwVz2J2zGcLAuh2QLqUSmw // signature   Header      typ(type): 토큰의 타입을 의미   alg(algorithm): 토큰의 서명을 발행하는데 사용된 해시 알고리즘의 종류를 의미   Payload      sub(subject): 토큰의 주인을 의미. sub는 ID처럼 유일한 식별자   iss(issuer): 토큰을 발행한 주체를 의미. 페이스북이 발행했다면 facebook 이 됨   iat(issued at): 토큰일 발행된 날짜와 시간   exp(expiration): 토큰이 만료되는 시간   Signature      토큰을 발행한 주체 Issuer가 발행한 서명으로 토큰의 유효성 검사에 사용       JWT에서 전자 서명이란 {헤더}.{페이로드}와 시크릿키를 이용해 해시 함수에 돌린 암호화한 결과 값   시크릿키란 나만 알고있는 문자열, 비밀번호 같은 것       JWT 인증 절차      최초 로그인 시 서버는 사용자의 아이디와 비밀번호를 서버에 저장된 값과 비교해 인증   인증된 사용자의 경우 사용자의 정보를 이용해 {헤더}.{페이로드} 부분을 작성, 시크릿키로 {헤더}.{페이로드} 부분을 전자 서명   전자 서명의 결과로 나온 값을 {헤더}.{페이로드}.{서명}으로 이어붙이고 Base64로 인코딩 후 반환   이후 이 토큰으로 리소스 접근 요청하면 서브는 토큰을 디코딩해 {헤더}.{페이로드}와 {서명} 부분으로 나눔   서버는 {헤더}.{페이로드}와 시크릿키로 전자 서명을 만든 후 방금 만든 전자 서명을 HTTP 요청이 갖고 온 {서명} 부분과 비교해 이 토큰의 유효성을 검사       위 과정을 통해 JWT 인증 방식은 인증 서버에 토큰의 유효성에 대해 물어볼 필요가 없다. 따라서 인증 서버에 부하를 일으키지 않는다. 즉, 인증 서버가 단일 장애점이 아니다.       토큰을 훔쳐가면 해당 계정의 리소스에 접근 할 수 있기 때문에 이를 방지하기 위해 HTTPS를 통해 통신해야 함.       2. 스프링 시큐리티 통합      JWT 인증 로직 구현   패스워드 암호화 로직 구현       2.1 실습 전 준비      User.java   UserRepository.java   UserService.java   UserDTO.java   UserController.java       User.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package me.yessm.userauth.user;  import lombok.*;  import javax.persistence.*;  @Entity @AllArgsConstructor @NoArgsConstructor @Data @Builder @Table(uniqueConstraints = {@UniqueConstraint(columnNames = \"email\")}) public class User {      @Id     @GeneratedValue     private Long id;      @Column(nullable = false)     private String username;      @Column(nullable = false)     private String email;      @Column(nullable = false)     private String password; }       UserRepository.java   1 2 3 4 5 6 7 8 9 10 11 12 package me.yessm.userauth.user;  import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository;  @Repository public interface UserRepository extends JpaRepository&lt;User, Long&gt; {      User findByEmail(String email);     Boolean existsByEmail(String email);     User findByEmailAndPassword(String email, String password); }       UserService.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package me.yessm.userauth.user;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service;  @Service public class UserService {      @Autowired     private UserRepository userRepository;      public User create(final User user) {         if (user == null || user.getEmail() == null) {             throw new RuntimeException(\"Invalid arguments\");         }          final String email = user.getEmail();         if (userRepository.existsByEmail(email)) {             throw new RuntimeException(\"Email already exists\");         }          return userRepository.save(user);     }      public User getByCredentials(final String email, final String password) {         return userRepository.findByEmailAndPassword(email, password);     } }       UserDTO.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package me.yessm.userauth.user;  import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor;  @Data @Builder @AllArgsConstructor @NoArgsConstructor public class UserDTO {      private String token;     private String email;     private String username;     private String password;     private Long id; }       UserController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package me.yessm.userauth.user;  import me.yessm.userauth.common.ResponseDTO; import me.yessm.userauth.security.TokenProvider; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  @RestController @RequestMapping(\"/auth\") public class UserController {      @Autowired     private UserService userService;      @PostMapping(\"/signup\")     public ResponseEntity&lt;?&gt; registerUser(@RequestBody UserDTO userDTO) {         try {             User user = User.builder()                     .email(userDTO.getEmail())                     .username(userDTO.getUsername())                     .password(userDTO.getPassword())                     .build();              User registeredUser = userService.create(user);             UserDTO responseUserDTO = UserDTO.builder()                     .email(registeredUser.getEmail())                     .id(registeredUser.getId())                     .username(registeredUser.getUsername())                     .build();              return ResponseEntity.ok().body(responseUserDTO);         } catch (Exception e) {             ResponseDTO responseDTO = ResponseDTO.builder().error(e.getMessage()).build();              return ResponseEntity.badRequest().body(responseDTO);         }     }      @PostMapping(\"/signin\")     public ResponseEntity&lt;?&gt; authenticate(@RequestBody UserDTO userDTO) {         User user = userService.getByCredentials(                 userDTO.getEmail(),                 userDTO.getPassword());          if (user != null) {             final UserDTO responseUserDTO = UserDTO.builder()                     .email(user.getUsername())                     .id(user.getId())                     .build();              return ResponseEntity.ok().body(responseUserDTO);         } else {             ResponseDTO responseDTO = ResponseDTO.builder()                     .error(\"Login failed\")                     .build();              return ResponseEntity.badRequest().body(responseDTO);         }     } }       2.2 JWT 생성 및 반환 구현   사용자 정보를 바탕으로 헤더와 페이로드를 작성학고 전자 서명한 후 토큰을 리턴          1. JWT 관련 라이브러리 추가   1 implementation group: 'io.jsonwebtoken', name: 'jjwt', version: '0.9.1'       2. TokenProvider 생성   TokenProvider.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package me.yessm.userauth.security;  import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import me.yessm.userauth.user.User; import org.springframework.stereotype.Service;  import java.time.Instant; import java.time.temporal.ChronoUnit; import java.util.Date;  @Service public class TokenProvider {      private static final String SECRET_KEY = \"test12341234\";      public String create(User user) {         Date expiryDate = Date.from(Instant.now().plus(1, ChronoUnit.DAYS));          return Jwts.builder()                 .signWith(SignatureAlgorithm.HS512, SECRET_KEY)                 .setSubject(user.getEmail())                 .setIssuer(\"yessm app\")                 .setIssuedAt(new Date())                 .setExpiration(expiryDate)                 .compact();     }      public String validateAndGetUserId(String token) {         Claims claims = Jwts.parser()                 .setSigningKey(SECRET_KEY)                 .parseClaimsJws(token)                 .getBody();          return claims.getSubject();     } }   TokenProvider 클래스가 하는 일은 사용자 정보를 받아 JWT를 생성하는 일   create(): JWT 라이브러리를 이용해 JWT 토큰을 생성   validateAndGetUserId(): 토큰을 디코딩 및 파싱하고 토큰의 위조 여부 확인       3. UserController.java 수정   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24     @PostMapping(\"/signin\")     public ResponseEntity&lt;?&gt; authenticate(@RequestBody UserDTO userDTO) {         User user = userService.getByCredentials(                 userDTO.getEmail(),                 userDTO.getPassword());          if (user != null) {             // 토큰 생성, UserDTO에 추가             final String token = tokenProvider.create(user);             final UserDTO responseUserDTO = UserDTO.builder()                     .email(user.getUsername())                     .id(user.getId())                     .token(token)                     .build();              return ResponseEntity.ok().body(responseUserDTO);         } else {             ResponseDTO responseDTO = ResponseDTO.builder()                     .error(\"Login failed\")                     .build();              return ResponseEntity.badRequest().body(responseDTO);         }     }       4. 테스트         인코딩된 JWT 토큰   1 2 3 4 5 6 7 {     \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ5ZXNzbTYyM0BnbWFpbC5jb20iLCJpc3MiOiJ5ZXNzbSBhcHAiLCJpYXQiOjE2NTAzNDU3NjEsImV4cCI6MTY1MDQzMjE2MX0.znuDrNcPA6BcKUzbysOQJ99vxm_OCTPpEhr1DUfveMjkkDh1uEKn4zF7pHSBiz3cTR4gBRalyKMDUHgn3RSIHA\",     \"email\": \"user1\",     \"username\": null,     \"password\": null,     \"id\": 3 }       2.3 스프링 시큐리티와 서블릿 필터          스프링 시큐리티의 도움을 받아 API가 실행될 때마다 사용자를 인증해 주는 부분을 구현   토큰 인증을 위해 컨트롤러 메서드의 첫 부분마다 인증 코드를 작성하기 위해 서블릿 필터를 사용       스프링 시큐리티는 서블릿 필터의 집합.  서블릿 필터란 서블릿 실행 전에 실행되는 클래스들   스프링이 구현하는 서블릿이 디스패처 서블릿이고 서블릿 필터는 디스패처 서블릿이 실행되기 전에 항상 실행됨   따라서, 개발자는 서블릿 필터를 구현하고 서블릿 필터를 서블릿 컨테이너가 실행하도록 설정해 주기만 하면 된다       서블릿 필터는 구현된 로직에 따라 원하지 않는 HTTP 요청을 걸러낼 수 있다.   걸러낸 HTTP는 거절되는 것이고 서블릿 필터가 전부 살아남은 HTTP요청은 디스패처 서블릿으로 넘어와 컨트롤러에서 실행됨       2.4 JWT를 이용한 인증 구현   스프링 시큐리티관련 라이브러리 추가   1 implementation 'org.springframework.boot:spring-boot-starter-security'       OncePerRequestFilter 클래스를 상속해 필터를 생성   OncePerRequestFilter는 한 요청당 반드시 한 번만 실행됨       OncePerRequestFilter를 상속받는 JwtAuthenticationFilter를 구현   JwtAuthenticationFilter.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package me.yessm.userauth.security;  import lombok.extern.log4j.Log4j2; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.AbstractAuthenticationToken; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.authority.AuthorityUtils; import org.springframework.security.core.context.SecurityContext; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.web.authentication.WebAuthenticationDetailsSource; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.filter.OncePerRequestFilter;  import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;  @Log4j2 @Component public class JwtAuthenticationFilter extends OncePerRequestFilter {      @Autowired     private TokenProvider tokenProvider;      @Override     protected void doFilterInternal(HttpServletRequest request,                                     HttpServletResponse response,                                     FilterChain filterChain)             throws ServletException, IOException {         try {             // 요청에서 토큰 가져옴             String token = parseBearerToken(request);              if (token != null &amp;&amp; !token.equalsIgnoreCase(\"null\")) {                 // userId 가져오기, 위조된 경우 예외 처리                 String userId = tokenProvider.validateAndGetUserId(token);                  // 인증 완료. SecurityContextHolder에 등록해야 인증된 사용자라고 생각한다                 AbstractAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userId, null, AuthorityUtils.NO_AUTHORITIES);                  authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));                  SecurityContext securityContext = SecurityContextHolder.createEmptyContext();                 securityContext.setAuthentication(authentication);                 SecurityContextHolder.setContext(securityContext);             }         } catch (Exception ex) {             logger.error(\"Could not set user authentication in security context\", ex);         }         filterChain.doFilter(request, response);     }      private String parseBearerToken(HttpServletRequest request) {         String bearerToken = request.getHeader(\"Authorization\");          if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(\"Bearer \")) {             return bearerToken.substring(7);         }         return null;     } }       위 코드의 처리 과정      요청의 헤더에서 Bearer 토큰을 가져옴        TokenProvider를 이용해 토큰을 인증하고 UsernamePasswordAuthenticationToken 작성       → UsernamePasswordAuthenticationToken 오브젝트에 사용자의 인증 정보를 저장하고 SecurityContext에 인증된 사용자를 등록       → 등록하는 이유? 요청을 처리하는 과정에서 사용자가 인증됐는지의 여부나 인증된 사용자가 누군지 알아야 할 때가 있기 때문           스프링 시큐리티의 SercurityContext는 SecurityContextHolder의 createEmptyContext() 메서드를 이용해 생성 가능   생성한 컨텍스트에 인증 정보인 authentication을 넣고 다시 SecurityContextHolder에 컨텍스트로 등록   SecurityContextHolder는 기본적으로 ThreadLocal에 저장됨   ThreadLocal에 저장되므로 Thread마다 하나의 컨텍스트를 관리할 수 있음       2.5 스프링 시큐리티 설정   서블릿 필터를 사용하려면      서블릿 필터를 구현해야 함   서블릿 컨테이너에 이 서블릿 필터를 사용하라고 알려주는 설정 작업       스프링 시큐리티에 JwtAuthenticationFilter를 사용하라고 알려주자       WebSecurityConfig.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package me.yessm.userauth.config;  import me.yessm.userauth.security.JwtAuthenticationFilter; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.web.filter.CorsFilter;  @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter {      @Autowired     private JwtAuthenticationFilter jwtAuthenticationFilter;      @Override     protected void configure(HttpSecurity http) throws Exception {         http.cors()                 .and()                 .csrf()                 .disable()                 .httpBasic()                 .disable()                 .sessionManagement()                 .sessionCreationPolicy(SessionCreationPolicy.STATELESS)                 .and()                 .authorizeRequests()                 .antMatchers(\"/\", \"/auth/**\").permitAll()                 .anyRequest()                 .authenticated();          http.addFilterAfter(                 jwtAuthenticationFilter,                 CorsFilter.class         );     } }   HttpSecurity 는 시큐리티 설정을 위한 오브젝트   web.xml 대신 HttpSecurity 를 이용해 시큐리티 관련 설정을 하는 것       addFilterAfter() 메서드를 통해 CorsFilter 이후에  jwtAuthenticationFilter 실행하게 설정       테스팅     회원가입 후 다시 로그인을 하면 아래 그림과 같이 응답과 함께 토큰이 온다             Authorization 에 Bearer Token 을 선택하고 토큰을 복사하여 붙여넣기 한다             토큰이 위조되면 아래와 같은 에러메시지가 발생한다.   1 2 3 4 // JWT를 신뢰할 수 없어 예외 처리됨 io.jsonwebtoken.SignatureException:  JWT signature does not match locally computed signature.  JWT validity cannot be asserted and should not be trusted.       2.6 TodoController에서 인증된 사용자 사용하기   TodoController.java   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 package me.yessm.userauth.controller;  import me.yessm.userauth.dto.ResponseDTO; import me.yessm.userauth.dto.TodoDTO; import me.yessm.userauth.entity.Todo; import me.yessm.userauth.service.TodoService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.security.core.annotation.AuthenticationPrincipal; import org.springframework.web.bind.annotation.*;  import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  @RestController @RequestMapping(\"todo\") public class TodoController {      @Autowired     private TodoService todoService;      @GetMapping(\"/test\")     public ResponseEntity&lt;?&gt; testTodo() {         String str = todoService.testService();         List&lt;String&gt; list = new ArrayList&lt;&gt;();         list.add(str);         ResponseDTO&lt;String&gt; response = ResponseDTO.&lt;String&gt;builder().data(list).build();          return ResponseEntity.ok(response);     }      @PostMapping     public ResponseEntity&lt;?&gt; createTodo(             @AuthenticationPrincipal String userId,             @RequestBody TodoDTO dto) {         try {             Todo entity = TodoDTO.toEntity(dto);             entity.setId(null);             entity.setUserId(userId);              List&lt;Todo&gt; entities = todoService.create(entity);             List&lt;TodoDTO&gt; dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList());              ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build();              return ResponseEntity.ok(response);         } catch (Exception e) {             String error = e.getMessage();             ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().error(error).build();              return ResponseEntity.badRequest().body(response);         }     }      @GetMapping     public ResponseEntity&lt;?&gt; retrieveTodoList(             @AuthenticationPrincipal String userId) {         System.out.println(\"UserID : \" + userId);         List&lt;Todo&gt; entities = todoService.retrieve(userId);          List&lt;TodoDTO&gt; dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList());          ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build();          return ResponseEntity.ok(response);     }      @PutMapping     public ResponseEntity&lt;?&gt; updateTodo(@AuthenticationPrincipal String userId,                                         @RequestBody TodoDTO dto) {         Todo entity = TodoDTO.toEntity(dto);         entity.setUserId(userId);         List&lt;Todo&gt; entities = todoService.update(entity);          List&lt;TodoDTO&gt; dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList());          ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build();          return ResponseEntity.ok(response);     }      @DeleteMapping     public ResponseEntity&lt;?&gt; deleteTodo(             @AuthenticationPrincipal String userId,             @RequestBody TodoDTO dto) {         try {             Todo entity = TodoDTO.toEntity(dto);             entity.setUserId(userId);             List&lt;Todo&gt; entities = todoService.delete(entity);              List&lt;TodoDTO&gt; dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList());              ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build();              return ResponseEntity.ok(response);         } catch (Exception e) {             String error = e.getMessage();             ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().error(error).build();              return ResponseEntity.badRequest().body(response);         }     } }       매개변수 userId 는 스프링의 @AuthenticationPrincipal 를 이용해서 찾는다       @AuthenticationPrincipal 이란?   1 2 AbstractAuthenticationToken authentication =  new UsernamePasswordAuthenticationToken(userId, null, AuthorityUtils.NO_AUTHORITIES);   UsernamePasswordAuthenticationToken 생성자의 첫 매개변수가 AuthenticationPrincipal 이다       2.7 패스워드 암호화   스프링 시큐리티가 제공하는 BCryptPasswordEncoder 를 사용       UserService.java   1 2 3 4 5 6 7 8 9 10 11 12 ...  \tpublic User getByCredentials(final String email, final String password, final PasswordEncoder encoder) {         final User originalUser = userRepository.findByEmail(email);          if (originalUser != null &amp;&amp; encoder.matches(password, originalUser.getPassword())) {             return originalUser         }         return userRepository.findByEmailAndPassword(email, password);     }  ...   BCryptPasswordEncoder 는 같은 값을 인코딩해도 할 때마다 값이 다르기 때문에 matches() 메서드를 이용해 패스워드가 같은지 비교       UserController.java 수정   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 package me.yessm.userauth.controller;  import me.yessm.userauth.dto.ResponseDTO; import me.yessm.userauth.dto.UserDTO; import me.yessm.userauth.entity.User; import me.yessm.userauth.security.TokenProvider; import me.yessm.userauth.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  @RestController @RequestMapping(\"/auth\") public class UserController {      @Autowired     private UserService userService;      @Autowired     private TokenProvider tokenProvider;      private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();      @PostMapping(\"/signup\")     public ResponseEntity&lt;?&gt; registerUser(@RequestBody UserDTO userDTO) {         try {             User user = User.builder()                     .email(userDTO.getEmail())                     .username(userDTO.getUsername())                     .password(passwordEncoder.encode(userDTO.getPassword()))                     .build();              User registeredUser = userService.create(user);             UserDTO responseUserDTO = UserDTO.builder()                     .email(registeredUser.getEmail())                     .id(registeredUser.getId())                     .username(registeredUser.getUsername())                     .build();              return ResponseEntity.ok().body(responseUserDTO);         } catch (Exception e) {             ResponseDTO responseDTO = ResponseDTO.builder().error(e.getMessage()).build();              return ResponseEntity.badRequest().body(responseDTO);         }     }      @PostMapping(\"/signin\")     public ResponseEntity&lt;?&gt; authenticate(@RequestBody UserDTO userDTO) {         System.out.println(\"signin userDTO: \" + userDTO);         User user = userService.getByCredentials(                 userDTO.getEmail(),                 userDTO.getPassword(),                 passwordEncoder);          if (user != null) {             // 토큰 생성             final String token = tokenProvider.create(user);             final UserDTO responseUserDTO = UserDTO.builder()                     .email(user.getUsername())                     .id(user.getId())                     .token(token)                     .build();              return ResponseEntity.ok().body(responseUserDTO);         } else {             ResponseDTO responseDTO = ResponseDTO.builder()                     .error(\"Login failed\")                     .build();              return ResponseEntity.badRequest().body(responseDTO);         }     } }  ","categories": ["Spring"],
        "tags": ["Java","Spring","JPA"],
        "url": "/spring/SpringBoot-JWT/",
        "teaser": ""
      },{
        "title": "파이썬 알고리즘",
        "excerpt":"파이썬 기초 문법   출력방식   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 a, b, c = 1, 2, 3  print(a, b, c, sep=', ') # 1, 2, 3  print(a, b, c, sep='') # 123  print(a, b, c, sep='\\n') # 1 # 2 # 3  # 줄바꿈 안함. 공백으로 구분. print(a, end=' ') print(b, end=' ') print(c) # 1 2 3     변수입력과 연산자   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # a = 2, b = 3 a=input(\"숫자를 입력하세요 : \") print(type(a)) print(a) # &lt;class 'str'&gt; # 2  a, b = input(\"숫자를 입력하세요 : \").split() a=int(a) b=int(b) print(type(a)) print(a+b) # &lt;class 'int'&gt; # 5  # 입력받은 값을 바로 int로 가져옴 a, b = map(int, input(\"숫자를 입력하세요 : \").split()) print(type(a)) print(a+b) print(a-b) print(a*b) print(a/b) # 나누기 print(a//b) # 나누기의 몫 print(a%b) # 나누기의 나머지 print(a**b) # 제곱근 # &lt;class 'int'&gt; # 5 # -1 # 6 # 0.66666666666 # 0 # 2 # 8  a=4.3 b=5 print(type(c)) print(c) # &lt;class 'float'&gt; # 실수형과 정수형을 더하면 실수형으로 나옴, 범위: 실수형&gt;정수형 # 9.3  # 숫자면 true, 아니면 false isdecimal()  # 값 비교하여 더 큰 값을 return largest = 20 tmp = 30 largest = max(largest, tmp) # largest = 30  tmp = 10 largest = max(largest, tmp) # largest = 30     반복문   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # range()는 정수를 순서대로 만듦 a=range(1, 11) list(a) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # range(10) == range(0,10) list(range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  list(range(10, 0, -1)) # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]  list(range(10, 0, -2)) # [10, 8, 6, 4, 2]  # 한 숫자의 모든 배수에 접근할 때는 range(start, end, start)  # (i=i+1) == (i+=1)  # for ~ else 구문: for문이 모두 실행된 후 else 실행 for i in range(1, 11): \tprint(i) \tif i==5: \t\tbreak else: \tprint(11) # 1 # 2 # 3 # 4 # 5  for i in range(1, 11): \tprint(i) \tif i&gt;15: \t\tbreak else: \tprint(11) # 1 # 2 # ... # 9 # 10 # 11     반복문을 이용한 문제풀이   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ''' 반복문을 이용한 문제풀이 1) 1부터 N까지 홀수 출력하기 (N은 입력받기) 2) 1부터 N까지 합 출력하기 (N은 입력받기) 3) N의 약수 출력하기 (N은 입력받기) '''  # 1) n = input(\"숫자1: \") n = int(n) for i in range(1, n+1): \tif i%2 == 1: \t\tprint(i)  # 2) n2 = int(input(\"숫자2: \")) sum = 0 for i in range(1, n2+1):     sum+=i print(sum)  # 3) n3 = int(input(\"숫자3: \")) for i in range(1, n3+1):     if n3%i==0:         print(i, end=' ')     중첩 반복문(2중 for문)   1 2 3 4 5 for i in range(5):     print('i:', i, sep='', end=' ')     for j in range(5):         print('j:', j, sep='', end=' ')     print()   1 2 3 4 5 i:0 j:0 j:1 j:2 j:3 j:4  i:1 j:0 j:1 j:2 j:3 j:4  i:2 j:0 j:1 j:2 j:3 j:4 i:3 j:0 j:1 j:2 j:3 j:4 i:4 j:0 j:1 j:2 j:3 j:4   1 2 3 4 5 for i in range(5):     print('i:', i, sep='', end=' ')     for j in range(i+1):         print('*', end=' ')     print()   1 2 3 4 5 i:0 *  i:1 * *  i:2 * * * i:3 * * * * i:4 * * * * *   1 2 3 4 for i in range(5):     for j in range(5-i):         print('*', end=' ')     print()   1 2 3 4 5 * * * * *  * * * *  * * * * * *     문자열과 내장함수   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 msg = \"It is Time\" print(msg.upper()) # 대문자 print(msg.lower()) # 소문자 print(msg) tmp=msg.upper() print(tmp) print(tmp.find('T')) # 문자열 index 반환(첫번째 index) print(tmp.count('T')) # 문자열 갯수 count print(msg) print(msg[:2]) # 0번부터 2번 전까지 print(msg[3:5]) # 3번부터 5번 전까지 print(len(msg)) for i in range(len(msg)):     print(msg[i], end=' ') print()  for x in msg:     print(x, end=',') print()  # 문자열에서 대문자만 출력 for x in msg:     if x.isupper():         print(x, end=' ') print()  # 문자열에서 소문자만 출력 for x in msg:     if x.islower():         print(x, end=' ') print()  # 알파벳만 출력 for x in msg:     if x.isalpha():         print(x, end='') print()  # ord(): 아스키 number 출력 # A: 65, Z: 90 # tmp='AZ' tmp='az' for x in tmp:     print(ord(x))  # 아스키넘버 -&gt; 문자열로 tmp=65 print(chr(tmp))   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 IT IS TIME it is time It is Time IT IS TIME 1 2 It is Time It is 10 I t   i s   T i m e I,t, ,i,s, ,T,i,m,e, I T t i s i m e ItisTime 97 122 A     리스트와 내장함수(1)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # 빈 list 생성 a=[] b=list() print(a, b) print(type(a), type(b))  a = [1, 2, 3, 4, 5] print(a, a[0])  # range로 list 초기화 b=list(range(1,11)) print(b)  c=a+b print(c)  # list에 값 추가 a.append(6)  # list a 에 3번째 인덱스에 7을 추가 a.insert(3, 7) print(a)  a.pop() # list 마지막 요소 삭제 print(a) # list의 3번째 요소 삭제 a.pop(3) print(a)  # 값으로 요소 삭제 a.remove(4) print(a)  # c=[3,2,1,4,6,8,'안녕'] # c.remove('안녕') # print(c)  # 해당하는 값의 index를 반환 print(a.index(5))  print(\"===================\")  a=list(range(1,11)) print(a) print(sum(a)) # 리스트의 합 print(max(a)) # 리스트의 가장 큰 값 print(min(a)) # 리스트의 가장 작은 값 print(min(7,3,5)) # 7, 3, 5 중 작은 값  import random as r # 랜덤으로 섞기 r.shuffle(a) print(a)  # 내림차순 a.sort(reverse=True) print(a)  # 오름차순 a.sort() print(a)  a.clear() print(a)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [] [] &lt;class 'list'&gt; &lt;class 'list'&gt; [1, 2, 3, 4, 5] 1 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 2, 3, 7, 4, 5, 6] [1, 2, 3, 7, 4, 5] [1, 2, 3, 4, 5] [1, 2, 3, 5] 3 ============================== [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 55 10 1 3 [6, 5, 1, 10, 4, 8, 2, 7, 3, 9] [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] []     리스트와 내장함수(2)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 a=[23,12,36,53,19] print(a[:3]) print(a[1:4]) print(len(a))  for i in range(len(a)):     print(a[i], end=' ') print()  for x in a:     print(x, end=' ') print()  for x in a:     if x%2==1:         print(x, end=' ') print()  # x가 tuple로 반환됨 for x in enumerate(a):     print(x)  b=(1,2,3,4,5) print(b[0]) # error. tuple은 변경이 불가능, 리스트는 변경 가능 # b[0]=7  b=[1,2,3,4,5] b[0]=7 print(b)  for x in enumerate(a):     print(x[0], x[1]) print()  for index, value in enumerate(a):     print(index, value) print()  print(\"============================\")  # a를 for문으로 돌면서 조건에 모두 참이면 true 반환 if all(60&gt;x for x in a):     print(\"YES\") else:     print(\"NO\")  # a를 for문으로 돌면서 조건에 하나라도 참이면 true 반환 if any(15 &gt; x for x in a):     print(\"YES\") else:     print(\"NO\")  # Q: 리스트안에 튜플이 있는 형태 any(cur[1] &lt; x[1] for x in Q)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [23, 12, 36] [12, 36, 53] 5 23 12 36 53 19 23 12 36 53 19 23 53 19 (0, 23) (1, 12) (2, 36) (3, 53) (4, 19) 1 [7, 2, 3, 4, 5] 0 23 1 12 2 36 3 53 4 19  0 23 1 12 2 36 3 53 4 19  ============================ YES YES   리스트와 튜플   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  a = [(0, 1), (1, 4), (5, 9), (3, 8), (4, 3)]  # 정렬방법 # 튜플의 첫번째 값을 기준으로 정렬 a.sort() # [(0, 1), (1, 4), (3, 8), (4, 3), (5, 9)]  # 튜플의 두번째 값을 기준으로 정렬 a.sort(key=lambda x: (x[1], x[0])) # [(0, 1), (4, 3), (1, 4), (3, 8), (5, 9)]  # 리스트를 받아오는 동시에 튜플의 첫번째는 인덱스, 두번째는 값을 가져오는 법 # input(): 60 50 70 80 90 Q = [(pos, val) for pos, val in enumerate(list(map(int, input().split())))] # [(0, 60), (1, 50), (2, 70), (3, 80), (4, 90)]     2차원 리스트 생성과 접근   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 a=[0]*3 print(a)  # 변수없이 반복문 3번 실행 # for _ in range(3)  # 2차원 리스트 -&gt; 표로 표현하는게 좋다 # [0]*3 을 3번 반복 a=[[0]*3 for _ in range(3)] print(a) print()  a[0][1]=1 print(a) print()  a[1][1]=2 print(a) print()  for x in a:     print(x)  for x in a:     for y in x:         print(y, end=' ')     print()   1 2 3 4 5 6 7 8 9 10 11 12 13 [0, 0, 0] [[0, 0, 0], [0, 0, 0], [0, 0, 0]]  [[0, 1, 0], [0, 0, 0], [0, 0, 0]]  [[0, 1, 0], [0, 2, 0], [0, 0, 0]]  [0, 1, 0] [0, 2, 0] [0, 0, 0] 0 1 0 0 2 0 0 0 0     함수만들기   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 함수는 항상 메인 스크립트 위에 생성해야 함 def add(a, b):     c = a+b     return c  x = add(3,2) print(add(3,2)) print(x)  print(\"==========================\")  # 함수에서 여러개의 값을 return 할 수 있다 # 튜플로 return 됨 def cal(a, b):     c=a+b     d=a-b     return c, d  print(cal(3,2))  print(\"==========================\")  # 소수면 true 반환 def isPrime(x):     for i in range(2,x):         if x%i==0:             return False     return True  arr=[12, 13, 7, 9, 19] for a in arr:     if isPrime(a):         print(a, end=' ')   1 2 3 4 5 6 5 5 ========================== (5, 1) ========================== 13 7 19     람다함수   1 2 3 4 5 6 7 8 9 10 11 12 def plus_one(x):     return x+1 print(plus_one(1))  plus_two=lambda x: x+2 print(plus_two(1))  a=[1, 2, 3] # map(함수명, 인자) # map(int, a) print(list(map(plus_one, a))) print(list(map(lambda x: x+1, a)))   1 2 3 4 2 3         [2, 3, 4] [2, 3, 4]     숫자, 문자열 역순  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 숫자 역순 할 때 사용 def reverse(x):     res = 0     while x &gt; 0:         t = x % 10         res = res * 10 + t         x = x//10     return res  # 숫자와 문자열 역순 할 때 사용 def reverse(x):     x = list(str(x))     x.reverse()     x = ''.join(x)      return int(x)     소수 관련   소수를 구하는 방법 (에라토스테네스의 체)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 소수를 구하는 방법은 다양하게 있으나 가장 빠른 방법은 에라토스테네스 체  # 받은 입력만큼의 크기를 가진 리스트를 만든다 ch=[0]*(n+1)  # 소수인 경우 카운트를 할 변수 초기화 cnt=0  # 소수의 갯수를 구하기 위해 2부터 n까지 for문을 실행 for i in range(2, n+1): \t\t# ch[i]가 0이면 소수     if ch[i] == 0:         cnt += 1 \t\t\t\t# ch[j]의 배수를 모두 1로 초기화         for j in range(i, n+1, i):             ch[j] = 1      [에라토스테네스의 체]           1은 제거            지워지지 않은 수 중 제일 작은 2를 소수로 채택하고, 나머지 2의 배수를 모두 지운다.            지워지지 않은 수 중 제일 작은 3을 소수로 채택하고, 나머지 3의 배수를 모두 지운다.            지워지지 않은 수 중 제일 작은 5를 소수로 채택하고, 나머지 5의 배수를 모두 지운다.            (반복)           소수 판별   1 2 3 4 5 6 7 8 def isPrime(x):     if x == 1:         return False     for i in range(2, x//2+1):         if x%i == 0:             return False     else:         return True     내장 함수   itertools (순열, 조합)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from itertools import combinations, combinations_with_replacement  arr = [1,2,3]  for a in combinations(arr, 2):     print(a)  print(\"=========\")  for a in combinations_with_replacement(arr, 2):     print(a)  # (1, 2) # (1, 3) # (2, 3) # ========= # (1, 1) # (1, 2) # (1, 3) # (2, 2) # (2, 3) # (3, 3)  from itertools import product a = ['A', 'B'] for i in product(a, repeat=3): \tprint(i)  ''' 출력결과: ('A', 'A', 'A') ('A', 'A', 'B') ('A', 'B', 'A') ('A', 'B', 'B') ('B', 'A', 'A') ('B', 'A', 'B') ('B', 'B', 'A') ('B', 'B', 'B') '''   collections   1 2 3 4 5 6 7 8 9 10 11 12 from collections import Counter  # 가장 흔한 값 arr = [1,4,5,6,3,2,4,5,6,1,1,4,5] counts = Counter(arr) res = counts.most_common(2) print(res) print(res[0][0], res[0][1]) print(res[1][0], res[1][1],) # [(1, 3), (4, 3)] # 1 3 # 4 3       알고리즘 종류   그리디 알고리즘   문제를 풀어나가는 과정(단계)에 있어서 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 것 보통의 그리디 문제는 다 정렬이다. 정렬 후 순서대로 선택해 나가면 됨       자료구조   리스트(List)           정의       리스트는 자료를 뒤에서 부터 넣을 수 있고 만약 처음 데이터를 삭제한다면 자료가 하나씩 앞당겨 지는 것       → 비효율적이다            평균 시간복잡도: O(n)           스택(Stack)           리스트와 같다 (FILO)            append(), pop() 활용            활용: 후위표기식 등            후위표기식              ’(‘: 나오면 바로 스택에 push한다.       ’)’: 우선순위가 가장 높은 괄호연산자가 끝난다는 뜻이므로, 괄호 안에 남아있는 연산자를 전부 pop하고 ‘(‘도 pop해줌. ‘)’는 처음부터 스택에 넣지 않는다.       ’*’, ‘/’: 스택에 ‘*’, ‘/’가 있다면 그것들을 먼저 없어질 때까지 pop해주고 끝나면 push한다. (‘+’,’-‘은 우선순위가 낮으므로 pop안함)       ’+’, ‘-‘: 스택에 다른 사칙연산자가 있다면 그것들을 먼저 없어질 때까지 (괄호연산자 직전가지)pop해주고 끝나면 push한다.               덱(Double-ended Queue, Double-linked list)           정의       양 끝에 elements 추가/삭제 가능       데크는 리스트와 달리 앞에서도 넣을 수 있고 뒤에서도 넣을 수 있다       만약 처음 데이터를 삭제하더라도 자료가 이동하지 않는다 (포인터가 변경되는 것이라 생각)       → 즉, 효율적이다!            평균 시간복잡도: O(1)            deque 주요 함수             append()       appendleft()       pop()       popleft()           참고) deque의 appendleft() 대신 List는 insert()가 있는데 O(n)의 시간 복잡도이다.       큐(Queue): FIFO   큐를 앞뒤로 활용한 것이 deque(덱)   deque를 사용해서 풀이: popleft(), append() 사용   원형 큐는 원형인 점을 고려하여 popleft() 후 마지막에 다시 append() 해줌…       참고) 아래 그림은 덱과 리스트의 차이를 보여줌           이분/이진 탐색 (binary search)      이진 탐색을 하기 위한 전제 조건: 리스트가 정렬되어 있어야 함   이진 탐색 순서            탐색 리스트를 정렬       left(0), right(len(list)), mid((left + right) // 2) 설정       mid 값과 찾고자 하는 값 비교       mid 값이 더 크면 right = mid - 1, mid 값이 더 작으면 left = mid + 1       left &lt;= right 조건이 만족할 때까지 반복           이진 탐색 시간복잡도: 탐색 사이즈가 계속 1/2씩 줄어들기 때문에 시간복잡도가 O(logN)       이진트리순회(깊이우선탐색)      전위순회: 부모-왼쪽-오른쪽   중위순회: 왼쪽-부모-오른쪽   후위순회: 왼쪽-오른쪽-부모   대부분의 문제는 전위순회가 대부분. 후위순회는 병합정렬이 대표적, 중위순회를 사용하는 경우는 많지 않다.   코드를 작성할 때 부모가 D(i)이라 한다면, 왼쪽 자식은 D(i2), 오른쪽 자식은 D(i2+1)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import sys sys.stdin=open(\"input.txt\", \"r\")  def DFS(v):     if v &gt; 7:         return     else:         # 전위순회방식         print(v)         DFS(v * 2)         # 중위순회방식         print(v)         DFS(v * 2 + 1)         # 후위순회방식         print(v)  if __name__==\"__main__\":     DFS(1)      ","categories": ["Python","Algorithm"],
        "tags": ["Algorithm","Python"],
        "url": "/python/algorithm/Python-Algorithm/",
        "teaser": ""
      },{
        "title": "자바: 예외처리",
        "excerpt":"예외처리(excetpion handling)   1.1 프로그램 오류   발생시점에 따라      컴파일 에러: 컴파일 할 때 발생하는 에러   런타임 에러: 프로그램의 실행도중에 발생하는 에러 (프로그램 종료됨)   그 외에      논리적 에러: 컴파일도 잘되고 실행도 잘되지만 의도한 것과 다르게 동작하는 것 (프로그램 종료 X)       실행 순서   컴파일 실행 → 컴파일러가 소스코드에 대해 오류가 있는지 알려줌 → 컴파일 성공되면 클래스 파일 생성됨 → 생성된 클래스 파일 실행       실행 중 에러 (런타임 에러)      에러(error)            프로그램 코드에 의해서 수습 될 수 없는 심각한 오류       ex. 메모리 부족 (OOME, Out of Memory Error), 스택오버플로우           예외(exception)            프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류       개발자가 예외를 대비해 적절한 코드를 미리 작성하여 프로그램의 비정상적인 종료를 막을 수 있음               1.2 예외 클래스의 계층구조   자바에선 실행 시 발생할 수 있는 오류(Exception과 Error)를 클래스로 정의함   Exception과 Error 클래스의 조상은 Object 클래스 (모든 클래스의 조상은 Object이므로..)       모든 예외의 최고 조상은 Exception   Exception과 RuntimeException      Exception클래스들: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외   RuntimeException클래스들: 프로그래머의 실수로 발생하는 예외       1.3 예외처리하기 - try~catch문   예외처리의 정의와 목적   정의: 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것   목적: 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지       예외를 처리하기 위해 try~catch문을 사용   1 2 3 4 5 6 7 8 9 try { \t// 예외가 발생할 가능성이 있는 문장들을 넣는다 } catch (Exception1 e1) { \t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적음 } catch (Exception2 e2) { \t// Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 적음 } catch (Exception3 e3) { \t// Exception3이 발생했을 경우, 이를 처리하기 위한 문장을 적음 }       1.4 try~catch문에서의 흐름      try블럭 내에서 예외가 발생한 경우            발생한 예외와 일치하는 catch 블럭이 있는지 확인       일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행. 일치하는 catch블럭을 찾지 못하면 예외는 처리되지 못함           try블럭 내에서 예외가 발생하지 않은 경우            catch블럭을 거치지 않고 try~catch문을 빠져나가서 수행을 계속함               1.5 예외의 발생과 catch블럭   catch블럭의 괄호() 내에는 처리하고 하는 예외와 같은 타입의 참조변수 하나를 선언   (참조변수의 유효범위(scope): 하나의 catch블럭)   예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐       printStackTrace()와 getMessage()   예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨있음.      printStackTrace(): 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력   getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다       멀티 catch블럭   내용이 같은 catch블럭을 하나의 catch블럭으로 합친 것   1 2 3 4 5 try { \t... } catch (ExceptionA | ExceptionB e) { \te.printStackTrace(); }   단, 부모 자식 관계에선 멀티 catch블럭을 사용할 수 없다.   멀티 catch블럭을 사용할 땐 ExceptionA에만 선언된 methodA()는 호출할 수 없다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-OOP9-Exception/",
        "teaser": ""
      },{
        "title": "IP와 TCP",
        "excerpt":"IP   클라이언트와 서버의 통신은 복잡한 인터넷 망(중간 노드라는 서버들)을 거쳐서 데이터를 전송한다. 먼저 IP에 대해 알아보자.      참고 노드   여기서의 노드란 네트워크를 중간에서 연결해주는 서버(라우터)를 의미한다.     IP란 Internet Protocol(인터넷 프로토콜)의 줄임말로 IP 프로토콜이라고도 한다. 복잡한 인터넷 망에서 클라이언트와 서버가 통신하려면 최소한의 규칙이 있어야 하는데 그게 IP이다.   클라이언트가 서버에게 지정한 주소로 메시지를 전달할 수 있으려면 클라이언트와 서버에 IP 주소를 부여해야 한다.      IP는 지정한 IP 주소(IP Address)에 데이터를 전달하고 패킷(Packet)이라는 통신 단위로 데이터를 전달한다.      참고 패킷   네트워크에서 데이터를 주고 받을 때 데이터를 일정 묶음으로 나눠놓은 것이다. 데이터는 작은 패킷으로 나뉘어 네트워크로 전송된다. 이 패킷에는 헤어가 있어서 헤더에 발신자 정보와 수령자 정보 등이 포함된다.        참고   패킷 교환방식의 장점           네트워크 리소스 점유 시간이 적다.     클라이언트에서 서버로 이동하는 경로가 고정되어 있지 않다.                패킷마다 어떤 경로를 통해 전달될지가 결정되어 있지 않기 때문에 경로상에 장애가 발생해도 다른 경로를 통해 전송하게 되므로 안정성이 높다.                 나누어진 패킷은 순서(넘버링)가 매겨져 중간에 유실된 패킷에 대한 재요청이 가능하여 전체 내용을 재전송하지 않아도 된다. (syn, ack 신호 교환이 각 패킷에 모두 적용된다)       패킷 교환방식의 단점   모든 패킷에 대한 syn, ack 확인과정이 추가되는 것, 모든 패킷에 헤더가 붙어야 한다는 것에 따른 오버헤드가 발생할 수 있다.     IP 패킷 정보   IP 패킷 정보에는 출발지 IP, 목적지 IP, 전송 데이터, 기타 등이 있다.      참고   요청(클라이언트 → 서버) 패킷과 응답(서버 → 클라이언트) 패킷의 전달 경로는 서로 다를 수 있다.     IP 프로토콜의 한계      비연결성: 클라이언트는 서버가 어떤 상태인지 모른다. 따라서, 서버가 서비스 불능 상태여도 일단 패킷을 전송하고 사라진다.   비신뢰성: 패킷을 보내는 중간에 노드(서버)가 꺼지거나 문제가 생기면 패킷이 유실되는데, 클라이언트는 패킷이 사라진지 모른다. 또한, 메시지가 너무 크면 패킷을 끊어서 보내는데 패킷이 순서대로 오지 않을 수 있다. 예) 클라이언트 1:Hello, 2:World → 서버 1:World, 2:Hello   프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 2개 이상이면 구분이 불가능하다.  예) 같은 IP에서 음악을 실행하고 게임을 하고 있으면 구분할 수 없다.      참고 IP 패킷의 순서   네트워크 계층 헤더의 프래그먼트 오프셋 등을 이용해 패킷의 순서를 알 수 있다. 수신측은 이 헤더정보를 통해 데이터의 순서나, 추가 데이터가 있는지 등을 파악할 수 있다.     이러한 IP 프로토콜의 한계를 극복하기 위해 TCP를 사용한다.   TCP, UDP   TCP   TCP란 Transmission Control Protocol의 줄임말로 전송 제어 프로토콜이라고 한다.   TCP는 패킷소실을 방지해주고, 패킷 순서를 보장해준다. 또한, TCP엔 PORT가 있어서 같은 IP에서 다른 애플리케이션을 실행해도 구분할 수 있다.   TCP/IP 패킷 정보      IP 내용: 출발지 IP, 목적지 IP, 기타   TCP 내용: 출발지 PORT, 목적지 PORT, 전송제어 정보, 순서 정보, 검증 정보   TCP = IP + PORT (IP가 한 아파트라면 PORT는 동, 호수이다.)         참고 PORT   PORT는 클라이언트에서 한번에 둘 이상의 서버와 연결할 때 구분하기 위해 사용한다. 포트는 0~65535 할당 가능하다. 그 중 0~1023까지는 잘 알려진 포트이므로 사용하지 않는 것이 좋다.  예) FTP - 20, 21 / TELNET - 23 / HTTP - 80 / HTTPS - 443        참고 localhost:8080   웹은 기본적으로 80포트를 사용하는 것이 관례이다. 그래서 HTTP 요청이면서 별도의 포트를 지정하지 않을 경우 80번 포트로 접속을 시도한다. 그러나, 사용자가 직접 포트 번호를 지정할 경우 그 포트로 바로 접속을 시도한다. 80에서 8080으로 포워딩하는 구조는 아니다.     TCP 특징   TCP엔 전송제어 정보, 순서 정보, 검증 정보가 있기 때문에 아래의 연결지향, 데이터 전달 보증, 순서 보장이 가능하다.      연결지향 - TCP 3way handshake(가상 연결): 서버와 클라이언트가 연결이 되어있는지 확인한다.   데이터 전달 보증: 클라이언트에서 데이터를 전달하고 서버가 데이터를 받으면 서버가 데이터를 잘 받았다고 클라이언트에게 응답 메시지를 전달해준다. 따라서, 패킷이 누락 되면 클라이언트가 알 수 있다.   순서 보장: 패킷을 보냈는데 순서가 틀리면 다 버리고 다시 보낸다. 예) 패킷 1, 2, 3 을 보냈는데 전송 도착이 1, 3, 2라고 하면 2번째 패킷부터 순서가 틀렸기 때문에 2번부터 다시 받음   신뢰할 수 있는 프로토콜   현재는 대부분 TCP 사용   TCP 3way handshake   TCP 3way handshake는 가상 연결로 물리적 연결이 아닌 논리적 연결이다. 클라이언트랑 서버랑 SYN - ACK을 보내면서 연결이 되어있나보다 생각하는 것이다.   TCP/IP 프로토콜로 연결하는 과정은 다음과 같다. (SYN: 접속 요청, ACK: 요청 수락)      클라이언트에서 서버로 SYN 보냄   서버에서 클라이언트로 SYN+ACK 보냄   클라이언트에서 서버로 ACK 보냄   연결이 완료되며 클라이언트에서 서버로 데이터 전송   1,2,3: connect 과정이고 이 과정 중 하나라도 실패하면 connection이 연결되지 않는다. 4번에서 데이터를 전송한다고 하였지만 요즘엔 최적화되어 3번 ACK를 전송하면서 데이터도 같이 전송한다.         참고   TCP/IP 패킷은 크게 헤더 부분과 데이터 부분으로 나눌 수 있다. 3 way handshake에서 TCP/IP 패킷을 전송한다고 했는데 실제론 헤더 부분을 전송하는 것이다. 이 헤더 부분에 SYN, ACK등을 포함해서 보낼 수 있다. 3단계나 4단계에서 헤더 + 데이터 부분이 함께 전송된다.        참고   데이터 전달이 종료되고 난 후 연결을 해제할 때는 4 way handshake 과정을 거친다.     UDP   UDP란 User Datagram Protocol의 줄임말로 사용자 데이터그램 프로토콜이라고 한다.   TCP와 달리 UDP는 패킷 소실 방지, 패킷 순서 보장을 해주는 것은 아니라 크게 도움이 되진 않지만, 그래도 문제를 해결해주는 정보를 가지고 있다. UDP는 TCP와 마찬가지로 PORT가 있다.   UDP 특징   UDP는 기능이 거의 없다. (연결지향 - TCP 3way handshake X, 데이터 전달 보증 X, 순서 보장 X) 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠르다. IP와 거의 같고 PORT, 체크섬 정도만 추가된다.   최근 HTTP 3스펙이 나오면서 TCP 프로토콜의 3 Way Handshake 과정의 번거로움을 없애고자 UDP를 사용하면서 UDP가 떠오르고 있다.      참고 체크섬   이 메세지가 맞는지 검증하는 용도, 네트워크를 통해 전달된 값이 변경되었는지를 검사하는 값으로 무결성을 제공함        참고 TCP와 UDP   애플리케이션으로 통신을 구현할 때 TCP와 UDP 중 선택해서 사용할 수 있다. 다만, 웹 개발은 브라우저라고 하는 애플리케이션 위에서 동작하는 애플리케이션을 만드는 일이다. 따라서, 통신 프로토콜을 선택하거나 하는 자유도가 많이 떨어진다. 서버와 브라우저가 서로 통신하며 HTTP 최신 규격을 사용할지 여부를 결정하게 되고, 이 규격에 따라 TCP만 사용할지 UDP도 사용할지가 결정된다. HTTP 최신규격인 HTTP/3 는 UDP를 이용한 데이터 전송을 주력으로 통신속도 향상을 꾀하는 것이 주된 목적이고 구글이 주도적으로 표준을 정립하고 있다.     DNS (Domain Name System)   IP는 기억하기 어렵고 변경될 수 있다. 따라서, IP주소를 도메인 명으로 변환하여 사용한다. 이때 DNS란 전화번호부처럼 도메인 명과 IP를 매칭하여 등록해 놓은 것을 의미한다.      인터넷 프로토콜 스택의 4계층   아래 그림은 브라우저의 인터넷을 사용할 때 이용되는 프로토콜 스택의 4계층이다. 브라우저라는 응용 애플리케이션이 실제 네트워킹을 하기 위한 구조라고 이해하자.      [예제] 채팅 프로그램      Hello, world! 라는 메시지를 전송하고 싶다면,      Hello, world! 메시지 생성   SOCKET 라이브러리를 사용해서 OS 계층에 메시지를 넘긴다.   OS 계층의 TCP가 메시지에 TCP의 정보 씌운다.   TCP 정보에 IP정보를 씌운다.            IP 패킷 안에 TCP 데이터 포함하고 있고 그 안에 메시지가 있다.           네트워크 인터페이스를 통해 LAN 카드로 IP 패킷을 서버에 보낸다. (Ethernet frame이 포함되서 나간다.)      참고 이더넷 프레임 (Ethernet frame)   랜카드에 등록된 맥주소 같은 물리적인 정보들이 포함되어 있다.     Reference.   모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["HTTP"],
        "tags": ["HTTP","web"],
        "url": "/http/Web-Internet-Network/",
        "teaser": ""
      },{
        "title": "HTTP",
        "excerpt":"HTTP란?   HTTP란 HyperText Transfer Protocol의 줄임말로 과거에는 HyperText(문서간의 링크를 통해 연결한 HTML)를 전송하기 위한 프로토콜이였으나 현재는 거의 모든 형태의 데이터를 HTTP 메시지로 전송 가능하다. (HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML(API) 등)   HTTP 버전은 HTTP/1.1을 가장 많이 사용한다. HTTP/1.1이 제일 중요한데 그 이유는 HTTP/1.1에 거의 모든 기능이 들어있고 HTTP/2, HTTP/3은 성능 개선에 초점이 맞춰져 있다.   HTTP/1.1과 HTTP/2는 TCP 기반 프로토콜이며 HTTP/3은 UDP 기반 프로토콜이다.      참고   TCP 프로토콜 위에 HTTP 프로토콜이 있고 현재는 TCP 프로토콜은 거의 사용하지 않고 HTTP 프로토콜을 사용한다.     HTTP 특징   HTTP의 특징은 4가지가 있다. 그 중에서 HTTP 메시지가 가장 중요하다.   1. 클라이언트 - 서버 구조   HTTP는 Requst, Response 구조이다. 클라이언트는 서버에 요청을 보내고 응답을 대기하고, 서버는 요청에 대한 결과를 만들어서 응답한다.   클라이언트와 서버를 분리한게 중요하다. 비즈니스 로직과 데이터는 서버에 처리하고, 클라이언트는 UI, 사용성에 집중한다. 이러한 설계 구조는 클라이언트와 서버가 각각 독립적으로 진화를 할 수 있다는 장점이 있다.      2. 무상태 프로토콜(stateless)   HTTP의 중요한 특징 중 하나는 무상태 프로토콜을 지향한다는 것이다.   무상태 프로토콜이란 특징 때문에 서버가 클라이언트의 상태를 보존하지 않으므로 서버 확장성이 높다는 장점이 있다. 무한한 서버 증설이 가능하므로 스케일 아웃에 유리하다. 따라서, 대용량 트래픽이 발생해도 서버를 많이 증설하여 대응할 수 있는 부분이 많아진다. 반면, (stateless 하기 때문에) 클라이언트가 추가적으로 보낼 데이터가 많다는 단점도 있다.   서버가 클라이언트의 상태를 보존하지 않는 형태로 설계하도록 노력해야 하고 상태를 유지해야 하는 경우엔 쿠키, 세션, 토큰과 같은 방법을 사용한다.   웹 애플리케이션 설계는 최대한 무상태로 설계하고 정말 어쩔수 없는 경우에 한해서 상태유지를 하도록 설계해야 한다.   비 연결성 (connectionless)   HTTP는 기본이 연결을 유지하지 않는 모델이다. 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않는다. 따라서, 서버의 자원을 효율적으로 관리하고 수 많은 클라이언트의 요청에 대응할 수 있게 한다.   하지만, 매번 TCP/IP 연결을 새로 맺어야 하므로 3 way handshake(SYN, SYN+ANK, ANK)에 대한 시간이 소요된다는 한계점도 가지고 있다. 이러한 한계점을 극복하기 위해 HTTP/2, HTTP/3에서는 HTTP 지속 연결(Persistent Connections)을 통해 최적화했다.         참고 비연결성 vs Stateless   비연결성은 TCP/IP 커넥션 연결을 지속하지 않는다 는 뜻이고 Stateless는 클라이언트와 서버 사이에 상태를 유지하지 않는다 는 뜻이다.        참고 클라이언트와 서버간의 연결 과정           브라우저에서 URL을 입력하고 엔터를 누른다.     DNS 서버에서 해당 URL의 아이피를 조회한다.     아이피에 해당하는 서버와 TCP 연결을 한다. 이때, 3 way handshake를 통해 연결한다.     이후 HTTP 요청/응답을 한다.          참고 TCP, HTTP   TCP의 특징으로 연결 지향이 있다. 그리고 HTTP를 사용하면 TCP도 사용하게 되는데 HTTP의 특징이 왜 비연결성일까? TCP의 연결지향과 HTTP의 비연결성은 결이 다르다. TCP의 연결지향적 특징으로 3 way handshake가 있는데 TCP는 UDP와 다르게 먼저 내가 요청 보낼 곳과 연결할 수 있는지를 체크하는 로직이 있다는 점에서 연결지향적이다.  반면, HTTP는 기본적으로 SOCKET 통신과 달리 요청과 응답을 받고 나면 연결을 끊고, 요청이 필요할 때마다 연결을 하는 비연결성을 보인다.     3. HTTP 메시지(⭐ 매우 중요)   HTTP 메시지는 start line, headers, blank line(공백), body(message body)로 구분된다.   HTTP 요청 메시지와 HTTP 응답 메시지의 start-line은 다르게 생겼다.   start-line(시작 라인)   HTTP 요청 메시지         start-line은 request-line이라고도 한다. request-line은 다음과 같게 작성한다.   1 **method** SP(공백) **request-target** SP **HTTP-version** CRLF(엔터)      HTTP 메서드(method)            종류: GET, POST, PUT, DELETE…       서버가 수행해야 할 동작 지정                    GET: 리소스 조회           POST: 요청 내역 처리                           요청 대상(request-target)            /search?q=hello&amp;hl=ko       absolute-path[?query] (절대경로[?쿼리])       절대경로 = “/” 로 시작하는 경로       참고: *, http://…?x=y와 같이 다른 유형의 경로지정 방법도 있다           HTTP Version(HTTP-version)            HTTP/1.1           HTTP 응답 메시지      start-line(시작 라인)      start-line = status-line   status-line = HTTP-version SP(공백) status-code SP reason-phrase CRLF(엔터)      HTTP 버전(HTTP-version)   HTTP 상태 코드(status-code)            요청 성공, 실패를 나타냄                    200: 성공           400: 클라이언트 요청 오류           500: 서버 내부 오류                           이유 문구(reason-phrase)            사람이 이해할 수 있는 짧은 상태 코드 설명 글           header 헤더   1 2 3 4 **field-name** \"**:**\" OWS **field-value** OWS (OWS: 띄어쓰기 허용)  # 예제 Host: www.google.com   HTTP 헤더 용도   HTTP 전송에 필요한 모든 부가 정보가 있다. (메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등) 필요 시 임의의 헤더도 추가 가능하다. (helloworld: hihi)   메시지 바디   실제 전송할 데이터가 있다. HTML 문서, 이미지, 영상 JSON 등등 byte로 표현할 수 있는 모든 데이터를 전송 할 수 있다.   4. 단순하고, 확장 가능   HTTP는 단순하다. HTTP 메시지도 매우 단순하다. 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술이다.  ","categories": ["HTTP"],
        "tags": ["HTTP","web"],
        "url": "/http/Web-HTTP/",
        "teaser": ""
      },{
        "title": "HTTP API",
        "excerpt":"HTTP API   API URI 설계   리소스   URI를 설계시 가장 중요한 것은 리소스 식별이다. 리소스란 동작을 제외한 자원 그 자체를 리소스라 한다.   리소스를 식별하는 방법은 리소스 자체에만 집중하여 리소스를 URI에 매핑한다.   예를 들어, 회원과 관련된 HTTP API를 만들어본다고 가정하면 회원이라는 개념 자체가 리소스이다.   그리고 회원 리소스를 식별하는 URI는 아래와 같다. 이렇게 URI를 작성하고 조회, 수정, 삭제를 구분할 때는 HTTP 메서드로 구분한다.      회원 목록 조회: /members   회원 조회: /members/{id}   회원 등록: /members   회원 수정: /members/{id}   회원 삭제: /members/{id}   리소스와 행위를 분리   가장 중요한 것은 리소스를 식별하는 것이다. 따라서, URI는 리소스만 식별한다. 즉, 리소스와 해당 리소스를 대상으로 하는 행위를 분리한 것이다. 회원으로 예를 들면 리소스는 회원이고 행위는 조회, 등록, 삭제, 변경이다. 앞에서도 말했듯이 행위는 HTTP 메서드로 구분한다. (GET, POST, PUT, PATCH, DELETE…)      참고   계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(member → members)        참고 Query String vs Path Variable   Query String: /members?id=123 Path Variable: /members/123 Query String과 Path Variable 둘 다 리소스를 식별하기 위해 사용한다. query는 주로 비계층 구조로 된 정보를 포함하고 path는 계층 구조로 된 정보를 포함한다. 관례적으로 리소스를 식별할 때는 path variable 처럼 사용하고 검색조건의 경우에 query string을 사용한다.     HTTP 메서드   HTTP 메서드 종류 중 주요 메서드는 GET, POST, PUT, PATCH, DELETE가 있다.   GET   GET은 리소스를 조회할 때 사용한다. 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달한다. 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다.   POST   POST는 요청 데이터를 처리할 때 주로 사용한다. 메시지 바디를 통해 서버로 요청 데이터 전달하면 서버가 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.   또한, 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용한다.   신규 리소스 등록   서버가 아직 식별하지 않은 새 리소스 생성한다.   프로세스 처리   단순히 데이터를 생성하거나 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우이다. 예를 들어 주문에서 ‘결제완료 -&gt; 배달시작 -&gt; 배달완료’처럼 단순히 상태 값 변경을 넘어 프로세스의 상태가 변경되는 경우에도 POST를 사용한다.   다른 메서드로 처리하기 애매한 경우   애매하면 POST를 사용하면 된다. 예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우      참고 GET과 POST의 차이점?   클라이언트에서 서버로 요청을 할 때, GET은 보통 (메시지 바디에) 데이터를 전달하지 않는다. 하지만, POST는 클라이언트에서 서버로 데이터를 전달하고 서버에게 처리해달라고 요청한다.        참고   Created(201)로 보낼 땐, 응답 데이터에 Location(신규 리소스 식별자)를 포함해 클라이언트에 전달한다.        참고 POST vs PATCH   POST를 사용하는 경우 중에서 프로세스를 처리할 때도 POST를 사용한다고 했다. 이때, 값이 변경되는 것이니 PATCH를 써도 되지 않나 하는 의문이 들었다. 그러나, 이 경우는 단순히 데이터를 생성, 변경하는 것을 넘어 내부에서 매우 큰 프로세스가 실행된다. 이렇게 해당 리소스만 변경하는것이 아닌 내부 프로세스를 실행해야 할 때는 PATCH 보다 POST를 사용하는 것이 좋다.     PUT   PUT은 리소스를 대체한다. 해당 리소스가 있으면 완전히 대체(주의)하고 없으면 생성한다. 쉽게 이야기 하면 덮어쓰기 한다.   POST와 PUT의 큰 차이점은 PUT은 클라이언트가 리소스를 식별한다는 것이다. POST는 클라이언트가 리소스의 위치를 모른다.(POST /members) 하지만, PUT은 클라이언트가 리소스 위치를 알고 URI 지정한다.(PUT /member/100)   PATCH   PATCH는 리소스를 부분 변경한다. 만약, PATCH를 지원하지 않는다면 POST를 사용하면 된다. (물론 요즘은 대부분 지원함)   DELETE   DELETE는 리소스를 삭제한다.      참고   리소스가 최근에는 Representation(표현)으로 변경되었다.     HTTP 메서드 종류 중 기타 메서드는 아래와 같다.      HEAD: GET과 동일하지만 메시지 부분을 제외하고 상태 줄과 헤더만 반환   OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)   CONNECT, TRACE도 있지만 거의 사용하지 않음   HTTP 메서드의 속성   안전(Safe Methods)   호출해도 리소스를 변경하지 않는다. GET의 경우가 이에 해당되고 POST, DELETE 등은 해당되지 않는다. (바뀌면 안전하지 않음)      참고   여기서 안전이란 단어의 관점은 리소스의 상태가 변경되냐 안되냐의 차이이다.     멱등(Idempotent Methods)   멱등이란 한 번 호출하든 두번 호출하든 100번 호출하든 결과가 똑같다는 뜻이다. 멱등 메서드에는 GET, PUT, DELETE가 해당된다. POST는 멱등이 아니다. (두 번 호출하면 같은 결제가 중복해서 발생할 수 있음)   멱등을 활용하는 경우는 자동 복구 메커니즘에서 사용한다. 예를 들어 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 부분을 판단하는 근거가 된다.   캐시가능(Cacheable Methods)   중요한 내용이다. 응답 결과 리소스를 캐시해서 사용해도 되는 메서드는 GET, HEAD, POST, PATCH 이다. 실제로는 GET, HEAD 정도만 캐시로 사용한다. POST, PATCH를 캐시해서 사용하지 않는 이유는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않기 때문이다.      참고   캐시를 이해하는 중요한 키는 데이터의 변경 관점이다. 캐시는 원본 데이터가 변경되지 않고 유지되어야 하는데 POST, PUT, DELETE, PATCH로 데이터를 변경하게 되면 원본 데이터가 변경되기 때문에 캐시를 유지하기가 어렵다. 따라서, 데이터를 변경할 가능성이 있는 POST, PUT, DELETE, PATCH는 대부분의 구현에서 캐시를 유지하지 않는다.     클라이언트에서 서버로 데이터 전송   정적 데이터 조회   이미지, 정적 텍스트 문서를 전송한다. GET을 사용하여 조회하며 쿼리 파라미터를 사용하지 않는다. 정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회할 수 있다.   동적 데이터 조회   쿼리 파라미터(?q=hello&amp;hl=ko) 사용하여 데이터를 전달하고 조회한다. 주로 검색, 게시판 목록에서 정렬 필터(검색어)에서 사용한다.   HTML Form 데이터 전송   HTML Form 데이터 전송에는 POST 전송, GET 전송, multipart/form-data 3가지가 있다.   POST 전송 - 저장   주로 회원 가입, 상품 주문 등에서 사용한다. (Content-Type: application/x-www-form-urlencoded) form의 내용을 메시지 바디를 통해서 전송한다. (key=value 형식, 쿼리 파라미터 형식) 이때, 전송 데이터를 url encoding 처리한다. (예. abc김 -&gt; abc%EA%B9%80)      참고 인코딩하는 이유?   웹 브라우저와 웹 서버는 서로 다른 인코딩 방식을 가지므로 적절한 인코딩 설정이 필요하다.     GET 전송 - 저장   GET 방식으로 form 데이터를 전송하면 URL이 쿼리 파라미터 형식으로 서버에 들어온다. 단, form 데이터를 사용할 때 GET은 조회에만 사용해야 한다. 리소스 변경(저장 등)이 발생하는 곳에서 사용하면 안된다.   multipart/form-data   파일 업로드 같은 바이너리 데이터 전송시 사용한다. 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능하다. (Content-Type: multipart/form-data)      참고   HTML Form 전송은 GET, POST만 지원한다.     HTTP API 데이터 전송   HTTP API 데이터 전송은 서버 to 서버(백엔드 시스템 통신), 앱 클라이언트(아이폰, 안드로이드), 웹 클라이언트(ajax, React, Vue 같은 웹 클라이언트와 API 통신)에서 사용한다. Content-Type: application/json을 주로 사용한다. (사실상 표준)   GET은 조회, 쿼리 파라미터로 데이터 전달하고 POST, PUT, PATCH는 메시지 바디를 통해 데이터를 전송한다.   HTTP API 설계 예시   HTTP API 설계에는 컬렉션을 사용하는 POST 기반 등록, 스토어를 사용하는 PUT 기반 등록, 컨트롤 URI를 사용하는 HTML FORM 기반 등록 방법이 있다.   POST 기반 등록      회원 목록 /members → GET   회원 등록 /members → POST   회원 조회 /members/{id} → GET   회원 수정 /members/{id} → PATCH(default), PUT(게시글을 수정할 때), POST   회원 삭제 /members/{id} → DELETE   POST로 신규 자원을 등록할 때의 특징은 클라이언트는 등록될 리소스의 URI를 모른다는 것이다. 서버가 데이터를 저장하고 새로 등록된 리소스 URI를 생성해준다. 즉, 응답메시지에 식별자를 Location에 담아(Location: /members/100) 클라이언트에 전달한다.   이런 형식을  컬렉션(Collection)이라 한다. 즉, 서버가 관리하는 리소스 디렉토리에 서버가 리소스의 URI를 생성하고 관리하는 것이다. 여기서 컬렉션은 /members이다.   PUT 기반 등록      파일 목록 /files → GET   파일 조회 /files/{filename} → GET   파일 등록 /files/{filename} → PUT(파일 업로드의 경우엔 PUT이 딱 맞다. 없으면 생성해야 하고 있으면 더덮어쓰기 해야하므로..)   파일 삭제 /files/{filename} → DELETE   파일 대량 등록 /files → POST   PUT로 신규 자원을 등록할때의 특징은 클라이언트가 리소스 URI를 알고 있어야 한다. 즉, 클라이언트가 직접 리소스의 URI를 지정한다.   이런 형식을 스토어(Store)라 한다. 즉, 클라이언트가 관리하는 리소스 저장소에 클라이언트가 리소스의 URI를 알고 관리하는 것이다. 여기서 스토어는 /files이다.      중요 POST, PUT 기반 신규 자원 등록의 차이점   API를 설계할때 크게 두가지로 분류할 수 있다.  첫번째가 POST 기반의 등록을 하는 것이고 컬렉션이라 하고 두번째는 PUT 기반의 등록을 하는 것이고 스토어라 한다. 이 둘의 차이점은 서버가 리소스 관리를 하는지(컬렉션), 클라이언트가 리소스 관리를 하는지(스토어)의 차이이다. 대부분 컬렉션을 사용하고 파일 업로드 같은 경우엔 스토어를 사용하기도 한다.     HTML FORM 사용      회원 목록 /members →  GET   회원 등록 폼 /members/new → GET   회원 등록 /members/new, /members → POST   회원 조회 /members/{id} → GET   회원 수정 폼 /members/{id}/edit → GET   회원 수정 /members/{id}/edit, /members/{id} → POST   회원 삭제 /members/{id}/delete → POST   HTML FORM은 GET, POST만 지원한다. AJAX 같은 기술을 사용해서 해결 가능(회원 API 참고)하지만 여기서는 순수 HTML, HTML FORM 이야기를 하겠다.   HTML FORM은 GET, POST만 지원하므로 제약이 있다. 이를 해결하기 위해 컨트롤 URI를 사용한다. 컨트롤 URI는 /new, /edit, /delete와 같이 동사로 된 리소스 경로를 사용한다. HTTP 메서드로 해결하기 애매한 경우에 사용한다. (HTTP API 포함)      참고 컨트롤 URI   URI를 리소스만 가지고 설계하기 힘들 때 URI에 동사를 넣어 설계하는 것을 컨트롤 URI라 한다. 실무에서 정말 많이 사용된다. 하지만, 최대한 리소스란 개념을 가지고 설계하고 그 상황에서 안될 때 대체제로 컨트롤 URI를 사용한다고 이해하자.    ","categories": ["HTTP"],
        "tags": ["HTTP","web"],
        "url": "/http/Web-HTTPAPI/",
        "teaser": ""
      },{
        "title": "시간 복잡도와 공간 복잡도",
        "excerpt":"알고리즘 평가할 때 시간 복잡도와 공간 복잡도를 사용함      시간 복잡도: 알고리즘의 수행시간을 평가   공간 복잡도: 알고리즘 수행에 필요한 메모리 양을 평가       시간 복잡도   시간 복잡도는 알고리즘의 수행시간을 나타냄.   시간 복잡도를 낮출 수 있다면 프로그램에 큰 성능 향상을 기대할 수 있음       O(1) - 상수 시간   입력 크기(N)에 상관없이 일정한 연산을 수행       O(logN) - 로그 시간   입력 크기(N)가 커질 때 연산 횟수가 logN에 비례해서 증가   1 for (i=1; i&lt;=n; i*2) {}       O(n) - 선형 시간   입력 크기(n)가 커질 때 연산 횟수가 n에 비례해서 증가하면 시간 복잡도는 O(n).      연산횟수가 선형적으로 증가하는 형태   1 for (i=0; i&lt;n; i++) {}       O(N^2) - 2차 시간   입력 크기(n)가 커질 때 연산 횟수가 n^2에 비례해서 증가   예) 중첩 for문…       O(2^N) - 지수 시간   입력 크기가 커질 때 연산수가 2^N에 비례해서 증가   예) 피보나치 수열…              파이썬 주요 함수, 메소드의 시간 복잡도   list                  Operation       Example       Big-O       Notes                       Index       l[i]       O(1)                         Store       l[i] = 0       O(1)                         Length       len(l)       O(1)                         Append       l.append(5)       O(1)                         Pop       l.pop()       O(1)       l.pop(-1) 과 동일                 Clear       l.clear()       O(1)       l = [] 과 유사                 Slice       l[a:b]       O(b-a)       l[:] : O(len(l)-0) = O(N)                 Extend       l.extend(…)       O(len(…))       확장 길이에 따라                 Construction       list(…)       O(len(…))       요소 길이에 따라                 check ==, ≠       l1 == l2       O(N)       비교                 Insert       l.insert(i, v)       O(N)       i 위치에 v를 추가                 Delete       del l[i]       O(N)                         Remove       l.remove(…)       O(N)                         Containment       x in/not in l       O(N)       검색                 Copy       l.copy()       O(N)       l[:] 과 동일 - O(N)                 Pop       l.pop(i)       O(N)       l.pop(0):O(N)                 Extreme value       min(l)/max(l)       O(N)       검색                 Reverse       l.reverse()       O(N)       그대로 반대로                 Interation       for v in l:       O(N)                         Sort       l.sort()       O(N Log N)                         Multiply       k*l       O(k N)       [1,2,3] * 3 » O(N**2)               Dict                  Operation       Example       Big-O       Notes                       Index       d[k]       O(1)                         Store       d[k] = v       O(1)                         Length       len(d)       O(1)                         Delete       del d[k]       O(1)                         get/setdefault       d.method       O(1)                         Pop       d.pop(k)       O(1)                         Pop item       d.popitem()       O(1)                         Clear       d.clear()       O(1)       s = {} or = dict() 유사                 View       d.keys()       O(1)       d.values() 동일                 Construction       dict(…)       O(len(…))                         Iteration       for k in d:       O(N)                       공간 복잡도   공간 복잡도는 알고리즘에서 사용하는 메모리 양을 나타냄.   공간 복잡도는 보조공간과 입력 공간을 합친 포괄적인 개념. 보조 공간은 알고리즘이 실행되는 동안 사용하는 임시 공간  ","categories": ["Python","Algorithm"],
        "tags": ["Algorithm","Python"],
        "url": "/python/algorithm/Python-Time-Complexity/",
        "teaser": ""
      },{
        "title": "JVM(Java Virtual Machine)",
        "excerpt":"JVM(Java Virtual Machine)이란?   직역하면 자바를 실행하기 위한 가상 기계(컴퓨터)   자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하면서 프로그램 메모리를 관리하고 최적화하는 것       자바프로그램 실행과정      원시코드(*.java)는 CPU가 인식하지 못하므로 기계어로 컴파일을 해줘야함.   원시코드(.java)는 JVM이 인식할 수 있는 Java Bytecode(.class)로 변환됨. (Java compiler가 변환해줌)          참고 Java compiler란?   JDK를 설치하면 bin에 존재하는 javac.exe를 말함 (즉, JDK에 Java compiler가 포함되어 있음) javac 명령어를 통해 .java를 .class로 컴파일 할 수 있음         변환된 bytecode는 기계어가 아니기 때문에 OS에서 바로 실행되지 않음.   이때, JVM이 OS가 bytecode를 이해할 수 있도록 해석해준다. 따라서, Byte Code는 JVM 위에서 OS 상관없이 실행될 수 있는 것.   OS에 종속적이지 않고, Java 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행할 수 있음.       컴파일 하는 방법   Java Compiler는 JDK를 설치하면 javac.exe라는 실행 파일 형태로 설치됨. (경로: *jdk/bin/javac.exe)   Java Compiler의 javac라는 명령어를 사용하면 .class파일을 생성할 수 있음.   1 javac test.java       실행하는 방법   java 명령어로 .class 파일을 실행 시킬 수 있음.   1 java test(.class 파일 이름)          참고   JDK 디렉토리의 /bin 폴더에 존재하는 java.exe는 JVM을 구동시키기 위한 명령 프로그램(JRE) java 명령어로 JVM을 실행 시킬 수 있음         바이트 코드란?   가상 컴퓨터(VM)에서 돌아가는 실행 프로그램을 위한 이진 표현법   자바 바이트코드는 JVM이 이해할 수 있는 언어로 변환된 자바 소스코드를 의미함   바이트 코드는 다시 실시간 번역기 or JLT 컴파일러에 의해 바이너리 코드로 변환된다.       즉, CPU가 이해하는 언어는 바이너리 코드, 가상 머신이 이해하는 코드는 바이트 코드       지금까지 내용을 정리하면,       자바 코드를 컴파일하여 .class 바이트 코드로 만들면 이 코드가 자바 가상 머신 환경에서 실행 됨. JVM은 자바 실행 환경 JRE에 포함되어 있음. 현재 사용하는 컴퓨터의 운영체제에 맞는 자바 실행환경(JRE, Java Runtime Environment)가 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻      Java는 컴파일된 바이트 코드로 어떤 JVM에서도 동작시킬 수 있기 때문에 플랫폼에 의존적이지 않지만, JVM은 플랫폼에 의존적. 즉, 리눅스 JVM과 윈도우의 JVM은 서로 다르다.       바이트 코드를 읽는 방식   JVM은 바이트코드를 명령어 단위로 읽어서 해석하는데, Interpreter 방식과 JIT 컴파일 방식 두가지 방식을 혼합해서 사용함.   Interpreter 방식은 바이트코드를 한 줄씩 해석, 실행하는 방식이며 초기 방식으로 속도가 느리다는 단점이 있다. 이를 보완하기 위해 나온 것이 JIT(Just In Time) 컴파일 방식.   JIT(Just In Time) 컴파일 방식은 바이트코드를 JIT 컴파일러를 이용해 프로그램을 실제 실행하는 시점에 각 OS에 맞는 Native Code로 변환하여 실행 속도를 개선함. 하지만, 바이트코드를 Native Code로 변환하는 데에도 비용이 소요되므로, JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고, 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일 방식으로 명령어를 실행함.       JIT 컴파일러란?   JIT 컴파일러는 바이트 코드를 읽는 방식 중 하나인 인터프리터 방식의 속도가 느리다는 점을 보완한 방식. 같은 코드를 매번 해석하지 않고, 실행할 때 컴파일을 하면서 해당 코드를 캐싱해버림. 이후에는 바뀐 부분만 컴파일하고, 나머지는 캐싱된 코드를 사용함.       자바에선 자바 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음, 실제 바이트 코드를 실행하는 시점에서 자바 가상 머신(JVM, 정확히는 JRE)이 바이트 코드를 JIT 컴파일을 통해 기계어로 변환       가비지 컬렉션 (Garbage Collection, GC)   JRE의 구성 요소 중 하나. 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했지만 Java에서는 JVM이 프로그램 메모리를 관리함. 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제함          참고 JDK와 JRE 차이?   JDK(Java Development kit, 자바 개발 키트)   자바를 사용하기 위해 필요한 모든 기능을 갖춘 Java용 SDK(Software Development Kit). JDK는 JRE를 포함하고 있다. 즉, JDK는 프로그램을 생성, 실행, 컴파일 할 수 있음   JRE(Java Runtime Environment, 자바 런타임 환경)   JVM + 자바 클래스 라이브러리 등으로 구성되어 있으며, 컴파일 된 Java 프로그램을 실행하는데 필요한 패키지         JVM의 메모리 구조   위의 내용을 다시 정리하자면, JVM이란 Java Virtual Machine의 약자로, 자바 가상 머신이라고 부름. 자바와 운영체제 사이에서 중개자 역할을 수행하며, 자바가 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와준다. 또한, 가비지 컬렉터(GC)를 사용한 메모리 관리도 자동으로 수행하며, 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작함.       JVM의 구조      Garbage Collector   Execution Engine   Class Loader   Runtime Data Area          자바 소스 파일은 자바 컴파일러에 의해서 바이트 코드 형태인 클래스 파일이 되고 이 클래스 파일은 클래스 로더가 읽어들이면서 JVM이 수행됨       Class Loader   .java 소스를 자바컴파일러가 컴파일하면 .class(바이트코드)이 생성되는데 이렇게 생성된 클래스파일들을 엮어서 JVM이 운영체제로부터 할당받은 메모리영역인 Runtime Data Area로 적재하는 역할을 Class Loader가 함. (자바 애플리케이션이 실행중일 때 이런 작업 수행)       Execution Engine   클래스 로더를 통해 JVM 내에 Runtime Data Area에 배치된 바이트 코드들을 기계어로 변경해 명령어 단위로 읽어서 실행하는 역할을 한다.   최초 JVM이 나왔을 당시에는 인터프리터 방식이었기때문에 속도가 느리다는 단점이 있었다. 하지만 이를 JIT 컴파일러 방식을 통해 보완함. JIT는 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿈으로써 실행이 빠르지만 변환하는데 비용이 발생함. 이 같은 이유로 JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고, 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행함       Garbage Collector(GC)   GC는 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할을 한다.   GC가 역할을 하는 시간은 언제인지 정확히 알 수 없다. (참조가 없어지자마자 해제되는 것을 보장하지 않음)       Runtime Data Area   JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있음.               Method Area       모든 쓰레드가 공유하는 메모리 영역. 메소드 영역은 클래스, 인터페이스, 메소드, 필드, Static 변수 등이 생성되는 영역.            Heap Area       모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역. 또한, 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역.            Stack Area              메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성한다. 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장함. 마지막으로, 메서드 수행이 끝나면 프레임별로 삭제한다.            PC Register       쓰레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 쓰레드마다 하나씩 존재함. 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다.            Native Method Stack       자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역           쓰레드가 생성되었을 때 기준으로1,2번인 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고,3,4,5번인 스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않는다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-JVM/",
        "teaser": ""
      },{
        "title": "서블릿",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   서블릿   서블릿이란 Dynamic Web Page를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술이다. 웹을 만들때는 다양한 요청(request)과 응답(response)이 있고 규칙이 존재하는데 이러한 요청과 응답을 일일이 처리하기 힘들다. 서블릿은 이러한 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술이다.   서블릿을 사용하지 않으면 아래의 리스트를 모두 구현해야 한다. 하지만, 서블릿을 지원하는 WAS를 사용하면 초록색 박스안의 내용만 구현하면 된다.      서블릿 사용예제   1 2 3 4 5 6 7 8 @WebServlet(name = \"helloServelt\", urlPatterns = \"/hello\") public class HelloServlet extends HttpServlet {      @Override     protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         ...     } }      @WebServlet            name: 서블릿 이름       urlPatterns: URL 매핑           protected void service(HttpServletRequest request, HttpServletResponse response)            HTTP 요청을 통해 매핑된 URL이 호출되면 서블릿 컨테이너는 service() 메서드를 실행한다.           서블릿 특징      urlPatterns의 URL이 호출되면 서블릿 코드가 실행된다.   HTTP 요청, 응답 정보를 편리하게 사용할 수 있는 HttpServletRequest와 HttpServletResponse를 제공한다.   개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있다.   서블릿 HTTP 요청, 응답 흐름   클라이언트에서 URL 요청이 들어오면 WAS는 Request, Response 객체를 생성하고 서블릿 객체를 호출한다. 개발자는 Reqeust 객체에서 HTTP 요청 정보를 꺼내서 사용하고 Response 객체에서 HTTP 응답 정보를 편리하게 입력한다. WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성하여 클라이언트에 전달한다.         참고 서블릿 객체의 생성 시점   서버 설정에 따라 다르다. 로딩 시점에 생성할 수도 있고 최초 요청 시점에 생성할 수도 있다.     서블릿 컨테이너   서블릿 컨테이너란 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다. 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리하는데 이때 싱글톤으로 관리한다.   고객의 요청이 올 때 마다 객체를 생성하는 것은 비효율적이므로 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용한다. 모든 고객의 요청은 동일한 서블릿 객체 인스턴스에 접근하며 서블릿 컨테이너 종료 시 함께 종료한다. 이때, 공유 변수 사용에 주의해야한다.   JSP도 서블릿으로 변환되어서 사용하며 동시 요청을 위한 멀티 쓰레드 처리를 지원한다.      참고 싱글톤 패턴   싱글톤 패턴은 객체를 딱 하나만 생성하여 생성된 객체를 프로그램 어디에서나 접근하여 사용할 수 있도록 하는 패턴을 말한다. 개발을 하다보면 전역적으로 하나의 객체만을 사용해야 하는 경우가 있는데 이때 싱글톤 패턴을 사용하면 객체 생성을 단 한번으로 제한하여 객체들이 복제되는 경우를 방지할 수 있고 클래스를 사용하는 여러 곳에서 인스턴스를 계속 생성하여 불필요하게 메모리 낭비를 유발할 수 있다고 판단되는 경우에도 싱글톤 패턴을 사용한다.        참고 서블릿과 싱글톤   /hello 를 처리하는 HelloServlet, /spring을 처리하는 SpringServlet이 각각 존재한다면 HelloServlet, SpringServlet를 매번 요청이 올 때마다 새롭게 만들어줄 필요 없이 한 번만 생성한 뒤 이미 생성된 것을 사용하면 된다. 여기서 언급된 싱글톤은 HelloServlet, SpringServlet을 각각 하나만 존재하도록 하는 것이다.        참고 스프링 컨테이너와 서블릿 컨테이너의 관계   서로가 어디에 포함된다고 보기보단 스프링 빈을 관리하는 스프링 컨테이너와 서블릿을 관리하는 서블릿 컨테이너가 각자의 목적에 맞게 별도의 컨테이너로 존재한다.             참고   request 객체를 만들어서 서블릿에 넘겨주는 것이 서블릿 컨테이너의 역할이며 response도 마찬가지로 서블릿 컨테이너가 한다. 서블릿 컨테이너가 서블릿을 호출해준다. 서블릿은 service() 로직을 수행하는 싱글톤 객체라고 이해해도 된다.        참고 서블릿 컨테이너 흐름           서블릿 컨테이너가 서블릿 객체를 생성 (서블릿의 생성시점은 서버 설정에 따라 다름)     클라이언트가 해당 서블릿을 사용하는 HTTP 요청을 하면, 서블릿 컨테이너에서 request, response 객체를 생성     이때, 쓰레드가 서블릿 객체를 호출하고 request, response 객체를 서블릿 객체에 넘겨줌     request 객체를 활용해 서블릿의 비즈니스 로직 실행     응답 결과를 response 객체에 담은 후, 서블릿 컨테이너에 전달     서블릿 컨테이너가 HTTP 응답 메시지 생성 후 클라이언트에게 전달      ","categories": ["Spring"],
        "tags": ["Spring","Java"],
        "url": "/spring/Spring-Servlet/",
        "teaser": ""
      },{
        "title": "스레드와 스레드 풀",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   스레드   스레드란 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것      애플리케이션 코드를 하나하나 순차적으로 실행하는 것   자바 메인 메서드를 처음 실행하면 main이라는 이름의 스레드가 실행   스레드가 없다면 자바 애플리케이션 실행이 불가능함   스레드는 한번에 하나의 코드 라인만 수행   동시 처리가 필요하면 스레드를 추가로 생성      참고     클라이언트에서 요청이 들어온 경우 WAS와 연결을 해주는 역할을 TCP/IP 에서 해준다.     TCP/IP를 통해 요청한 주소를 통해 WAS와 연결이 되고 연결된 요청을 WAS에서 스레드를 사용하여 적절한 Servlet으로 처리를 해준다.     요청마다 하나의 스레드를 생성한다고 가정하면,   동시 요청을 처리할 수 있고, 하나의 스레드가 지연되도 나머지 스레드는 정상 동작한다는 장점이 있다.   그러나, 스레드는 생성 비용이 매우 비싸고 요청마다 하나의 스레드를 생성하면 응답 속도가 늦어진다. 또한, 스레드는 컨텍스트 스위칭 비용이 발생한다. 컨텍스트 스위칭 비용이란 스레드를 전환할때 발생하는 비용을 말하는데 스레드가 너무 많으면 문제가 생긴다. 스레드 생성 시 CPU, 메모리가 사용되는데 그 임계점을 넘어서 서버가 죽을 수도 있다.   이러한 단점들은 보완한 것이 스레드 풀이다.      참고 멀티 스레드에서의 동시 요청과 다수 서버로 운영되는 어플리케이션에서의 동시 요청은 같은 맥락이 아니다. 멀티 스레드는 하나의 서버 안에서 발생하는 것을 전제로 얘기한다. 여러 대의 서버로 구성된 서비스가 동시 요청을 처리하는 건 로드 밸런서라는 키워드가 있다.     스레드 풀   스레드 풀에 필요한 스레드를 보관하고 관리하며 스레드 풀에 생성 가능한 스레드의 최대치를 관리한다. (톰캣의 경우 최대 200개)   스레드가 필요하면 스레드 풀에 이미 생성되어 있는 스레드를 꺼내서 사용하고 사용을 종료하면 스레드 풀에 해당 스레드를 반납한다. 만약, 최대 스레드가 모두 사용중이여서 스레드 풀에 스레드가 없다면 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정 할 수 있다.   스레드 풀의 장점은 스레드가 미리 생성되어 있으므로, 스레드를 생성하고 종료하는 비용이 절약되고 응답 시간이 빠르다. 또한, 생성 가능한 스레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.      스레드 풀과 관련된 실무팁   WAS의 주요 튜닝 포인트는 최대 스레드(max thread) 수이다. max thread를 낮게 설정 시 동시 요청이 많으면 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연된다. max thread를 높게 설정 시 동시 요청이 많으면 CPU, 메모리 리소스 임계점 초과로 서버가 다운된다.   그럼 스레드 풀의 적정 숫자가 뭘까? 이에 대한 정답은 없다. 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다르다. 적정 숫자를 찾을 방법은 최대한 실제 서비스와 유사하게 환경을 구성 후 성능 테스트를 시도하는 것이다. 관련 툴로는 아파치 ab, 제이미터, nGrinder가 있다.   장애가 발생했다고 가정하고, 클라우드면 일단 서버부터 증설하고 이후에 튜닝을 하고 클라우드가 아니면 열심히 튜닝..해야 한다.      참고 스레드 풀을 사용해도 컨텍스트 스위칭 비용이 발생한다. 그러나, 무한정 늘어나지 않으니 컨텍스트 스위칭 비용도 무한정 늘어나지 않는다.        참고 서버가 다운되었을 경우 우선 점검 페이지로 요청을 돌린다. 그 후 다운되는 원인을 찾는다. 다운되는 원인은 connection pool timeout, memory leak 등 여러 이유가 있다. 모니터링 툴을 통해 원인을 찾아낼 수도 있고, 힙 덤프를 떠서 살펴보는 방법도 있다. 코드 레벨에서 해결할 수 있는 문제는 조치 후 운영하면 되고 물리적인 문제라면 서버 증설을 빠르게 진행한다.        참고 AWS의 AutoScaling AWS에는 AutoScaling이란 기능이 있어 요청이 증가할 때 자동으로 인스턴스를 생성하여 늘어나는 요청에 대응할 수 있다. 하지만, 순간적으로 요청이 폭발적으로 증가하는 경우에는 대응하기 어려울 수 있다. 인스턴스가 생성되는 시간이 필요하기 때문!. 예측할 수 있는 이벤트의 경우 미리 인스턴스를 확보하여 늘어나는 요청에 대응하기도 한다.        참고 톰캣 스레드와 JPA에서 사용하는 스레드 스레드는 어떠한 프로그램, 프로세스 내에서 실행되는 하나의 흐름을 의미한다. 톰캣은 웹서버로써 고객의 HTTP 요청을 처리하는 프로세스를 담당하며 이를 효율적으로 처리하기 위한 스레드풀을 운영한다. JPA도 하나의 프로세스로 스프링 컨테이너와 DB 사이에서의 중계자 역할을 맡고 있다. JPA 또한 업무 효율을 위한 스레드풀을 별도로 운영한다. (보통 HikariPool 이라고 하는 스레드풀 라이브러리를 사용한다.) 이 둘의 스레드는 별도로 관리되기에 서로 영향을 미치지 않는다. 단, 어떤 HTTP 요청이 많은 DB 조회를 요구한다면 톰캣의 스레드 1개와 JPA 스레드 여러개를 차지할 수 있다.    ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-Thread/",
        "teaser": ""
      },{
        "title": "SSR, CSR",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   서버 사이드 렌더링, 클라이언트 사이드 렌더링은 각각 서버와 클라이언트가 웹 페이지를 렌더링하는 기술을 의미한다.   서버 사이드 렌더링(SSR)   SSR은 서버에서 사용자에게 보여줄 페이지를 모두 구성해 보여주는 방식이다. 즉, HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달한다. 주로 정적인 화면에서 사용하고 관련 기술로는 JSP, 타임리프가 있다. SSR을 쓰면 모든 데이터가 매핑된 서비스 페이지를 클라이언트에 바로 보여줄 수 있다. 서버를 이용해 페이지를 구성하기 때문에 CSR보다 페이지 구성 속도는 느리지만 전체적으로 사용자에게 보여주는 컨텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있다.      클라이언트 사이드 렌더링(CSR)   CSR은 사용자의 행동에 따라 필요한 부분만 다시 읽어들이기 때문에 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있다. 서버는 단지 JSON파일만 보내주고 html을 그리는 역할은 자바스크립트를 통해 클라이언트 측에서 수행한다. 주로 동적인 화면에 사용하며 웹 환경을 마치 앱처럼 필요한 부분부분 변경할 수 있다. 관련 기술로는 React, Vue.js가 있다.      참고로 React, Vue.js를 CSR+SSR 동시에 지원하는 웹 프레임워크가 있다. 또한, SSR을 사용하더라도 자바스크립트를 사용해서 화면 일부를 동적으로 변경할 수 있다.   백엔드 개발자 입장에선 서버 사이드 렌더링(SSR) 기술을 학습하는 것은 필수이지만, CSR 기술(React, Vue.js 등) 학습은 옵션이다. 백엔드 개발자는 서버, DB, 인프라 등 수 많은 백엔드 기술을 학습해야 한다. 선택과 집중을 해야한다.  ","categories": ["HTTP"],
        "tags": ["HTTP","Spring"],
        "url": "/http/Web-SSR-CSR/",
        "teaser": ""
      },{
        "title": "웹 서버와 WAS",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   웹 서버(Web Server, WS)   웹 서버는 HTTP 기반으로 동작하며 정적 리소스를 제공한다. 정적 리소스에는 정적 html, css ,js, 이미지, 영상 등이 있다. nginx, apache가 웹 서버에 해당한다.   웹 어플리케이션 서버(WAS)   WAS는 HTTP 기반으로 동작하며 웹 서버 기능(정적 리소스 제공)도 제공할 수 있고 애플리케이션 로직도 수행한다. tomcat 등이 WAS에 해당된다.   웹 서버와 WAS의 차이점   사실 둘의 경계는 모호하다. 웹 서버도 프로그램을 실행하는 기능을 포함하기도 하고 WAS도 웹 서버의 기능을 제공한다. 차이점을 말하자면 웹 서버는 정적 리소스를 제공하는것에 특화되어있고, WAS는 애플리케이션 로직을 수행하는데 더 특화되어있다. 즉, 웹 서버 없이 WAS에서 모든 처리를 해결할 수 있으며, WAS 없이 WS 만으로 정적 웹을 만드는 것도 가능하다.   웹 서버와 WAS를 분리할 경우 장점   우선, 효율적인 리소스 관리가 가능하다. 정적 리소스가 많이 사용되면 웹 서버를 증설하고, 애플리케이션 리소스가 많이 사용되면 WAS를 증설한다.   또한, 정적 리소스를 제공하는 웹 서버의 경우엔 장애가 자주 발생하지 않는 반면, 애플리케이션 로직이 동작하는 WAS의 경우는 개발자의 로직 실수 등으로 장애가 자주 발생한다. 이처럼 WAS, DB 장애 시 웹 서버에서 오류 화면을 제공할 수 있어 사용자의 혼란을 줄일 수 있다.      참고    API 서버만 제공한다면 웹 서버는 구축하지 않아도 된다. 비용 측면에서 정적 리소스 보다 애플리케이션 로직이 더 비싸다.    ","categories": ["HTTP"],
        "tags": ["Spring","HTTP"],
        "url": "/http/Web-WebServer-WAS/",
        "teaser": ""
      },{
        "title": "구 MVC 패턴과 프론트 컨트롤러",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   구 MVC 패턴의 한계   MVC 패턴을 적용해 컨트롤러의 역할과 뷰 렌더링하는 역할을 구분하였지만 중복이 많고 필요하지 않은 코드가 많다.   포워드 중복   View로 이동하는 코드가 항상 중복 호출된다.   1 2 RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response);   ViewPath 중복   유지보수가 어렵다. JSP가 아닌 thymeleaf 같은 다른 뷰로 변경 시 전체 코드를 변경해야 한다.   1 String viewPath = \"/WEB-INF/views/new-form.jsp\";   사용하지 않는 코드   아래의 코드를 사용하지 않을 때도 있다.   1 HttpServletRequest request, HttpServletResponse response   공통 처리 어려움   단순히 공통 기능을 메서드로 뽑아도 결국 메서드를 항상 호출해야되고 실수로 호출하지 않으면 문제가 된다. 또한, 호출하는 것 자체도 중복이다.   이러한 한계점들은 프론트 컨트롤러 패턴을 도입하여 문제 해결이 가능하다.   프론트 컨트롤러 패턴   프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받으면 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출해준다. 즉, 입구를 하나로 만들어 공통 처리가 가능해져 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 된다. 스프링 MVC의 핵심이 바로 프론트 컨트롤러이다.      프론트 컨트롤러 패턴 특징      프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받는다.   프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출한다.   입구가 하나이므로 공통 처리가 가능하다.   프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 된다.   스프링 웹 MVC의 핵심이 FrontController이고 스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현되어 있다.      핸들러 어댑터   핸들러 어댑터는 어댑터 역할을 해주어 다양한 종류의 컨트롤러를 호출 가능하다.   프론트 컨트롤러에 어댑터 패턴을 사용하면 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경할 수 있다. FrontController와 컨트롤러 사이에 핸들러 어댑터를 둔다.   핸들러   컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 어댑터가 있기 때문에 컨트롤러 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 처리가 가능하다. (핸들러와 컨트롤러는 같은 의미지만 핸들러가 더 넓은 범위에 속한다)  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-MVCPattern-FrontController/",
        "teaser": ""
      },{
        "title": "MVC 패턴",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   서블릿과 JSP의 한계   서블릿으로 개발을 하면 뷰 화면을 위해 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡하다. 이를 개선하기 위해 등장한 것이 JSP이다. JSP를 통해 자바에서 HTML을 사용하는 것이 아니라 HTML 코드 내에 중요한 부분에만 자바 코드를 써서 간결하게 작성할 수 있다.   JSP를 사용하면서 HTML 작업이 깔끔해졌지만 자바 코드, 데이터를 조회하는 리포지토리 등이 JSP에 노출된다는 단점이 있다. (JSP가 너무 많은 역할을 한다) → 유지보수 지옥      참고 JSP   정적인 HTML이 아닌 서버(자바)로부터 데이터를 받아와 동적으로 화면이 그려지는 템플릿 엔진이다.     서블릿 - 컨트롤러, JSP - 뷰   MVC 패턴 개요   하나의 서블릿, JSP 만으로 비즈니스 로직과 뷰 렌더링을 모두 처리하게 되면 너무 많은 역할을 하게 된다. 이부분은 향후 유지보수를 진행하게 되었을 때 문제가 많이 생긴다.   UI를 수정하는 일과 비즈니스 로직을 수정하는 일은 변경의 라이프 사이클이 다르다. 때문에 수정 시 각각 다르게 발생할 가능성이 매우 높고 대부분 서로에게 영향을 주지 않는다. 변경의 라이프 사이클이 다른 부분을 하나의 코드로 관리하는 것은 유지보수하기 좋지 않다.   결과적으로, JSP 같은 뷰 템플릿은 화면을 렌더링 하는데 최적화 되어 있기 때문에 이 부분에 대한 업무만 담당하는 것이 효과적이다.   이러한 부분들을 개선하기 위해 등장한 것이 MVC 패턴이다.   MVC 패턴은 하나의 서블릿이나 JSP로 처리하던 것을 컨트롤러와 뷰라는 영역으로 서로 역할을 나눈 것을 의미한다. 웹 애플리케이션은 보통 이 MVC 패턴을 사용한다.      컨트롤러: HTTP 요청을 받아서 파라미터를 검증, 비즈니스 로직을 실행함. 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다   모델: 뷰에 출력할 데이터를 담아둠. 뷰가 필요한 데이터를 모두 모델에 담아서 전달. 따라서, 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고 화면을 렌더링 하는 일에 집중함   뷰: 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중 (HTML 생성)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @WebServlet(name = \"mvcMemberListServlet\", urlPatterns = \"/servlet-mvc/members\") public class MvcMemberListServlet extends HttpServlet {      private MemberRepository memberRepository = MemberRepository.getInstance();      @Override     protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {          List&lt;Member&gt; members = memberRepository.findAll();          request.setAttribute(\"members\", members);          String viewPath = \"/WEB-INF/views/members.jsp\";         RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);         dispatcher.forward(request, response);     } }      참고   컨트롤러에 비즈니스 로직을 둘 수도 있지만 이렇게 되면 컨트롤러가 너무 많은 역할을 담당하게 된다. 따라서, 비즈니스 로직은 서비스라는 계층을 별도로 만들어서 처리 컨트롤러는 비즈니스 로직이 있는 서비스를 호출하는 역할을 담당한다.        참고 redirect vs forward   리다이렉트는 클라이언트에 응답이 나갔다가 클라이언트가 redirect 경로로 다시 요청. 따라서, 클라이언트가 인지할 수 있고, URL 경로도 실제로 변경 됨. 포워드는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 인지하지 못함        참고 DAO, DTO   DAO란 데이터 접근 객체로 데이터베이스에 접근하는 역할을 담당한다.  DTO는 데이터 전송 객체로 계층간 데이터를 전송할 때 사용한다. 모델이란 문맥에 따라 여러가지 용어가 있다. 비즈니스 모델이라고 할 때는 service, dto, dao 등을 포함해서 설명하는 경우도 있다.    ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-MVCPattern/",
        "teaser": ""
      },{
        "title": "요청 매핑 핸들러 어뎁터 구조",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get       HTTP 메시지 컨버터는 어디서 사용되는지 알아보자. HTTP 메시지 컨버터는 애노테이션 기반의 컨트롤러, 즉 @RequestMapping을 처리하는 핸들러 어댑터인 RequestMappingHandlerAdapter(요청 매핑 헨들러 어댑터)와 관련이 있다.      클라이언트와 서버가 요청과 응답을 주고 받을 때 매우 다양한 파라미터와 리턴 값으로 데이터를 주고 받을 수 있었다. 이는 ArgumentResolver와 ReturnValueHandler를 사용했기 때문에 가능하다.   ArgumentResolver   애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있다.   사용할 수 있는 파라미터 종류      HttpServletRequest, Model   @RequestParam, @ModelAttribute 같은 애노테이션   @RequestBody, HttpEntity 같은 HTTP 메시지를 처리하는 부분   이처럼 다양한 파라미터를 사용할 수 있는데 이렇게 파라미터를 유연하게 처리할 수 있는 이유는 ArgumentResolver 덕분이다.   애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdapter는 ArgumentResolver를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다. 그리고 파라미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.   스프링은 30개가 넘는 ArgumentResolver를 기본으로 제공한다.      참고 ArgumentResolver 가능한 파라미터 목록   https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments     ArgumentResolver의 정확한 명칭은 HandlerMethodArgumentResolver인데 줄여서 ArgumentResolver라 부른다.   1 2 3 4 5 6 7 8 9 public interface HandlerMethodArgumentResolver { \tboolean supportsParameter(MethodParameter parameter); \t \t@Nullable \tObject resolveArgument(MethodParameter parameter,                           @Nullable ModelAndViewContainer mavContainer,                          NativeWebRequest webRequest,                           @Nullable WebDataBinderFactory binderFactory) throws Exception; }   동작 방식   ArgumentResolver의 supportsParameter()를 호출해서 해당 파라미터를 지원하는지 체크하고, 지원하면 resolverArgument()를 호출해서 실제 객체를 생성한다. 이렇게 생성된 객체는 컨트롤러 호출시 넘어간다.   ArgumentResolver는 인터페이스이기 때문에 확장해서 사용할 수 있다.   ReturnValueHandler   HandlerMethodReturnValueHandler를 줄여서 ReturnValueHandler라 부른다. ArgumentResolver와 비슷한데, 이것은 응답 값을 변환하고 처리한다.   컨트롤러에서 String으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분이다.      참고 가능한 응답 값 목록   https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types        HTTP 메시지 컨버터를 사용하는 @RequestBody도 컨트롤러가 필요로 하는 파라미터의 값에 사용된다. @ResponseBody의 경우도 컨트롤러의 반환 값을 이용한다.   요청의 경우 @RequestBody를 처리하는 ArgumentResolver가 있고, HttpEntity를 처리하는 ArgumentResolver가 있다. 이 ArgumentResolver들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성하는 것이다. (HTTP 메시지 컨버터 - read())   응답의 경우 @ResponseBody와 HttpEntity를 처리하는 ReturnValueHandler가 있다. 그리고 여기에서 HTTP 메시지 컨버터를 호출해서 응답 결과를 만든다. (HTTP 메시지 컨버터 - write())   확장   스프링은 다음을 모두 인터페이스로 제공하여 언제든지 기능을 확장할 수 있다.      HandlerMethodArgumentResolver   HandlerMethodReturnValueHandler   HttpMessageConverter   기능 확장은 WebMvcConfigurer를 상속 받아서 스프링 빈으로 등록하면 된다.   스프링은 대부분의 기능을 제공하기 때문에 실제 기능을 확장할 일이 많지는 않으나 알아는 두어야 한다.      참고   ArgumentResolver, ReturnValueHandler 만으로 해결이 되지 않는 경우엔 HTTP 메시지 컨버터를 사용한다.    ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-RequestMappingHandlerAdapter/",
        "teaser": ""
      },{
        "title": "디스패처 서블릿",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   DispatcherServlet   스프링 MVC도 프론트 컨트롤러 패턴으로 구현하였으며 스프링 MVC의 프론트 컨트롤러가 디스패처 서블릿이다. 디스패처 서블릿은 스프링 MVC의 핵심이다.   프론트 컨트롤러와 관련된 내용 (링크)      DispatcherServlet도 부모 클래스에서 HttpServlet을 상속받아서 사용하며 서블릿으로 동작한다.   1 DispatcherServlet → FrameworkServlet → HttpServletBean → HttpServlet   스프링 부트는 DispatcherServlet을 서블릿으로 자동으로 등록하면서 모든 경로(urlPatterns=”/”)에 대해 매핑한다.   DispatcherServlet 요청 흐름      서블릿이 호출되면 HttpServlet이 제공하는 service()가 호출된다.   스프링 MVC는 DispatcherServlet의 부모인 FrameworkServlet에서 service()를 오버라이드 한다.   FrameworkServlet.service()를 시작으로 여러 메서드가 호출되면서 DispatcherServlet.doDispatch()가 호출됨   DispatcherServlet.doDispatch()   DispatcherServlet의 핵심 코드는 doDispatch() 메서드이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // DispatcherServlet의 핵심 코드 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {      HttpServletRequest processedRequest = request;     HandlerExecutionChain mappedHandler = null;     ModelAndView mv = null;      // 1. 핸들러 조회     mappedHandler = getHandler(processedRequest);     if (mappedHandler == null) {         noHandlerFound(processedRequest, response);         return;     }      // 2. 핸들러 어댑터 조회 - 핸들러를 처리할 수 있는 어댑터     HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());      // 3. 핸들러 어댑터 실행 -&gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&gt; 5. ModelAndView 반환     mv = ha.handle(processedRequest, response, mappedHandler.getHandler());      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);  }  private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, \t\t\tHandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {      // 뷰 렌더링 호출     render(mv, request, response);  }  protected void render(ModelAndView mv, HttpServletRequest request,     HttpServletResponse response) throws Exception {      View view;     String viewName = mv.getViewName();      // 6. 뷰 리졸버를 통해서 뷰 찾기, 7. View 반환     view = resolveViewName(viewName, mv.getModelInternal(), locale, request);      // 8. 뷰 렌더링     view.render(mv.getModelInternal(), request, response); }   DispatcherServlet 동작 프로세스         핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 찾는다.   핸들러 어댑터 조회: 핸들러를 처리할 수 있는 핸들러 어댑터를 찾는다.   찾았으면 처리할 데이터를 핸들러 어댑터를 실행하여 실제 핸들러(컨트롤러)에 전달한다.   ModelAndView 반환: 핸들러가 데이터를 처리하여 반환하면 핸들러 어댑터가 ModelAndView로 변환해서 반환한다.   viewResolver 호출: 뷰 리졸버를 찾고 실행한다.            JSP의 경우 InternalResourceViewResolver가 자동 등록되고 사용됨           View 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고 렌더링 역할을 담당하는 뷰 객체를 반환한다.            JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다           뷰 렌더링: 뷰를 통해서 뷰를 렌더링.   스프링 MVC의 강점은 DispatcherServlet 코드의 변경 없이 원하는 기능을 변경, 확장할 수 있다는 점이다. (대부분을 확장 가능하도록 인터페이스로 제공하기 때문이다.)      참고 주요 인터페이스 목록          핸들러 매핑: org.springframework.web.servlet.HandlerMapping     핸들러 어댑터: org.springframework.web.servlet.HandlerAdapter     뷰 리졸버: org.springframework.web.servlet.ViewResolver     뷰: org.springframework.web.servlet.View      핸들러 매핑과 핸들러 어댑터   컨트롤러를 호출하려면 핸들러 매핑과 핸들러 어댑터가 필요하다.   핸들러 매핑과 핸들러 어댑터를 이해하기 위해 지금은 전혀 사용하지 않지만 과거에 주로 사용했던 스프링이 제공하는 간단한 컨트롤러를 살펴보자.   Controller 인터페이스   과거 버전 스프링 컨트롤러이다. 현재는 @Controller 어노테이션을 사용한다.   1 2 3 4 // org.springframework.web.servlet.mvc.Controller public interface Controller { \tModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception; }      참고 Controller 인터페이스와 @Controller는 전혀 다름     1 2 3 4 5 6 7 8 9 10 //import org.springframework.web.servlet.mvc.Controller;  @Component(\"/springmvc/old-controller\") public class OldController implements Controller {     @Override     public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {         System.out.println(\"OldController.handleRequest\");         return null;     } }   @Component는 OldController는 /springmvc/old-controller라는 이름의 스프링 빈으로 등록된다. 빈의 이름으로 URL을 매핑시킨 것이다. 결론적으로 OldController가 스프링 빈, /springmvc/old-controller이 빈 이름이다.   핸들러 매핑   핸들러 매핑에서 컨트롤러를 찾을 수 있어야 한다. (예. 스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요함)   핸들러 어댑터   핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요하다. (예. Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 함)   스프링은 대부분의 핸들러 매핑과 핸들러 어댑터를 미리 구현해두었기 때문에 개발자가 직접 핸들러 매핑과 핸들러 어댑터를 구현하는 일이 거의 없다.   스프링 부트가 자동 등록하는 핸들러 매핑과 어댑터   스프링은 핸들러 매핑, 핸들러 어댑터 모두 순서대로 찾고 없으면 다음 순서로 넘어간다. (종류는 실제로 더 많지만, 주요 핸들러 매핑과 어댑터만 소개함)   HandlerMapping   1 2 0 = RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용 1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다.   HandlerAdapter   1 2 3 0 = RequestMappingHandlerAdapter : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용 1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리 2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리      핸들러 매핑으로 핸들러 조회            HandlerMapping을 순서대로 실행해서, 핸들러를 찾음       이 경우, 빈 이름으로 핸들러를 찾아야 하기 때문에 이름 그대로 빈 이름으로 핸들러를 찾아주는 BeanNameUrlHandlerMapping가 실행에 성공하고 핸들러인 OldController를 반환함           핸들러 어댑터 조회            HandlerAdapter의 supports()를 순서대로 호출       SimpleControllerHandlerAdapter가 Controller 인터페이스를 지원하므로 대상이 됨           핸들러 어댑터 실행            디스패처 서블릿이 조회한 SimpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨줌       SimpleControllerHandlerAdapter는 핸들러인 OldController를 내부에서 실행하고, 그 결과를 반환           정리 - OldController 핸들러매핑, 어댑터   OldController를 실행하면서 사용된 객체      HandlerMapping = BeanNameUrlHandlerMapping (스프링 빈의 이름으로 핸들러를 찾음)   HandlerAdapter = SimpleControllerHandlerAdapter (Controller 인터페이스 처리)   RequestMappingHandlerMapping   가장 우선순위가 높은 핸들러 매핑과 핸들러 어댑터는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter 이고 앞에 부분만 따서 RequestMapping이라 한다.   @RequestMapping은 현재 스프링에서 주로 사용하는 애노테이션 기반의 컨트롤러를 지원하는 매핑과 어댑터이다. (실무에서 99.9% 사용)   뷰 리졸버   스프링 부트는 InternalResourceViewResolver 라는 뷰 리졸버를 자동으로 등록하는데 이때, application.properties에 등록한 설정 정보를 사용한다.   1 2 spring.mvc.view.prefix=/WEB-INF/views/ spring.mvc.view.suffix=.jsp   뷰 리졸버 동작 방식   스프링 부트가 자동 등록하는 뷰 리졸버   1 2 1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성 기능에 사용) 2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.      핸들러 어댑터 호출            핸들러 어댑터를 통해 new-form이라는 논리 뷰 이름을 획득           ViewResolver 호출            new-form이라는 뷰 이름으로 viewResolver를 순서대로 호출       BeanNameViewResolver는 new-form이라는 이름의 스프링 빈으로 등록된 뷰를 찾아야 하는데 없다       그 다음 순위인 InternalResourceViewResolver가 호출됨           InternalResourceViewResolver            이 뷰 리졸버는 InternalResourceView를 반환           뷰 - InternalResourceView            InternalResourceView는 JSP처럼 포워드 forward()를 호출해서 처리할 수 있는 경우에 사용           view.render()            view.render()가 호출되고 InternalResourceView는 forward()를 사용해서 JSP를 실행함              참고   Thymeleaf 뷰 템플릿을 사용하면 ThymeleafViewResolver를 등록해야 한다. 최근에는 라이브러리만 추가하면 스프링 부트가 이런 작업도 모두 자동화해준다.    ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-DispatcherServlet/",
        "teaser": ""
      },{
        "title": "HTTP 메시지 컨버터",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get       뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라, HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.         viewResolver 대신에 HttpMessageConverter가 동작   기본 문자처리: StringHttpMessageConverter (문자를 반환할 때)   기본 객체처리: MappingJackson2HttpMessageConverter (JSON을 반환할 때)      참고   응답의 경우 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택된다.     스프링 MVC의 HTTP 메시지 컨버터는 다음과 같은 기능을 제공한다.      HTTP 요청: @RequestBody를 사용하여 JSON을 자바객체로 변환, HttpEntity(RequestEntity)   HTTP 응답: @ResponseBody를 사용하여 자바객체를 JSON으로 변환, HttpEntity(ResponseEntity)   인터페이스인 HTTP 메시지 컨버터를 이용하여 JSON, Stirng, Byte 타입으로 편리하게 반환할 수 있다.   HTTP 메시지 컨버터 인터페이스   1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.springframework.http.converter;  public interface HttpMessageConverter&lt;T&gt; {      boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);     boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);      List&lt;MediaType&gt; getSupportedMediaTypes();      T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)             throws IOException, HttpMessageNotReadableException;     void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)             throws IOException, HttpMessageNotWritableException; }      HTTP 메시지 컨버터는 HTTP 요청, HTTP 응답 둘 다 사용된다.   canRead() , canWrite() : 메시지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크   read() , write() : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능   스프링 부트 기본 메시지 컨버터 (일부 생략)   1 2 3 4 0 = ByteArrayHttpMessageConverter: application/octet-stream 1 = StringHttpMessageConverter: text/plain 2 = MappingJackson2HttpMessageConverter: application/json ...   스프링 부트는 다양한 메시지 컨버터를 제공하는데, 대상 클래스 타입과 미디어 타입 둘을 체크해서 사용여부를 결정함. (만약, 만족하지 않으면 우선순위가 넘어감)   HTTP 요청 데이터 읽기      HTTP 요청이 오고, 컨트롤러에서 @RequestBody , HttpEntity 파라미터를 사용한다면   메시지 컨버터가 우선순위에 따라 작동하며   메시지를 읽을 수 있는지 확인하기 위해 canRead()를 호출한다.            대상 클래스 타입을 지원하는가.                    예) @RequestBody 의 대상 클래스 (byte[] , String , HelloData)                       HTTP 요청의 Content-Type 미디어 타입을 지원하는가.                    예) text/plain , application/json , /                           canRead() 조건을 만족하면 read()를 호출해서 객체 생성하고, 반환한다.   HTTP 응답 데이터 생성      컨트롤러에서 @ResponseBody , HttpEntity로 값이 반환되면   메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite()를 호출한다.            대상 클래스 타입을 지원하는가.                    예) return의 대상 클래스 (byte[] , String , HelloData)                       HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces)                    예) text/plain , application/json , /                            canWrite() 조건을 만족하면 write()를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.                                                  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-HTTPMessageConverter/",
        "teaser": ""
      },{
        "title": "로깅",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   로깅   운영 시스템에서는 System.out.println()같은 시스템 콘솔 사용하지 않고 별도의 로깅 라이브러리를 사용해서 로그를 출력함       로깅 라이브러리   스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리(spring-boot-starter-logging) 포함       스프링 부트가 사용하는 기본 로깅 라이브러리      SLF4J   Logback       로그 라이브러리는 Logback, Log4J, Log4J2 등등 수 많은 라이브러리가 존재   그것을 통합해 인터페이스로 제공하는 것이 SLF4J 라이브러리   SLF4J는 인터페이스고, 그 구현체로 Logback 같은 로그 라이브러리를 선택   실무에서는 스프링 부트가 기본으로 제공하는 Logback을 대부분 사용       로그 선언      private Logger log = LoggerFactory.getLogger(getClass());   private static final Logger log = LoggerFactory.getLogger(Xxx.class)   @Slf4j : 롬복 사용 가능       로그 호출      log.info(”hello”)   System.out.println(”hello)       시스템 콘솔로 직접 출력하는 것보다 로그를 사용하는게 좋다. 실무에서는 항상 로그를 사용해야 함.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package hello.springmvc.basic;  import lombok.extern.slf4j.Slf4j; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  //@Slf4j @RestController public class LogTestController {      private final Logger log = LoggerFactory.getLogger(getClass());      @RequestMapping(\"/log-test\")     public String logTest() {         String name = \"Spring\";          log.trace(\"trace log={}\", name);         log.debug(\"debug log={}\", name);         log.info(\" info log={}\", name);         log.warn(\" warn log={}\", name);         log.error(\"error log={}\", name);          // 로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X         log.debug(\"String concat log=\" + name);          return \"ok\";     } }   @RestController      @Controller는 반환값이 String이면 뷰 이름으로 인식됨. 따라서, 뷰를 찾고 뷰가 랜더링 된다   @RestController는 반환 값으로 뷰를 찾는 것이 아닌, HTTP 메시지 바디에 바로 입력됨. 따라서, 실행 결과로 ok 메세지를 받는다. @ResponseBody와 관련이 있음       테스트      로그가 출력되는 포맷 확인            시간, 로그레벨, 프로세스ID, 쓰레드명, 클래스명, 로그 메시지           로그 레벨 설정을 변경해서 출력 결과 확인            LEVEL: TRACE &gt; DEBUG &gt; INFO &gt; WARN &gt; ERROR       개발 서버는 debug 출력       운영 서버는 info 출력                @Slf4j로 변경: 다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자는 편리하게 log 라고 사용.       1 2   private static final org.slf4j.Logger log =    org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class);               로그레벨 설정   application.properties   1 2 3 4 5 #전체 로그 레벨 설정(기본 info(debug)) logging.level.root=info  #hello.springmvc 패키지와 그 하위 로그 레벨 설정 logging.level.hello.springmvc=debug       올바른 로그 사용법      log.debug(”data=”+data)            로그 출력 레벨을 info로 설정해도 해당 코드에 있는 “data=”+data가 실행되어버림 (메모리 사용, cpu사용)           log.debug(”data={}”, data)            로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않음. 따라서, 앞과 같은 의미없는 연산이 발생하지 않는다               로그 사용시 장점      쓰레드 정보, 클래스 이름 같은 부가 정보를 볼 수 있고, 출력 모양을 조정할 수 있음   개발 서버와 운영 서버 각각 상황에 맞게 로그 레벨을 조절할 수 있음 → 설정파일을 통해   시스템 아웃 콘솔에만 출력하는 것이 아닌 파일, 네트워크 등 로그를 별도의 위치에 남길 수 있음. 특히, 파일로 남길 때 일별, 특정 용량에 따라 로그 분할 가능함   성능도 System.out 보다 좋음. (내부 버퍼링, 멀티 쓰레드 등) 실무에서는 꼭 로그를 사용!  ","categories": ["web"],
        "tags": ["web","Spring"],
        "url": "/web/Spring-Logging/",
        "teaser": ""
      },{
        "title": "PRG, Post/Redirect/Get",
        "excerpt":"목차      웹 서버와 WAS   서블릿   쓰레드와 쓰레드 풀   SSR, CSR   MVC 패턴   구 MVC 패턴과 프론트 컨트롤러   디스패처 서블릿   로깅   HTTP 메시지 컨버터   요청 매핑 핸들러 어댑터 구조   PRG Post/Redirect/Get   PRG 패턴   PRG 패턴이란 웹 개발 패턴 중 자주 쓰이는 패턴으로 HTTP POST 요청에 대해 GET 방식의 웹페이지로 리다이렉트 시키는 패턴이다.   PRG 패턴을 사용하게 된 이유는 아래 코드로 설명할 수 있다. 이 코드는 상품을 등록하고 상품 목록 페이지로 다시 돌아가는 코드이다. 이 코드에서는 오류가 있다. 상품을 등록을 완료하고 웹 브라우저의 새로고침 버튼을 누를 때마다 상품이 새로 등록된다.   1 2 3 4 5 @PostMapping(\"/add\") public String addItemV5(Item item) {     itemRepository.save(item);     return \"/basic/item\" }   왜 새로고침 버튼을 누를 때마다 새로 등록될까? 새로고침은 클라이언트 마지막에 보낸 요청을 다시 보낸다. 즉, 클라이언트가 서버에게 보낸 마지막 요청이 상품을 등록하는 것이기 때문에 새로고침을 할 때마다 상품이 새로 등록된다.   PRG - 새로고침 문제 해결   PRG 패턴으로 이 문제를 해결할 수 있다.   웹 브라우저의 새로 고침은 마지막에 서버에 전송한 데이터를 다시 전송한다. 새로 고침 문제를 해결하려면 상품 저장 후에 뷰 템플릿으로 이동하는 것이 아니라, 상품 상세 화면으로 리다이렉트를 호출해주면 된다.   웹 브라우저는 리다이렉트의 영향으로 상품 저장 후에 실제 상품 상세 화면으로 다시 이동한다. 따라서, 마지막에 호출한 내용이 상품 상세 화면인 ‘GET /items/{id}’ 가 되는 것이다. 이후 새로고침을 해도 상품 상세 화면으로 이동하게 되므로 새로 고침 문제를 해결할 수 있다.   1 2 3 4 5 6 7 8 9 /**  * PRG - Post/Redirect/Get  */ @PostMapping(\"/add\") public String addItemV5(Item item) {     itemRepository.save(item);     // return \"/basic/item\"     return \"redirect:/basic/items/\" + item.getId(); }   기존엔 상품 등록 후 뷰 템플릿(/basic/item)을 리턴하였는데 이젠 상품 상세 화면으로 리다이렉트 하도록 코드를 작성하여 문제를 해결하였다. 이런 문제 해결 방식을 PRG Post/Redirect/Get라 한다.   PRG 적용 전      ‘POST /items/add + 상품 데이터‘를 서버로 전송   서버에서 클라이언트로 ‘POST + 200 응답코드’ 전달   클라이언트가 서버에 마지막으로 요청한 url은 ‘POST /items/add + 상품 데이터‘ 이다   클라이언트의 새로고침은 마지막에 서버에 전송한 데이터를 다시 전송하는 것이다   따라서, 새로고침을 할때마다 1번을 전송한다. (무의미한 데이터를 저장하게 된다)      PRG 적용 후      ‘POST /items/add + 상품 데이터‘를 서버로 전송   서버에서 클라이언트로 ‘POST + 302 응답 코드 + Location’ 전달   302 응답 코드와 Location이 전달되면 Location에 적힌 url을 다시 호출하게 된다.   따라서, 클라이언트는 서버에 ‘GET + /items/{id}’를 요청하게 된다.   클라이언트가 서버에 마지막으로 요청한 url은 ‘GET + /items/{id}’ 이다   클라이언트의 새로고침은 마지막에 서버에 전송한 데이터를 다시 전송하는 것이다   따라서, 새로고침을 할때마다 5번을 전송한다. (새로고침 오류를 해결!)         주의   \"redirect:/basic/items/\" + item.getId()  redirect에서 +item.getId() 처럼 URL에 변수를 더해서 사용하는 것은 URL 인코딩이 안되기 때문에 위험하다. 위의 경우는 int여서 괜찮았지만 문자열을 전송하게 되어 한글을 전송하게 된다면 인코딩 문제가 발생하게 된다. 이러한 문제는 다음에 설명하는 RedirectAttributes를 사용하여 해결할 수 있다.     RedirectAttributes   RedirectAttributes를 사용하면 URL 인코딩도 해주고, pathVarible, 쿼리 파라미터까지 처리해준다.      redirect:/basic/items/{itemId}            pathVariable 바인딩: {itemId}       나머지는 쿼리 파라미터로 처리: ?status=true           1 2 3 4 5 6 7 8 9 10 /**  * RedirectAttributes  */ @PostMapping(\"/add\") public String addItemV6(Item item, RedirectAttributes redirectAttributes) {     Item savedItem = itemRepository.save(item);     redirectAttributes.addAttribute(\"itemId\", savedItem.getId());     redirectAttributes.addAttribute(\"status\", true);     return \"redirect:/basic/items/{itemId}\"; }   코드를 실행하면 ‘http://localhost:8080/basic/items/3?status=true’ 리다이렉트 결과가 나온다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-PRG/",
        "teaser": ""
      },{
        "title": "좋은 객체 지향 설계의 원칙: SOLID",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   SOLID란, 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리한 것이다.   SRP, OCP, LSP, ISP, DIP가 있는데 그 중 OCP와 DIP가 중요하다.       1. SRP 단일 책임 원칙 (Single Responsibility Principle)   한 클래스는 하나의 책임만 가져야 한다. 여기서 하나의 책임이라는 말은 모호할 수 있다. 하나의 책임을 구분하는 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라 볼 수 있다.      예) UI 변경, 객체의 생성과 사용을 분리       2. OCP 개방-폐쇄 원칙 (Open/Closed Principle)   소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다. 확장을 하려면 당연히 기존 코드를 변경해야한다고 생각할 수 있지만, 다형성을 활용하면 가능하다.   인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다면 즉, 역할과 구현을 분리한다면 OCP가 가능하다.   그러나, 다형성만으로는 OCP 원칙을 지킬 수 없다. 아래 예제를 살펴보자.   1 2 3 public class MemberService {     private MemberRepository memberRepository = new MemoryMemberRepository(); }   1 2 3 4 5 6 7 8 public class MemberService {     // private MemberRepository memberRepository = new MemoryMemberRepository();     private MemberRepository memberRepository = new JdbcMemberRepository(); }  // MemberRepository: 인터페이스 // MemoryMemberRepository: 구현 객체 // JdbcMemberRepository: 구현 객체   MemberService 클라이언트가 구현 클래스를 직접 선택했다. MemberRepository는 인터페이스이고 MemoryMemberRespository와 JdbcMemberRespository는 구현체이다. 다형성을 지켰지만 코드의 변경은 일어났다.      MemberRepository m = new MemoryMemberRepository(); // 기존 코드   MemberRepository m = new JdbcMemberRepository(); // 변경 코드       구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. 어떻게 해결할까? 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. 이후에 등장하는 DI개념과 DI 컨테이너가 이 부분을 담당한다.       3. LSP 리스코프 치환 원칙 (Liskov Substitution Principle)   프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다. 단순히 컴파일에 성공하는 것을 넘어서는 이야기이다.      예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함       4. ISP 인터페이스 분리 원칙 (Interface Segregation Principle)   특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. ISP 원칙을 지키면 인터페이스가 명확해지고, 대체 가능성이 높아진다.      예)   자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리   사용자 클라이언트 → 운전자 인터페이스, 정비사 클라이언트로 분리   분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음       5. DIP 의존관계 역전 원칙 (Dependency Inversion Principle)   프로그래머는 ‘추상화에 의존해야지, 구체화에 의존하면 안된다.’ 의존성 주입은 이 원칙을 따르는 방법 중 하나다.   다시말하면, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.      예) k3, 아반떼, 테슬라(자동차 구현)에 집중하는 것이 아닌 자동차 객체에 집중!   앞에서 이야기한 역할에 의존하게 해야 한다는 것과 같은 의미이다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.   그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다. (의존한다는 것의 의미는 내가 저 코드에 대해 알기만해도 의존한다고 한다) 그렇다면 어떻게 해야할까? MemberService는 MemberRepository에만 의존하도록 설계해야한다.       스프링의 DI, DI 컨테이너 제공을 통해 다형성 + OCP, DIP를 가능하게 한다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-SOLID/",
        "teaser": ""
      },{
        "title": "스프링 컨테이너와 스프링 빈",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   스프링 컨테이너   스프링 컨테이너란?   스프링 컨테이너란 스프링에서 자바 객체들을 관리하는 공간을 말한다. 여기서 자바 객체는 스프링 빈(Bean)을 의미한다. 즉, 스프링 컨테이너는 빈의 생성부터 소멸까지의 생명주기를 관리해주는 곳이다.   스프링 컨테이너의 종류에는 ApplicationContext와 BeanFactory가 있다. 하지만, BeanFactory를 직접 사용하는 경우는 거의 없으므로 일반적으로 ApplicationContext를 스프링 컨테이너라 한다.   스프링 컨테이너 생성   ApplicationContext는 인터페이스이다. 그리고 인터페이스이므로 다형성이 적용되어 있다. 스프링 컨테이너는 XML 기반으로 만들 수 있고 애노테이션 기반의 자바 설정 클래스로 만들 수 있다. (구현체)   1 2 3 // AnnotationConfigApplicationContext은 ApplicationContext의 구현체 // AnnotationConfigApplicationContext은 애노테이션 기반의 자바 설정 클래스 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);   컨테이너 생성 시 AppConfig를 전달하면 AppConfig가 빈으로 등록되고 내부에 @Bean이 붙은 메서드들이 스프링 빈으로 등록된다.      참고   ApplicationContext는 직접 생성할 일이 거의 없다. 스프링 부트 프로젝트의 최상위 폴더에 있는 XxxApplication.java 파일의 SpringApplication.run(XxxApplication.class, args)를 통해 내부에서 컨테이너가 자동으로 생성된다.     스프링 컨테이너의 생성과정           스프링 컨테이너 생성       new AnnotationConfigApplicationContext(AppConfig.class);로 스프링 컨테이너를 생성할 수 있다. 스프링 컨테이너가 생성되면서 내부에는 스프링 빈 저장소가 생성되는데 키가 빈 이름이고 값이 빈 객체이다. 스프링 컨테이너를 생성할 때는 AppConfig 같은 설정 정보를 파라미터로 넘겨 구성 정보를 지정해주어야 한다.                   스프링 빈 등록       스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보(AppConfig)를 사용해서 스프링 빈을 등록한다. 빈 이름은 보통 메서드 이름을 사용한다. (직접 부여할 수도 있다.)                     주의     빈 이름은 항상 다른 이름을 부여해야 한다. 같은 이름을 부여하면 다른 빈이 무시되거나 기존 빈을 덮어버리거나 설정에 따라 오류가 발생한다.                  스프링 빈 의존관계 설정       스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)한다. 단순히 자바 코드를 호출하는 것 같지만, CGLIB라는 바이트코드 조작 라이브러리를 호출하는 것이다. 이에 대한 내용은 싱글톤 컨테이너에서 설명한다.(링크 넣어주자!)                 참고   스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다. 그런데, 이렇게 자바 코드로 스프링 빈을 등록하면 생성자를 호출하면서 의존관계 주입도 한번에 처리된다. 여기서는 이해를 돕기 위해 개념적으로 나누어 설명했다. 자세한 내용은 의존관계 자동 주입에서 다시 설명하겠다.     다양한 설정 형식 - 자바 코드, XML   스프링 컨테이너는 다양한 형식의 설정 정보를 받아들일 수 있게 유연하게 설계되어 있다. (자바 코드, XML, Groovy 등)   애노테이션 기반 자바 코드 설정 사용   AnnotationConfigApplicationContext 클래스를 사용하면서 자바 코드로된 설정 정보를 넘기면 된다.   1 ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class)   XML 설정 사용   최근에는 스프링 부트를 많이 사용하면서 XML기반의 설정은 잘 사용하지 않는다. 하지만, 아직 많은 레거시 프로젝트들이 XML로 되어 있고, 또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있으므로 한번쯤 배워두는 것도 괜찮다.   1 ApplicationContext ac = new GenericXmlApplicationContext(\"appConfig.xml\");   스프링 빈 설정 메타 정보   스프링이 다양한 형식을 지원할 수 있는 이유는 BeanDefinition으로 추상화하여 사용하기 때문이다. BeanDefinition을 빈 설정 메타정보라 한다. @Bean, 당 각각 하나의 메타 정보가 생성된다. 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다. 실무에서 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다.   BeanFactory와 ApplicationContext   BeanFactory   BeanFactory는 스프링 컨테이너의 최상위 인터페이스다. 스프링 빈을 관리하고 조회하는 역할을 담당하며 getBean()을 제공한다. ApplicationContext는 BeanFactory 기능을 모두 상속받아서 제공한다.      앞서 스프링 컨테이너의 종류엔 BeanFactory와 ApplicationContext가 있지만 주로 ApplicationContext를 사용한다고 했다. 그 이유는 ApplicationContext은 빈을 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능을 제공한다.   ApplicationContext가 제공하는 부가기능         메시지소스를 활용한 국제화 기능: 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력   환경변수: 로컬, 개발, 운영 등을 구분해서 처리   애플리케이션 이벤트: 이벤트를 발행하고 구독하는 모델을 편리하게 지원   편리한 리소스 조회: 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회   ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다. 따라서, BeanFactory를 직접 사용할 일은 거의 없고 부가기능이 포함된 ApplicationContext를 사용한다.   스프링 빈   스프링 빈이란?   스프링 빈은 스프링 컨테이너에 의해 관리되는 자바 객체를 의미한다.   스프링 빈 조회   스프링 빈을 조회할 일은 많지 않으므로 이런게 있다 정도로만 알아두자.   컨테이너에 등록된 모든 빈 조회   1 2 3 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);  String[] beanDefinitionNames = ac.getBeanDefinitionNames();   스프링 빈 조회 - 기본   1 2 3 4 5 6 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);  // ac.getBean(빈이름, 타입) MemberService memberService = ac.getBean(\"memberService\", MemberService.class); // ac.getBean(타입) MemberService memberService = ac.getBean(MemberService.class);   [참고]   #1과 #2 코드는 동일한 코드이다. 하지만 #1처럼 DiscountPolicy로 쓰는 것이 좋다. #1 코드는 역할과 구현을 분리한 코드이다. DIP 원칙을 지키는 코드가 좋은 코드이다. (역할 DiscountPolicy, 구현 rateDiscountPolicy)   1 2 3 4 5 6 7 8 9 10 11 // #1 @Bean public DiscountPolicy rateDiscountPolicy() {     return new RateDiscountPolicy(); }  // #2 @Bean public RateDiscountPolicy rateDiscountPolicy() {     return new RateDiscountPolicy(); }  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-SpringContainer-Bean/",
        "teaser": ""
      },{
        "title": "의존관계 주입 방법",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   다양한 의존관계 주입 방법      생성자 주입   수정자 주입 (setter 주입)   필드 주입   일반 메서드 주입   생성자 주입   생성자를 통해서 의존 관계를 주입 받는 방법이고 현재 가장 권장하는 방법이다. 생성자 호출 시점에 1번만 호출되는 것이 보장되고 불변, 필수 의존관계에 사용된다. 또한, 생성자가 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. (스프링 빈에만 해당됨)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Component public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository;     private final DiscountPolicy discountPolicy;      // 생성자가 하나이기 때문에 @Autowired 생략 가능 하다. \t\t// 요즘은 생략해서 많이 사용함     // @Autowired     public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {         this.memberRepository = memberRepository;         this.discountPolicy = discountPolicy;     } \t... }      참고 불변   좋은 개발 습관은 제약, 한계점이 있어야 한다.     생성자 주입을 권장하는 이유      불변            대부분의 의존관계 주입은 애플리케이션 종료시점까지 변경될 일이 없고 변하면 안된다.(불변해야 한다.)       수정자 주입을 사용하면 setXxx 메서드를 public으로 열어둬야 한다. public이기 때문에 누군가 실수로 변경할 수 있다. 또한, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.       생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서, 불변하게 설계할 수 있다.           누락            생성자 주입을 사용하면 주입 데이터가 누락 되었을 때 컴파일 오류가 발생하여 어떤 값을 필수로 주입해야 하는지 알 수 있다. (가장 좋은 오류는 컴파일 오류이다.)       수정자 주입을 사용하면 실행은 되지만 NPE 오류가 발생한다.           final 키워드            생성자 주입을 사용하면 필드에 final을 사용할 수 있어 혹시라도 생성자에 값이 설정되지 않아 발생하는 오류를 컴파일 시점에 막아준다.              참고 순환참조   A→B→C→A로 각 Bean들의 생성자가 서로를 의존하는 문제를 순환참조라 한다. 그리고 순환참조가 발생하면 애플리케이션이 정상적으로 동작하지 않는다. 의존관계는 단방향으로 설계하는 것이 좋다.     수정자 주입(setter 주입)   setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해 의존관계를 주입하는 방법이다. 선택, 변경 가능성이 있는 의존관계에 사용되며, 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class OrderServiceImpl implements OrderService {      private MemberRepository memberRepository;     private DiscountPolicy discountPolicy;      @Autowired     public void setMemberRepository(MemberRepository memberRepository) {         this.memberRepository = memberRepository;     }      @Autowired     public void setDiscountPolicy(DiscountPolicy discountPolicy) {         this.discountPolicy = discountPolicy;     } \t... }      참고   @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정하면 된다.        참고 자바빈 프로퍼티 규약   자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서드를 통해서 값을 읽거나 수정하는 규칙을 만들었는데 그것이 자바빈 프로퍼티 규약이다.     필드 주입   필드에 바로 주입하는 방법이다. 코드가 간결하다는 장점이 있지만 외부에서 변경이 불가능해 테스트하기 힘들다는 치명적인 단점이 있다. 또한, DI 프레임워크가 없으면 아무것도 할 수 없다. 그래서, 순수 자바코드로 테스트가 불가하다. 이 방식은 되도록 사용하지 말자.   1 2 3 4 5 6 7 8 9 @Component public class OrderServiceImpl implements OrderService {      @Autowired     private MemberRepository memberRepository;     @Autowired     private DiscountPolicy discountPolicy;     ... }   일반 메서드 주입   일반 메서드를 통해 주입 받을 수 있다. 일반적으로 잘 사용하지 않는다.      참고   당연한 이야기지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다. 스프링 빈이 아닌 Member 같은 클래스에서 @Autowired 코드를 적용해도 아무 기능도 동작하지 않는다.     롬복과 최신 트렌드   롬복을 이용해 생성자 주입 방식으로 작성하면서도 매우 편리하게 사용할 수 있는 방법이 있다. 롬북에서 제공하는 @RequiredArgsConstructor 기능을 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.   1 2 3 4 5 6 7 @Component @RequiredArgsConstructor public class OrderServiceImpl implements OrderService {      private final MemberRepository memberRepository;     private final DiscountPolicy discountPolicy; }   위의 코드는 생성자 주입 코드와 완전히 동일하다. 롬복이 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 생성자 코드를 자동으로 생성해준다.   최근에는 생성자를 딱 1개 두고, @Autowired 를 생략하는 방법을 주로 사용한다. 여기에 Lombok 라이브러리의 @RequiredArgsConstructor 함께 사용하면 기능은 다 제공하면서, 코드는 깔끔하게 사용할 수 있다.      참고   @RequiredArgsConstructor는 단순히 생성자 코드만 만들어준다. 생성자가 하나만 있어서 @Autowired를 생략해도 되는 것이지 @RequiredArgsConstructor가 @Autowired 까지 생성해주는 것이 아니다.     @Autowired 필드 명, @Qualifier, @Primary   같은 타입의 빈이 2개 이상 등록되었을 때   @Autowired는 타입으로 빈을 조회하는데 타입으로 조회할 경우 선택된 빈이 2개 이상이면 NoUniqueBeanDefinitionException 에러가 발생한다.   예) DiscountPolicy의 하위 타입인 FixDiscountPolicy, RateDiscountPolicy 두가지가 스프링 빈으로 선언   1 2 @Autowired private DiscountPolicy discountPolicy;   1 2 3 4 5 @Component public class FixDiscountPolicy implements DiscountPolicy {}  @Component public class RateDiscountPolicy implements DiscountPolicy {}    에러를 해결하기 위해 하위 타입으로 지정할 수도 있지만, 하위 타입으로 지정하는 것은 DIP를 위배하고 유연성이 떨어진다. 그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다. 스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다.   조회 대상 빈이 2개 이상일 때 해결 방법      @Autowired 필드 명 매칭   @Qualifier → @Qualifier끼리 매칭 → 빈 이름 매칭   @Primary 사용   @Autowired 필드 명 매칭   @Autowired는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.   필드 명을 빈 이름으로 변경   1 2 3 @Autowired // private DiscountPolicy discountPolicy; private DiscountPolicy rateDiscountPolicy;   1 2 3 4 5 6 @Autowired // discountPolicy를 rateDiscountPolicy로 변경함 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy rateDiscountPolicy) {     this.memberRepository = memberRepository;     this.discountPolicy = rateDiscountPolicy; }   @Autowired 매칭 정리      우선 타입으로 매칭한다.   타입 매칭의 결과가 2개 이상일 때는 필드명, 파라미터명으로 빈 이름 매칭한다.   @Qualifier 사용   @Qualifier는 추가 구분자를 붙여주는 방법이다. 빈을 등록할 때 @Qualifier(“빈 이름”)을 지정해주고 의존관계 주입 시 @Qualifier를 붙여주고 등록한 이름을 적는다.   빈 등록 시 @Qualifier 붙여줌   1 2 3 @Component @Qualifier(\"mainDiscountPolicy\") public class RateDiscountPolicy implements DiscountPolicy {}   생성자 자동 주입 시 @Qualifier를 붙여줌   1 2 3 4 5 @Autowired public OrderServiceImpl(MemberRepository memberRepository, @Qualifier(\"mainDiscountPolicy\") DiscountPolicy discountPolicy) {     this.memberRepository = memberRepository;     this.discountPolicy = discountPolicy; }   만약, @Qualifier(“mainDiscountPolicy”)로 주입한 빈을 못찾는다면 mainDiscountPolicy라는 이름의 스프링 빈을 찾는다. 하지만 경험상 @Qualifier는 @Qualifier를 찾는 용도로만 사용하는 것이 좋다.   @Qualifier 정리      @Qualifier끼리 매칭   빈 이름 매칭   NoSuchBeanDefinitionException 예외 발생   @Primary 사용   @Primary는 우선순위 정하는 방법이다. @Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 가진다.   1 2 3 4 5 6 7 // rateDiscountPolicy가 우선권을 가짐 @Component @Primary public class RateDiscountPolicy implements DiscountPolicy {}  @Component public class FixDiscountPolicy implements DiscountPolicy {}   @Primary와 @Qualifier 중에 어떤 것을 사용하면 좋을지 고민이 될 것이다. @Qualifier의 단점은 주입 받을 때 코드에 @Qualifier를 여러 곳에 붙여주어야 한다는 점이다. 반면에, @Primary를 사용하면 이렇게 @Qualifier를 붙일 필요가 없다.   @Primary, @Qualifier 활용   코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고, 코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자. 메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary를 적용해서 조회하는 곳에서 @Qualifier 지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때는 @Qualifier를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다. 물론, 이때 메인 데이터베이스의 스프링 빈을 등록할 때 @Qualifier를 지정해주는 것은 상관없다.   우선순위   우선순위는 ‘@Qualifier &gt; @Primary &gt; @Autowired’ 순 이다. @Primary는 기본값 처럼 동작하는 것이고, @Qualifier는 매우 상세하게 동작한다. 스프링은 자동보다는 수동이, 넒은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다. 따라서, 여기서도 @Qualifier가 우선권이 높다.      참고   @Primary, @Qualifier를 사용하면서 구현체 코드를 수정했다. 즉, 클라이언트 코드를 수정하였다. 이는 OCP원칙에 위배된다. 기존 구현 클래스의 애노테이션을 변경하지 않으면 좋겠지만 이는 컴포넌트 스캔의 한계이다. 이런 것을 트레이드 오프라 한다. 트레이드 오프란 하나를 얻으면 다른 하나를 잃을 수 있는 관계를 의미한다.     애노테이션 직접 만들기   @Qualifier(”mainDiscountPolicy”) 이렇게 적으면 컴파일시 타입 체크가 안되므로 애노테이션을 만들어서 문제를 해결할 수 있다.      애노테이션을 직접 만드는 것은 실무에서 한번씩 사용한다.     1 2 3 4 5 6 7 8 9 10 import org.springframework.beans.factory.annotation.Qualifier;  import java.lang.annotation.*;  @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER,         ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Qualifier(\"mainDiscountPolicy\") public @interface MainDiscountPolicy {}   1 2 3 @Component @MainDiscountPolicy public class RateDiscountPolicy implements DiscountPolicy {}   1 2 3 4 5 @Autowired public OrderServiceImpl(MemberRepository memberRepository, @MainDiscountPolicy DiscountPolicy discountPolicy) {     this.memberRepository = memberRepository;     this.discountPolicy = discountPolicy; }   조회한 빈이 모두 필요할 때, List, Map   의도적으로 정말 해당 타입의 스프링 빈이 다 필요한 경우도 있다.   실무에서 사용하는 경우: 예시) 할인 서비스를 제공하는데, 클라이언트가 할인의 종류(rate, fix)를 선택할 수 있음.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class AllBeanTest {      @Test     void findAllBean() {         ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);          DiscountService discountService = ac.getBean(DiscountService.class);         Member member = new Member(1L, \"userA\", Grade.VIP);         int discountPrice = discountService.discount(member, 10000, \"fixDiscountPolicy\");          assertThat(discountService).isInstanceOf(DiscountService.class);         assertThat(discountPrice).isEqualTo(1000);          int rateDiscountPrice = discountService.discount(member, 20000, \"rateDiscountPolicy\");         assertThat(rateDiscountPrice).isEqualTo(2000);     }      static class DiscountService {          private final Map&lt;String, DiscountPolicy&gt; policyMap;         private final List&lt;DiscountPolicy&gt; policies;          public DiscountService(Map&lt;String, DiscountPolicy&gt; policyMap, List&lt;DiscountPolicy&gt; policies) {             this.policyMap = policyMap;             this.policies = policies;         }          public int discount(Member member, int price, String discountCode) {             DiscountPolicy discountPolicy = policyMap.get(discountCode);             return discountPolicy.discount(member, price);         }     }  }      Map을 통해 DiscountPolicy 타입의 빈들을 주입받는다. (여기서는 fixDiscountPolicy, rateDiscountPolicy가 주입됨)   discount() 메서드에 discountCode로 fixDiscountPolicy가 넘어오면 fixDiscountPolicy 빈을 실행한다. rateDiscountPolicy도 마찬가지다.      참고   DiscountService를 사용할 때 @Component를 붙이지 않는 이유는 AnnotationConfigApplicationContext(DiscountService.class) 코드가 스프링 컨테이너에 스프링 빈을 등록하는 코드이기 때문이다.     자동, 수동의 올바른 실무 운영 기준   실무에서 스프링 빈을 등록과 의존관계 주입은 default를 자동으로 한다.   스프링은 점점 자동을 선호하는 추세이다. @Component 뿐만 아니라 @Controller, @Service, @Repository 등도 자동으로 스캔할 수 있도록 지원한다. 최근 스프링 부트는 컴포넌트 스캔을 기본으로 사용한다. 자동으로 관리하면 설정 정보를 관리할 때 편의성이 있다. 또한 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.   그러면 수동 빈 등록은 언제 사용하면 좋을까?   애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.   업무 로직 빈   웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다. 이 경우에 자동 빈 등록을 권장한다.   기술 지원 빈   기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다. 기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 드러내는 것이 좋다.      참고 기술 지원 빈   objectMapper, modelMapper에 @Bean을 등록한 경우도 기술 지원 빈이라 한다. 그러나, 이는 AOP는 아니다. (AOP는 프록시를 사용해야 하는데 objectMapper, modelMapper는 코드에 직접 사용했으므로 AOP가 아니다.)     즉, 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.   비즈니스 로직 중에서 다형성을 적극 활용할 때는 수동 등록해주는 것이 좋다. 아래 예제를 살펴보면 Map&lt;String, DiscountPolicy&gt;에 어떤 빈들이 주입될지 코드만 보고 한번에 쉽게 파악하기 어렵다. 자동 등록을 사용하고 있기 때문에 여러 코드를 찾아봐야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 static class DiscountService {     private final Map&lt;String, DiscountPolicy&gt; policyMap;     private final List&lt;DiscountPolicy&gt; policies;      public DiscountService(Map&lt;String, DiscountPolicy&gt; policyMap, List&lt;DiscountPolicy&gt; policies) {         this.policyMap = policyMap;         this.policies = policies;     }      public int discount(Member member, int price, String discountCode) {         DiscountPolicy discountPolicy = policyMap.get(discountCode);         return discountPolicy.discount(member, price);     } }   이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는게 좋다. 핵심은 코드를 보고 바로 파악이 되어야 한다.   이 부분을 별도의 설정 정보로 만들고 수동으로 등록하면 다음과 같다.   1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class DiscountPolicyConfig {     @Bean     public DiscountPolicy rateDiscountPolicy() {         return new RateDiscountPolicy();     }      @Bean     public DiscountPolicy fixDiscountPolicy() {         return new FixDiscountPolicy();     } }   이처럼 별도의 설정 정보를 만들고 이를 별도의 특정 패키지에 모아두면 코드 파악이 용이하다.   참고로 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외다. 이런 부분들은 스프링 자체를 잘 이해하고 스프링의 의도대로 잘 사용하는게 중요하다. 반면에 스프링 부트가 아니라 내가 직접 기술 지원 객체를 스프링 빈으로 등록한다면 수동으로 등록해서 명확하게 드러내는 것이 좋다.   요약하자면, 편리한 자동 빈 등록을 기본으로 사용하고 직접 등록하는 기술 지원 객체는 수동 등록하자. 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자.  ","categories": ["Spring"],
        "tags": ["Spring","Java"],
        "url": "/spring/Spring-Dependency-Injection/",
        "teaser": ""
      },{
        "title": "API 개발 시 주의할 점 - 기본",
        "excerpt":"   참고   Web Controller Package와 API Controller Package는 분리하는게 좋다      💡 API 요청/응답에 엔티티를 노출하지 않는게 좋다.    API에 엔티티를 노출시킬 경우 발생하는 문제점      실무에서는 회원 엔티티를 위한 API가 다양하게 만들어지는데, 한 엔티티에 각각의 API를 위한 모든 요청 요구사항을 담기는 어렵다.   엔티티가 변경되면 API 스펙이 변한다.       따라서, API 요청 스펙에 맞추어 별도의 DTO를 파라미터로 받는다.   등록 API 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @RestController @RequiredArgsConstructor public class MemberApiController {      private final MemberService memberService;      @PostMapping(\"/api/v1/members\")     public CreateMemberResponse saveMemberV1(@RequestBody @Valid Member member) {         Long id = memberService.join(member);         return new CreateMemberResponse(id);     }      @PostMapping(\"/api/v2/members\")     public CreateMemberResponse saveMemberV2(@RequestBody @Valid CreateMemberRequest request) {         Member member = new Member();         member.setName(request.getName());         Long id = memberService.join(member);         return new CreateMemberResponse(id);     }      @Data     static class CreateMemberRequest {         private String name;     }      @Data     static class CreateMemberResponse {         private Long id;          public CreateMemberResponse(Long id) {             this.id = id;         }     } }   별도의 DTO를 생성할 경우 장점      엔티티와 프레젠테이션 계층을 위한 로직을 분리할 수 있다.   엔티티와 API 스펙을 명확하게 분리할 수 있다.   엔티티가 변해도 API 스펙이 변하지 않는다.      참고   엔티티에는 롬북 애노테이션을 제한해서 사용했다. (@Getter 등)   DTO는 데이터의 요청/응답을 주는 용도이고 크게 로직이 있는 것도 아니기 때문에 엔티티보다 비교적 자유롭게 사용한다.         (참고) JPA 1편 복습   데이터를 수정할 때는 변경감지를 이용한다.   @Transactional이 있는 상태에서 데이터를 조회하면 영속성 컨텍스트에서 데이터를 가져오고 Transactional이 끝난 후 commit 되는 시점에서 변경 감지가 일어난다.   1 2 3 4 5 @Transactional public void update(Long id, String name) {     Member member = memberRepository.findOne(id);     member.setName(name); }      참고 MemberService 코드에서 반환을 Member로 하지 않고 void로 한 이유?   update() 메서드는 갱신해주는 메서드인데 Member를 반환해버리면 조회까지 같이 하는 격이다. 트래픽이 높지 않으면 분리해주는 것이 좋다. (보통 트래픽이 높은 API는 조회 API)     조회 API를 만들때 엔티티를 외부에 노출하면 생기는 문제      실무에서는 회원 엔티티를 위한 API가 다양하게 만들어지는데, 한 엔티티에 각각의 API를 위한 모든 요청 요구사항을 담기는 어렵다.   엔티티가 변경되면 API 스펙이 변한다.   기본적으로 엔티티의 모든 값이 노출된다.   응답 스펙을 맞추기 위해 로직이 추가된다. (@JsonIgnore 같은) → 그럼에도 1번 문제가 발생   추가로 컬렉션을 직접 반환하면 항후 API 스펙을 변경하기 어렵다. (별도의 Result 클래스 생성으로 해결)   1번, 2번은 위에서 언급했으니 넘어가고 3번의 경우는 데이터 조회 시 엔티티를 그대로 노출할 경우 비밀번호 같은 개인정보도 같이 노출될 위험이 있다.   4번의 경우 엔티티로 조회하면 연관관계로 묶여있는 다른 엔티티들도 같이 나온다. @JsonIgnore를 사용해서 제외시킬 수 있지만 여러 API를 만들다 보면 다른 엔티티가 필요한 순간도 있다. 이처럼 케이스가 다양하기 때문에 문제가 발생할 수 밖에 없다. 또한, 엔티티가 변경되면 API 스펙도 변경된다.   5번의 경우 엔티티를 반환하게 되면 Array를 반환하게 된다. 이는 확장성이 매우 떨어진다. 만약, 데이터 리스트와 조회한 데이터 개수를 같이 반환하고 싶어도 데이터 리스트가 Array로 반환되었기때문에 데이터 개수를 추가로 반환할 수 없다. (확장성이 매우 떨어진다.)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 엔티티를 그대로 반환 [     // 에러발생!!     //\"count\": 3,     {         \"id\": 1,         \"name\": \"new-hello\",         \"address\": null     },     {         \"id\": 2,         \"name\": \"member1\",         \"address\": {             \"city\": \"서울\",             \"street\": \"11\",             \"zipcode\": \"111\"         }     } ]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 별도의 result 클래스를 생성하여 해결 {     \"count\": 3,     \"data\": [ \t      { \t          \"id\": 1, \t          \"name\": \"new-hello\", \t          \"address\": null \t      }, \t      { \t          \"id\": 2, \t          \"name\": \"member1\", \t          \"address\": { \t              \"city\": \"서울\", \t              \"street\": \"11\", \t              \"zipcode\": \"111\" \t          }   \t    }     ] }    아래 코드와 같이 엔티티를 DTO로 변환해서 반환한다. 추가로 Result 클래스로 컬렉션을 감싸서 향후 필요한 필드를 추가할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @GetMapping(\"/api/v2/members\") public Result member2V1() {     List&lt;Member&gt; findMembers = memberService.findMembers();     List&lt;MemberDTO&gt; collect = findMembers.stream()             .map(m -&gt; new MemberDTO(m.getName()))             .collect(Collectors.toList());      return new Result(collect.size(), collect); }  @Data @AllArgsConstructor static class Result&lt;T&gt; {     private int count;     private T data; }  @Data @AllArgsConstructor static class MemberDTO {     private String name; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 {     \"count\": 3,     \"data\": [         {             \"name\": \"new-hello\"         },         {             \"name\": \"member1\"         },         {             \"name\": \"member2\"         }     ] }   API 스펙은 노출할 것만 노출해야한다. 즉, API 스펙은 DTO와 1:1이다. 유지보수 관점에서도 DTO를 사용하는 것이 매우 좋다.   엔티티는 절대 노출하지말자! 꼭 API에 맞는 스펙의 DTO를 생성할 것!  ","categories": ["Spring"],
        "tags": ["Spring","JPA"],
        "url": "/spring/SpringBoot-API-Notes/",
        "teaser": ""
      },{
        "title": "페치 조인 (fetch join)",
        "excerpt":" 💡 실무에서 정말 중요하다. 필수적으로 알아야 하는 내용!    페치 조인   페치 조인이란 JPQL에서 성능 최적화를 위해 제공하는 기능이며 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능이다. SQL 조인 종류 아니며 JPA에서만 사용한다. join fetch 명령어를 사용하며 사용법은 아래와 같다.   1 [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로       엔티티 페치 조인 예시   1 2 3 4 5 # 기존 SQL select m.*, t.* from Member m inner join Team t on m.team_id = t.id  # JPQL select m from Member m **join fetch** m.team   페치 조인을 사용하면 연관된 테이블을 한번에 조회 할 수 있다.   상황만 보면 즉시로딩과 비슷하다. 그러나, 페치조인은 쿼리를 내가 원하는 데이터만을 한번에 조회할 것이라는 것을 명시적으로 동적인 타이밍에 정할 수 있다.   또한, 연관관계 설정이 LAZY로 되어있다고 해도 페치 조인을 우선 시 한다.   페치 조인을 사용하여 1 + N 문제를 해결할 수 있다.       컬렉션 페치 조인   1:N 관계에서의 페치 조인이다.      1 select t from Team t join fetch t.members;   결과를 보면 중복이 된다. 이 경우 distinct를 사용하여 중복을 제거할 수 있다. JPQL에서 distinct를 사용하면 SQL에서의 distinct 기능 뿐만 아니라, 엔티티의 중복까지 제거해준다.       페치 조인 주의사항      페치 조인 대상에는 별칭을 줄 수 없다. 하이버네이트 구현체에서는 사용이 가능하지만 가급적 사용하지 않는 것이 좋다.   둘 이상의 컬렉션은 페치 조인 할 수 없다.   컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.  ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-Fetch-Join/",
        "teaser": ""
      },{
        "title": "컬렉션 조회 최적화",
        "excerpt":"컬렉션인 일대다 관계(OneToMany)를 조회하고, 최적화하는 방법을 알아보자. (*ToOne 보다 신경 쓸게 많다.)   [예제] Order와 Member는 다대일 연관관계(양방향), Order와 Delivery는 다대일 연관관계(양방향)가 되어있고, Member와 Delivery는 지연 로딩이 설정되어 있다. 주문내역에서 추가로 주문한 상품 정보를 추가로 조회하자. Order 기준으로 컬렉션인 OrderItem 와 Item 이 필요하다.   엔티티를 DTO로 변환하면 마찬가지로 1 + N + N 문제가 생긴다. 이를 해결하기 위해 fetch join을 사용한다.      참고   DTO로 만들어야 한다는 것은 단순하게 겉 껍질(order)만 DTO로 만들라는게 아니다. 내부의 엔티티(orderItems)까지 모두 DTO로 만들어야 한다는 것을 의미한다.        참고   지연 로딩은 영속성 컨텍스트에 있으면 영속성 컨텍스트에 있는 엔티티를 사용하고 없으면 SQL을 실행한다. 따라서 같은 영속성 컨텍스트에서 이미 로딩한 회원 엔티티를 추가로 조회하면 SQL을 실행하지 않는다.     엔티티를 DTO로 변환 - 페치 조인 최적화   페치 조인 최적화   1 2 3 4 5 6 7 8 9 10 // OrderApiController.java @GetMapping(\"/api/v3/orders\") public List&lt;OrderDto&gt; ordersV3() {     List&lt;Order&gt; orders = orderRepository.findAllWithItem();      List&lt;OrderDto&gt; result = orders.stream()             .map(o -&gt; new OrderDto(o))             .collect(Collectors.toList());     return result; }   일대다 조인을 하면 다에 초점이 맞춰져 데이터 개수가 증가한다. 예를 들어 조인문 앞에 테이블의 row가 2, 조인문 뒤에 테이블의 row가 4라면 4로 증가한다.      JPQL에서 distinct를 사용하면 중복을 제거해준다.   1 2 3 4 5 6 7 8 9 10 // OrderRepository.java public List&lt;Order&gt; findAllWithItem() {     return em.createQuery(             \"select distinct o from Order o\" +                     \" join fetch o.member m\" +                     \" join fetch o.delivery d\" +                     \" join fetch o.orderItems oi\" +                     \" join fetch oi.item i\", Order.class)             .getResultList(); }   SQL의 distinct는 row의 모든 필드가 중복되어야 중복을 제거해준다. 그러나, JPA의 distinct는 JPA에서 자체적으로 기준이 되는 엔티티가 중복이 되면 제거를 해준다. 여기선 기준이 되는 엔티티가 Order 엔티티이다. (from 다음에 나오는 엔티티, root entity라고도 한다.)      참고   실무에서 복잡한 쿼리를 짤때는 QueryDSL을 이용하자 문자열로 짜는 JPQL은 오류를 잡기 어렵지만 QueryDSL을 사용하면 문자열 오류, 공백 등을 신경쓰지 않고 코드를 작성할 수 있다는 장점이 있다.     페치 조인으로 SQL이 1번만 실행된다. distinct를 사용한 이유는 일대다 조인이 있으므로 데이터베이스 row가 증가한다. 그 결과 같은 order 엔티티의 조회 수도 증가하게 된다. JPA의 distinct는 SQL에 distinct를 추가하고, 더해서 같은 엔티티가 조회되면, 애플리케이션에서 중복을 걸러준다. 이 예제에선 order가 컬렉션 페치 조인 때문에 중복 조회 되는 것을 막아준다.   하지만, 페이징이 불가능하다는 치명적인 단점이 있다. setFirstResult(), setMaxResults() 적용이 안된다.      참고   컬렉션 페치 조인을 사용하면 페이징이 불가능하다. 하이버네이트는 경고 로그를 남기면서 모든 데이터를 DB에서 읽어오고, 메모리에서 페이징 해버린다 (매우 위험하다).        참고   컬렉션 페치 조인은 1개만 사용할 수 있다. 컬렉션 둘 이상에 페치 조인을 사용하면 안된다. 데이터가 부정합하게 조회될 수 있다.     일대다 페치조인에서는 페이징을 절대 사용하면 안된다.   페이징과 한계 돌파   대부분의 페이징 + 컬렉션 엔티티 조회 문제는 다음에서 설명하는 방법으로 해결할 수 있다.   먼저, ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인 한다. ToOne 관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다. 그 후, 컬렉션(ToMany)은 지연 로딩으로 조회한다. 지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize 를 적용한다.      hibernate.default_batch_fetch_size: 글로벌 설정   @BatchSize: 개별 최적화   이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.   default_batch_fetch_size 설정   application.yml   1 jpa.hibernate.properties.hibernate.default_batch_fetch_size: 100   설정 후 쿼리 결과   1 2 3 4 5 6 7 8 9 ... 2022-08-14 01:10:22.984  INFO 31396 --- [nio-8080-exec-4] p6spy                                    : #1660407022984 | took 1ms | statement | connection 8| url jdbc:h2:tcp://localhost/~/jpashop select orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.count as count2_5_0_, orderitems0_.item_id as item_id4_5_0_, orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_price as order_pr3_5_0_ from order_item orderitems0_ where orderitems0_.order_id in (?, ?) select orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.count as count2_5_0_, orderitems0_.item_id as item_id4_5_0_, orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_price as order_pr3_5_0_ from order_item orderitems0_ where orderitems0_.order_id in (4, 11); 2022-08-14 01:10:22.996 DEBUG 31396 --- [nio-8080-exec-4] org.hibernate.SQL                        :  ... 2022-08-14 01:10:22.998  INFO 31396 --- [nio-8080-exec-4] p6spy                                    : #1660407022998 | took 0ms | statement | connection 8| url jdbc:h2:tcp://localhost/~/jpashop select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id in (?, ?, ?, ?) select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id in (2, 3, 9, 10);   default_batch_fetch_size를 설정하면 쿼리 호출 수가 1 + N → 1 + 1로 최적화 된다. 조인보다 DB 데이터 전송량이 최적화 된다. (Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.) 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다. 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.   정리하자면, ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지(컬렉션)는 hibernate.default_batch_fetch_size로 최적화 하자.   @BatchSize   개별로 설정하려면 @BatchSize를 적용하면 된다. (컬렉션은 컬렉션 필드에, 엔티티는 엔티티 클래스에 적용)   1 2 3 4 5 6 7 8 9 10 11 12 13 // Order.java  // ToMany 일 때는 연관관계 위치에 작성한다. @BatchSize(size = 1000) @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL) private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();  // ToOne 일 때는 엔티티 class 부분에서 작성한다. @BatchSize(size = 100) @Entity @Getter @Setter public abstract class Item {}    그냥 default_batch_fetch_size 사용하자!      참고   default_batch_fetch_size 의 크기는 적당한 사이즈를 골라야 하는데, 100~1000 사이를 선택하는 것을 권장한다. 이 전략을 SQL IN 절을 사용하는데, 데이터베이스에 따라 IN 절 파라미터를 1000으로 제한하기도 한다. 1000으로 잡으면 한번에 1000개를 DB에서 애플리케이션에 불러오므로 DB 에 순간 부하가 증가할 수 있다. 하지만 애플리케이션은 100이든 1000이든 결국 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다. 1000으로 설정하는 것이 성능상 가장 좋지만, 결국 DB든 애플리케이션이든 순간 부하를 어디까지 견딜 수 있는지로 결정하면 된다.     여기까지 하면 JPA와 관련된 성능최적화는 90%는 해결이 된다.   JPA에서 DTO 직접 조회   쿼리는 루트 1번, 컬렉션 N 번 실행된다. ToOne(N:1, 1:1) 관계들을 먼저 조회하고, ToMany(1:N) 관계는 각각 별도로 처리한다.   이런 방식을 선택한 이유는 다음과 같다.      ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다.   ToMany(1:N) 관계는 조인하면 row 수가 증가한다.   row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화하기 쉬우므로 한번에 조회하고, ToMany 관계는 최적화 하기 어려우므로 findOrderItems() 같은 별도의 메서드로 조회한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public List&lt;OrderQueryDto&gt; findOrderQueryDtos() {     List&lt;OrderQueryDto&gt; result = findOrders(); // query 1번 -&gt; N개     result.forEach(o -&gt; {         List&lt;OrderItemQueryDto&gt; orderItems = findOrderItems(o.getOrderId()); // Query N번         o.setOrderItems(orderItems);     });     return result; }  private List&lt;OrderQueryDto&gt; findOrders() {     return em.createQuery(                     \"select new jpabook.jpashop.repository.order.query.OrderQueryDto(o.id, m.name, o.orderDate, o.status, d.address)\" +                             \" from Order o\" +                             \" join o.member m\" +                             \" join o.delivery d\", OrderQueryDto.class)             .getResultList(); }  private List&lt;OrderItemQueryDto&gt; findOrderItems(Long orderId) {     return em.createQuery(                     \"select new jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count)\" +                             \" from OrderItem oi\" +                             \" join oi.item i\" +                             \" where oi.order.id = :orderId\", OrderItemQueryDto.class             )             .setParameter(\"orderId\", orderId)             .getResultList(); }   컬렉션 조회 최적화   쿼리는 루트 1번, 컬렉션 1번 실행된다. ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 orderId로 ToMany 관계인 OrderItem을 한꺼번에 조회하자. MAP을 사용해서 매칭 성능 향상(O(1))   플랫 데이터 최적화   쿼리는 1번 실행된다. 하지만, 조인으로 인해 DB에서 애플리케이션에 전달하는 데이터에 중복 데이터가 추가되므로 상황에 따라 컬렉션 조회 최적화 보다 더 느릴 수 도 있다. 또한 애플리케이션에서 추가 작업이 크다. 페이징 불가능하다.   정리   엔티티 조회 방식 접근 순서      엔티티 조회 방식으로 우선접근            페치조인으로 쿼리 수를 최적화       컬렉션 최적화                    페이징 필요 → hibernate.default_batch_fetch_size , @BatchSize 로 최적화           페이징 필요X → 페치 조인 사용                           엔티티 조회 방식으로 해결이 안되면 DTO조회 방식 사용   DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate      참고 엔티티 조회 방식은 페치 조인이나, hibernate.default_batch_fetch_size , @BatchSize 같이 코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다. 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.        참고 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다. 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화 할 수 있다. 반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야 한다.     DTO 조회 방식의 선택지      DTO로 조회하는 방법도 각각 장단이 있다. V4, V5, V6에서 단순하게 쿼리가 1번 실행된다고 V6이 항상 좋은 방법인 것은 아니다.   V4는 코드가 단순하다. 특정 주문 한건만 조회하면 이 방식을 사용해도 성능이 잘 나온다. 예를 들어서 조회한 Order 데이터가 1건이면 OrderItem을 찾기 위한 쿼리도 1번만 실행하면 된다.   V5는 코드가 복잡하다. 여러 주문을 한꺼번에 조회하는 경우에는 V4 대신에 이것을 최적화한 V5 방식을 사용해야 한다. 예를 들어서 조회한 Order 데이터가 1000건인데, V4 방식을 그대로 사용하면, 쿼리가 총 1 + 1000번 실행된다. 여기서 1은 Order 를 조회한 쿼리고, 1000은 조회된 Order의 row 수다. V5 방식으로 최적화 하면 쿼리가 총 1 + 1번만 실행된다. 상황에 따라 다르겠지만 운영 환경에서 100배 이상의 성능 차이가 날 수 있다.   V6는 완전히 다른 접근방식이다. 쿼리 한번으로 최적화 되어서 상당히 좋아보이지만, Order를 기준으로 페이징이 불가능하다. 실무에서는 이정도 데이터면 수백이나, 수천건 단위로 페이징 처리가 꼭 필요하므로, 이 경우 선택하기 어려운 방법이다. 그리고 데이터가 많으면 중복 전송이 증가해서 V5와 비교해서 성능 차이도 미비하다.  ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-JPA-Collections-Performance-Optimization/",
        "teaser": ""
      },{
        "title": "JPA 조회 성능 최적화",
        "excerpt":"조회 성능 최적화 부분은 매우 중요하다. 실무에서 JPA를 사용하려면 100% 이해해야 한다.   페치 조인(fetch join) (링크)   페치 조인이란 JPQL에서 성능 최적화를 위해 제공하는 기능이다. 페치 조인은 JPA에만 있는 문법으로 SQL의 조인 종류와는 다르다. 페치 조인으로 데이터를 가져오면 지연로딩으로 설정되어 있어도 무시하고 프록시 객체가 아닌 진짜 객체를 가져온다.   예제. Order와 Member는 다대일 연관관계(양방향), Order와 Delivery는 다대일 연관관계(양방향)가 되어있고, Member와 Delivery는 지연 로딩이 설정되어 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @GetMapping(\"/api/v2/simple-orders\") public List&lt;SimpleOrderDto&gt; ordersV2() {     List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());     List&lt;SimpleOrderDto&gt; result = orders.stream()             .map(o -&gt; new SimpleOrderDto(o))             .collect(Collectors.toList());      return result; }  @Data static class SimpleOrderDto {     private Long orderId;     private String name;     private LocalDateTime orderDate;     private OrderStatus orderStatus;     private Address address;      public SimpleOrderDto(Order order) {         orderId = order.getId();         name = order.getMember().getName();         orderDate = order.getOrderDate();         orderStatus = order.getStatus();         address = order.getDelivery().getAddress();     } }   엔티티를 DTO로 변환하는 일반적인 방법이다. 위의 코드는 쿼리가 총 1 + N + N번 실행된다.      1번: Order 조회 1번   N번: Order → Member 지연 로딩 조회 N번   N번: Order → Delivery 지연 로딩 조회 N번   지연 로딩은 영속성 컨텍스트에서 조회하므로, 이미 조회된 경우 쿼리를 생략한다. 그러나, 이 경우에는 id값이 달랐기 때문에 N번 조회한다.   정리하자면, 쿼리가 1 + N + N번 실행되는 원인은 JPA의 지연로딩 매커니즘 때문이다.   그렇다면 이 문제를 어떻게 해결해야 할까?   페치 조인 적용   1 2 3 4 5 6 7 8 @GetMapping(\"/api/v3/simple-orders\") public List&lt;SimpleOrderDto&gt; ordersV3() {     List&lt;Order&gt; orders = orderRepository.findAllWithMemberDelivery();     List&lt;SimpleOrderDto&gt; result = orders.stream()             .map(o -&gt; new SimpleOrderDto(o))             .collect(toList());     return result; }   1 2 3 4 5 6 7 8 9 // memberRepository에 추가 // jpql public List&lt;Order&gt; findAllWithMemberDelivery() {       return em.createQuery(               \"select o from Order o\" +               \" join fetch o.member m\" +               \" join fetch o.delivery d\", Order.class)              .getResultList(); }   엔티티를 페치 조인을 사용해서 가져오면 쿼리 1번에 조회가 가능하다. 페치 조인으로 데이터를 가져오면 지연 로딩으로 설정되어 있어도 무시하고 프록시 객체가 아닌 진짜 객체를 가져온다.      참고 원래는 List로 반환하면 안되고 Result로 감싸서 반환해야 한다. 지금은 예제이기 때문에 이렇게 진행한다.     JPA에서 DTO 직접 조회   DTO로 바로 조회하면 선택한 컬럼만 가져올 수 있다. 일반적인 SQL을 사용할 때처럼 원하는 값을 선택해서 조회할 수 있다. new 명령어를 사용해서 JPQL의 결과를 DTO로 즉시 변환한다. 선택한 컬럼만 가져오면 성능 최적화를 할 수 있다는 장점이 있지만 리포지토리 재사용성이 떨어진다는 단점이 있다.   1 2 3 4 @GetMapping(\"/api/v4/simple-orders\") public List&lt;OrderSimpleQueryDto&gt; ordersV4() {     return orderSimpleQueryRepository.findOrderDtos(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Repository @RequiredArgsConstructor public class OrderSimpleQueryRepository {      private final EntityManager em;      public List&lt;OrderSimpleQueryDto&gt; findOrderDtos() {         return em.createQuery(                         \"select new jpabook.jpashop.repository.order.simplequery.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) \" +                                 \" from Order o\" +                                 \" join o.member m\" +                                 \" join o.delivery d\", OrderSimpleQueryDto.class)                 .getResultList();     } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Data public class OrderSimpleQueryDto {     private Long orderId;     private String name;     private LocalDateTime orderDate;     private OrderStatus orderStatus;     private Address address;      public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address) {         this.orderId = orderId;         this.name = name;         this.orderDate = orderDate;         this.orderStatus = orderStatus;         this.address = address;     } }   DTO 조회 전용 리포지토리를 만든 이유는 유지보수 라이프 사이클이 다르기 때문이다. 엔티티를 반환하는 핵심 로직과 특정 API에 의존적인 로직의 라이프 사이클은 다르다. 따라서, 엔티티 반환 로직과 DTO 반환 로직을 분리하는게 좋다.      OrderRepository: 엔티티만 조회, 특정 API에 의존적이지 않다.   OrderSimpleQueryRepository: DTO 조회 전용, 특정 API에 의존적이다.   쿼리 방식 선택 권장 순서      우선 엔티티를 DTO로 변환하는 방법을 선택한다.   필요하면 페치 조인으로 성능을 최적화 한다. 대부분의 성능 이슈가 해결된다.   그래도 안되면 DTO로 직접 조회하는 방법을 사용한다.   최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.  ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-JPA-Performance-Optimization/",
        "teaser": ""
      },{
        "title": "OSIV와 성능 최적화",
        "excerpt":"OSIV(Open Session In View)   OSIV란 영속성 컨텍스트를 뷰까지 열어두는 기능이다. 영속성 컨텍스트가 유지되면 엔티티도 영속 상태로 유지된다. 뷰까지 영속성 컨텍스트가 살아있다면 뷰에서도 지연 로딩을 사용할 수가 있다.   하이버네이트에서는 OSIV(Open Session In View), JPA에서는 Open EntityManager In View라 한다. 하지만, 관례상 OSIV라 한다. OSIV를 알아야한다. 이것을 모르면 장애로 이어질 수 있다.   OSIV 동작 원리   스프링 프레임워크가 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV다. 영속성 컨텍스트는 사용자의 요청 시점에서 생성이 되지만, 데이터를 쓰거나 수정할 수 있는 트랜잭션은 비즈니스 계층에서만 사용할 수 있도록 트랜잭션이 일어난다.      참고 JPA가 데이터베이스 커넥션을 가져오고 반환하는 시점?   JPA의 영속성 컨텍스트는 데이터베이스 커넥션과 밀접한 연관이 있다. 영속성 컨텍스트는 데이터베이스 커넥션을 1:1로 쓰면서 동작한다. 그렇다면 영속성 컨텍스트는 언제 데이터베이스 커넥션을 가져올까? 데이터베이스 트랜잭션을 시작할 때 JPA의 영속성 컨텍스트가 데이터베이스 커넥션을 가져온다. 그리고 언제 커넥션을 반환할까? OSIV가 ON일 때는 모든 응답이 끝나고나면 반환되고 OSIV가 OFF일 때는 트랜잭션이 종료되는 시점에 같이 종료된다.     OSIV ON         spring.jpa.open-in-view : true, 기본값   spring.jpa.open-in-view의 값을 기본값(true)으로 애플리케이션을 구동하면, 애플리케이션 시작 시점에 warn 로그가 남는다. 프록시를 초기화하는 작업을 Service 계층에서 끝내지 않고도 렌더링 시 자동으로 해결하게 해주는 장점이 있는 OSIV 전략에 왜 경고를 줄까?   1 2022-08-16 13:41:55.714  WARN 38189 --- [  restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning   OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지한다. 그래서 지금까지 View Template이나 API 컨트롤러에서 지연 로딩이 가능했던 것이다.   지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. 이것 자체가 큰 장점이다.   그런데 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다.(커넥션이 마른다고 표현.) 이것은 결국 장애로 이어진다.   예를 들어서 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다. OSIV의 치명적인 단점이다.   OSIV OFF         spring.jpa.open-in-view : false, OSIV 종료   OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고(em.flush(), em.commit()), 데이터베이스 커넥션도 반환한다. 따라서, 커넥션 리소스를 낭비하지 않는다.   OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야 하는 단점이 있다. 그리고 view template에서 지연로딩이 동작하지 않는다. 결론적으로 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.   OSIV를 OFF 시킨 상태에서 Controller에서 지연 로딩을 할 경우 에러 로그   1 2 3 4 5 6 7 8 org.hibernate.LazyInitializationException: could not initialize proxy [jpabook.jpashop.domain.Member#1] - no Session \tat org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:170) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final] \tat org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:310) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final] \tat org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final] \tat org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final] \tat jpabook.jpashop.domain.Member$HibernateProxy$fTKfJLZN.getName(Unknown Source) ~[main/:na] \tat jpabook.jpashop.api.OrderApiController.ordersV1(OrderApiController.java:33) ~[main/:na] ...   해결 방안은 OSIV를 ON 하거나, 트랜잭션 안에서 지연로딩을 하거나, 페치 조인을 쓰는 방법이 있다.   커멘드와 쿼리 분리   실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법이 있다. 바로 Command와 Query를 분리하는 것이다.   보통 비즈니스 로직은 특정 엔티티 몇 개를 등록하거나 수정하는 것이므로 성능이 크게 문제가 되지 않는다. 그런데 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하다. 하지만 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아니다. 그래서 크고 복잡한 애플리케이션을 개발한다면, 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미 있다.   단순하게 설명해서 다음처럼 분리하는 것이다.      OrderService            OrderService: 핵심 비즈니스 로직       OrderQueryService: 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트랜잭션 사용)           보통 서비스 계층에서 트랜잭션을 유지한다. 두 서비스 모두 트랜잭션을 유지하면서 지연 로딩을 사용할 수 있다.      참고   고객 서비스의 실시간 API(트래픽이 많은 경우)는 OSIV를 끄고, ADMIN 처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켜는 방식으로 개발을 진행하는 것이 좋다.        참고 커맨드와 쿼리의 분리   Command Query Separation(CQS)를 의미하며 DB의 데이터를 업데이트하는 명령과 조회하는 쿼리를 분리하는 패턴이다. 이 메서드를 호출 했을 때, 내부에서 변경(사이드 이펙트)가 일어나는 메서드인지, 아니면 내부에서 변경이 전혀 일어나지 않는 메서드인지 명확히 분리하는 것. 권장하는 방법은 insert는 id만 반환하고(아무것도 없으면 조회가 안되니), update는 아무것도 반환하지 않고, 조회는 내부의 변경이 없는 메서드로 설계하면 좋다. 이 개념은 개발 전반에 기본개념으로 깔고 가는 것이 좋다.        참고 CQRS 패턴   CQRS 패턴이란, 우리가 보통 이야기하는 CRUD(Create, Read, Update, Delete)에서 CUD(Command)와 R(Query)을 구분하자는 이야기다. 구분하는 이유는, 우리가 Database로부터 데이터를 읽어오고 처리를 하게 되면 이미 그 사이에 데이터가 변경이 되었을 가능성이 높다. CQRS는 이런 변경 가능성을 인정하고 어차피 Read와 CUD 사이에는 delay가 존재할 수 있음을 인정하는 것이다. 이를 통해서 R과 CUD를 구분함으로써 얻는 이점을 설명하는 것이 CQRS패턴이다.    ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-OSIV/",
        "teaser": ""
      },{
        "title": "Auditing (공통 매핑 정보)",
        "excerpt":"@MappedSuperclass   공통 매핑 정보가 필요할 때 사용한다. 해당 어노테이션이 적용된 클래스는 테이블로 생성하지 않고 해당 클래스를 상속한 엔티티의 클래스로 데이터베이스 테이블이 생성된다. 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장한다.  테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 하며 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 @MappedSuperclass @EntityListeners(value = {AuditingEntityListener.class}) @Getter abstract class BaseEntity {      @CreatedDate     @Column(name = \"created_at\", updatable = false)     private LocalDateTime createdAt;      @LastModifiedDate     @Column(name = \"updated_at\")     private LocalDateTime updatedAt; }   엔티티 객체에 어떤 변화가 일어나는 것을 감지하는 리스너가 있다. JPA 내부에서 엔티티 객체가 생성/변경되는 것을 감지하는 역할은 AuditingEntityListener로 이루어진다.   @CreatedDate 는 생성시간, @LastModifiedDate 는 최종 수정 시간을 처리 속성으로 insertable, updateable 등이 있는데 updateable = false 로 지정하면 객체를 데이터베이스에 반영할 때 create_at 컬럼값은 변경되지 않는다.   AuditingEntityListener를 활성화시키기 위해 프로젝트의 @EnableJpaAuditing 설정을 추가한다.   1 2 3 4 5 6 7 8 @SpringBootApplication @EnableJpaAuditing public class BoardApplication {      public static void main(String[] args) {         SpringApplication.run(BoardApplication.class, args);     } }   정리하자면, @EnableJpaAuditing 스프링 부트 설정 클래스에 적용하고 @EntityListeners(AuditingEntityListener.class)는 엔티티에 적용한다.   Auditing   작성일, 수정일은 대부분의 엔티티에서 필요하다. 그러나, 작성자, 수정자의 경우 필요 없을 경우를 생각해 분리해서 작성하자.   1 2 3 4 5 6 7 8 9 10 11 12 @EntityListeners(AuditingEntityListener.class) @MappedSuperclass @Getter public class BaseEntity extends BaseTimeEntity {      @CreatedBy     @Column(updatable = false)     private String createdBy;      @LastModifiedBy     private String lastModifiedBy; }   1 2 3 4 5 6 7 8 9 10 11 12 @EntityListeners(AuditingEntityListener.class) @MappedSuperclass @Getter public class BaseTimeEntity {      @CreatedDate     @Column(updatable = false)     private LocalDateTime createdDate;      @LastModifiedDate     private LocalDateTime lastModifiedDate; }   1 2 3 4 5 6 7 8 9 10 11 12 13 @EnableJpaAuditing @SpringBootApplication public class DataJpaApplication {  \tpublic static void main(String[] args) { \t\tSpringApplication.run(DataJpaApplication.class, args); \t}  \t@Bean \tpublic AuditorAware&lt;String&gt; auditorProvider() { \t\treturn () -&gt; Optional.of(UUID.randomUUID().toString()); \t} }   등록자, 수정자를 처리해주는 AuditorAware 스프링 빈을 등록한다. (실무에서는 세션 정보나, 스프링 시큐리티 로그인 정보에서 ID를 받는다.)      참고 실무에서 대부분의 엔티티는 등록시간, 수정시간이 필요하지만, 등록자, 수정자는 없을 수도 있다. 그래서 위와 같이 Base 타입을 분리하고, 원하는 타입을 선택해서 상속한다.        참고 저장시점에 등록일, 등록자는 물론이고, 수정일, 수정자도 같은 데이터가 저장된다. 데이터가 중복 저장되는 것 같지만, 이렇게 해두면 변경 컬럼만 확인해도 마지막에 업데이트한 유저를 확인 할 수 있으므로 유지보수 관점에서 편리하다. 이렇게 하지 않으면 변경 컬럼이 null 일때 등록 컬럼을 또 찾아야 한다. 참고로 저장시점에 저장데이터만 입력하고 싶으면 @EnableJpaAuditing(modifyOnCreate = false) 옵션을 사용하면 된다.    ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-Auditing/",
        "teaser": ""
      },{
        "title": "엔티티 매니저 팩토리와 엔티티 매니저",
        "excerpt":"엔티티 매니저 팩토리   엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용한다.   엔티티 매니저   엔티티 매니저 팩토리에서 엔티티 매니저 생성한다.   엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록, 수정, 삭제, 조회 등 엔티티와 관련된 작업을 수행한다. 엔티티 매니저는 DB 커넥션과 밀접한 관계가 있으므로 쓰레드간에 공유하거나 재사용하면 안된다. JPA의 모든 데이터를 변경하는 작업은 트랜잭션 안에서 사용해야 한다.   @PersistenceContext를 통해 EntityManager를 주입 받아 사용한다.   1 2 @PersistenceContext EntityManager em;          JPA 동작 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.EntityTransaction; import javax.persistence.Persistence;  public class JpaMain {      public static void main(String[] args) {         // 엔티티 매니저 팩토리 생성         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         // 엔티티 매니저 생성         EntityManager em = emf.createEntityManager();          //트랜잭션         EntityTransaction tx = em.getTransaction();         tx.begin();          //code         try {             ...             tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close(); // 엔티티 매니저 종료         }          emf.close();// 엔티티 매니저 팩토리 종료     } }  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-EntityManger/",
        "teaser": ""
      },{
        "title": "플러시",
        "excerpt":"영속성 컨텍스트의 변경내용을 데이터베이스에 반영, 트랜잭션 커밋 될 때 플러시가 발생한다.   플러시 발생      변경 감지   수정된 엔티티 쓰기 지연 SQL 저장소에 등록   쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)   영속성 컨텍스트를 플러시하는 방법      참고    직접 플러시를 할일은 많이 없지만 테스트 시 사용하는 경우가 있기 때문에 알고는 있어야 한다.        em.flush() - 직접 호출   트랜잭션 커밋 - 플러시 자동 호출   JPQL 쿼리 실행 - 플러시 자동 호출   1 2 3 4 5 6 7 Member member = new Member(200L, \"member200\"); em.persist(member); em.flush();  System.out.println(\"=============================\");  tx.commit();   1 2 3 4 5 6 7 8 9 Hibernate:      /* insert hellojpa.Member         */ insert          into             Member             (name, id)          values             (?, ?) =============================      참고 flush()를 하게 되면 1차 캐시가 지워질까?   No! flush()는 단순히 쓰기 지연 SQL 저장소의 쿼리를 DB에 반영하는 역할만 한다.     JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유   1 2 3 4 5 6 7 em.persist(memberA); em.persist(memberB); em.persist(memberC);  // 중간에 JPQL 실행 query = em.createQuery(\"select m from Member m\", Member.class); List&lt;Member&gt; members= query.getResultList();   persist()를 해도 데이터베이스에 insert 되는 시점은 트랜잭션 커밋 시점이므로 원래 같으면 JPQL로 조회 시 데이터가 조회되지 않는다. 이를 방지하기 위해 JPA에서 JPQL 실행 시 자동으로 flush() 후 데이터를 가져오게 되어있다.   플러시 모드 옵션      FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시 (기본값)   FlushModeType.COMMIT: 커밋할 때만 플러시   1 em.setFlushMode(FlushModeType.COMMIT);   정리      플러시는 영속성 컨텍스트를 비우지 않는다.   플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화(Insert) 해준다   트랜잭션이라는 작업 단위가 중요, 커밋 직전에만 동기화 하면 된다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-Flush/",
        "teaser": ""
      },{
        "title": "연관관계의 주인과 mappedBy",
        "excerpt":"양방향 연관관계   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Entity public class Member {     ...     @ManyToOne     @JoinColumn(name = \"TEAM_ID\")     private Team team; }  @Entity public class Team {     ...     @OneToMany(mappedBy = \"team\")     // 초기화 시켜놓으면 add 할때 오류가 안나기 때문에 관례로 이렇게 쓴다     private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); }   1 2 3 4 5 // member가 연관관계의 주인 // 조회 Team findTeam = em.find(Team.class, team.getId());  // 역방향 조회 int memberSize = findTeam.getMembers().size();   연관관계의 주인과 mappedBy   mappedBy를 이해하기 위해선 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.      객체의 양방향 연관관계   객체의 양방향 관계는 서로 다른 단방향 관계 2개이다. 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.   Member와 Team으로 예를 들면, 객체 연관관계는 회원에서 팀을 참조하는 연관관계(단방향)와 팀에서 회원을 참조하는 연관관계(단방향) 총 2개의 객체 연관관계가 있다.   테이블의 양방향 연관관계   테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다.   Member와 Team으로 예를 들면, 테이블의 연관관계는 회원, 팀의 연관관계가 1개이다. MEMBER.TEAM_ID 외래키 하나로 양방향 연관관계를 가진다.(양쪽으로 조인이 가능하다.)   여기서, 연관관계의 주인이 필요한 이유가 나온다.   객체의 양방향 연관관계는 참조값이 2개이다. Member에 있는 Team 값이 업데이트 되었을 때와 Team에 있는 Member값이 업데이트 되었을 때 어떤 외래키 값을 업데이트 해야할지 딜레마가 온다.   연관관계의 주인(Owner)   양방향 매핑 규칙   객체의 두 관계 중 하나를 연관관계의 주인으로 지정해야 한다. 연관관계의 주인만이 외래키를 관리(등록, 수정) 할 수 있고 주인이 아닌 쪽은 읽기만 가능하다. 주인이 아닌 쪽에 mappedBy 속성을 넣어준다.   그렇다면, 누구를 주인으로 해야할까?   외래키가 있는 곳을 주인으로 한다. 예시에서는 Member.team이 연관관계의 주인이다. DB 입장에서 보면 외래키가 있는 곳이 N, 외래키가 없는 곳이 1 이다. 즉, N 이 연관관계의 주인이 되면 된다.   양방향 매핑 시 많이 하는 실수   양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고 주인이 아닌 곳에만 값을 입력하는 것이다.   1 2 3 4 5 6 7 8 9 10 11 Member member = new Member(); member.setName(\"member1\"); em.persist(member);  Team team = new Team(); team.setName(\"TeamA\");  // 주인이 아닌 곳만 연관관계 설정 team.getMembers().add(member);  em.persist(team);   위의 코드처럼 주인이 아닌 곳에만 값을 저장 후 Member 테이블을 조회하면 외래키인 TEAM_ID 값이 null로 저장된다. team은 연관관계의 주인이 아니기 때문에 member값을 넣어줘도 JPA에서 실행하지 않는다. 다시 한 번 강조하지만 연관관계의 주인만이 외래 키 값을 변경할 수 있다.   1 2 3 team.getMembers().add(member); // 연관관계의 주인에 값을 설정! member.setTeam(team)   그렇다면, 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까?   순수한 객체까지 고려한 양방향 연관관계   결론부터 얘기하자면 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자. JPA입장에서 보면 member.setTeam(team)만 해주는게 맞지만, 객체지향의 입장에서 보면 양쪽에 값을 다 줘야한다.   양쪽을 다 설정해주다보면 사람이기 때문에 실수를 할 수 있다. 따라서, 연관관계 편의 메소드를 이용한다.   1 2 3 4 5 6 7 8 9 10 11 12 public class Member {     ...     @ManyToOne     @JoinColumn(name = \"TEAM_ID\")     private Team team;  \t\t// 연관관계 편의 메소드     public void changeTeam(Team team) {         this.team = team;         team.getMembers().add(this);     } }   1 2 3 4 5 6 7 8 9 10 11 Team team = new Team(); team.setName(\"TeamA\"); em.persist(team);  Member member = new Member(); member.setUsername(\"member1\"); member.changeTeam(team); //연관관계 편의 메소드 em.persist(member);  em.flush(); em.clear();   그 밖의 양방향 매핑 시에 주의할 점은 무한 루프를 조심해야 한다.   예를 들면, toString(), lombok, JSON 생성 라이브러리가 있는데 우선, lombok의 toString()은 가급적 사용하지 말자. 또한, API를 만들때 엔티티는 반드시 DTO로 변경해서 반환해야 한다. (실제 실무에서는 가급적 controller에서 엔티티를 사용하면 안된다.)   양방향 매핑 정리   단방향 매핑만으로도 이미 연관관계 매핑은 완료된 것이고 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐이다. (JPQL에서 역방향으로 탐색할 일이 많다.)   단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다. (테이블에 영향을 주지 않는다.) 즉, 설계 시 단방향으로 설계 후 양방향은 개발하면서 필요할 때 추가한다. 연관관계의 주인은 외래키의 위치를 기준으로 정한다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-MappedBy/",
        "teaser": ""
      },{
        "title": "ORM과 JPA, Hibernate",
        "excerpt":"ORM   ORM이란 Object(객체)와 DB의 테이블을 매핑하여 데디터를 객체화하는 기술을 말한다. ORM을 사용하면 개발자가 반복적인 SQL을 직접 작성하지 않아도 되므로 생산성이 높아지고 DBMS에 종속적이지 않다는 장점이 있다. 그러나, 쿼리가 복잡해지면 ORM으로 표현하는데 한계가 있고, 성능이 raw query에 비해 느리다는 단점이 있다.   JPA   JPA란 자바 ORM 기술에 대한 API 표준 명세를 의미한다. JPA는 ORM을 사용하기 위한 인터페이스를 모아둔 것이며, JPA를 사용하기 위해서는 JPA를 구현한 Hibernate, EclipseLink, DataNucleus 같은 ORM 프레임워크를 사용해야 한다.   Hibernate는 JPA의 구현체이다. 즉, JPA는 인터페이스고 Hibernate는 JPA를 구현하는 구현체이다. 많은 구현체 중에서 Hibernate를 주로 사용한다.   JPA를 사용하면 SQL을 직접 작성하지 않아도 되고 객체 중심으로 개발이 가능하다. 또한, 유지보수도 용이하다는 장점이 있다. 하지만, 앞에서 말한 ORM의 단점과 마찬가지로 쿼리가 복잡해지면 한계가 있다. JPA에서는 이를 보완하기 위해 JPQL, QueryDSL 등을 사용하거나 한 프로젝트 내에서 Mybatis와 JPA를 같이 사용하기도 한다.      참고 SQL Mapper Object와 SQL의 필드를 매핑하여 데이터를 객체화 하는 기술이다. SQL문을 직접 작성하고 쿼리 수행 결과를 어떠한 객체에 매핑할지 바인딩 하는 방법이며, DBMS에 종속적인 문제가 있다. 주로 JdbcTemplate, MyBatis 등에서 사용한다.     Hibernate 공식 문서   Your relational data. Objectively. - Hibernate ORM  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-ORM-JPA-Hibernate/",
        "teaser": ""
      },{
        "title": "영속성 컨텍스트",
        "excerpt":"JPA에서 가장 중요한 2가지      객체와 관계형 데이터베이스 매핑하기(ORM, Object Relation Mapping)   영속성 컨텍스트   영속성 컨텍스트   JPA를 이해하는데 가장 중요한 용어이다.   영속성 컨텍스트란 엔티티를 영구 저장하는 환경이라는 뜻이다. 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB 같은 역할을 한다. (영속성 컨텍스트는 논리적인 개념. 눈에 보이지 않는다.) 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있다.   엔티티를 영속성 컨텍스트에 저장   1 entityManager.persist(entity);   J2SE 환경   엔티티 매니저와 영속성 컨텍스트가 1:1      J2EE, 스프링 프레임워크 같은 컨테이너 환경   엔티티 매니저와 영속성 컨텍스트가 N:1         참고 J2SE(Standard Edition)   기본적인 Java의 개발/실행 환경으로 Java언어를 이용하여 어플리케이션(Application), 애플릿(Applet) 그리고 컴포넌트(Component) 등을 개발하고 실행할 수 있는 환경을 제공하는 플랫폼이다.        참고 Java EE(Enterprise Edition)   자바 엔터프라이즈 에디션은 자바를 이용한 서버측 개발을 위한 플랫폼이다. Java EE는 표준 플랫폼인 Java SE를 사용하는 서버를 위한 플랫폼이다. 전사적 차원(대규모의 동시 접속과 유지가 가능한 다양한 시스템의 연동 네트워크 기반 총칭)에서 필요로 하는 도구로 EJB, JSP, Servlet, JNDI 같은 기능을 지원하며 WAS(Web Application Server)를 이용한 프로그램 개발 시 사용된다.         엔티티의 생명주기   비영속(new/transient)   영속성 컨텍스트와 전혀 관계가 없는 새로운 상태이며 객체를 생성만 한 상태이다.   1 2 3 4 //객체를 생성한 상태(비영속)  Member member = new Member();  member.setId(\"member1\");  member.setUsername(\"회원1\");   영속(managed)   영속성 컨텍스트에 저장된 상태이다. 엔티티가 영속성 컨텍스트에 의해 관리되는 상태   1 2 3 4 5 6 7 8 9 10 //객체를 생성한 상태(비영속)  Member member = new Member();  member.setId(\"member1\");  member.setUsername(“회원1”);  EntityManager em = emf.createEntityManager(); em.getTransaction().begin();  //객체를 저장한 상태(영속) em.persist(member);   영속 상태에서는 바로 DB에 저장되지 않는다. 트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들이 DB에 저장된다.   준영속(detached)   영속성 컨텍스트에 저장되었다가 분리된 상태이다.   1 2 //회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태  em.detach(member);   삭제(removed)   삭제된 상태, 실제 DB 삭제를 요청한 상태이다.   1 2 //객체를 삭제한 상태(삭제)  em.remove(member);      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package hellojpa;  import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.EntityTransaction; import javax.persistence.Persistence;  public class JpaMain {      public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");          EntityManager em = emf.createEntityManager();          //트랜잭션         EntityTransaction tx = em.getTransaction();         tx.begin();          //code         try {             //비영속             Member member = new Member();             member.setId(100L);             member.setName(\"HelloJPA\");              //영속             System.out.println(\"=== BEFORE ===\");             em.persist(member);             System.out.println(\"=== AFTER ===\");              tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }          emf.close();     } }   1 2 3 4 5 6 7 8 9 10 === BEFORE === === AFTER === Hibernate:      /* insert hellojpa.Member         */ insert          into             Member             (name, id)          values             (?, ?)   영속성 컨텍스트의 이점   1차 캐시   엔티티를 조회할 때 바로 DB에 접근하는 것이 아니라 1차 캐시를 먼저 조회한다. 이후 DB를 조회하여 데이터가 있다면 1차 캐시에 저장하고 반환한다. 사용자가 10명 있다고 했을 때 1차 캐시를 공유하는 것이 아닌 각각 개별의 1차 캐시를 가지고 있다. 따라서, 성능 상 큰 장점은 없다. (매커니즘의 이점이 있는 것..)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 엔티티를 생성한 상태(비영속) Member member = new Member(); member.setId(2L); member.setName(\"HelloJPA\");  System.out.println(\"=== BEFORE ===\"); // 엔티티를 영속 // 1차 캐시에 저장됨 em.persist(member); System.out.println(\"=== AFTER ===\");  // 1차 캐시에서 조회하기 때문에 select문이 없다 Member findMember = em.find(Member.class, 2L);  System.out.println(\"findMember.id = \" + findMember.getId()); System.out.println(\"findMember.name = \" + findMember.getName());   1 2 3 4 5 6 7 8 9 10 11 12 === BEFORE === === AFTER === findMember.id = 2 findMember.name = HelloJPA Hibernate:      /* insert hellojpa.Member         */ insert          into             Member             (name, id)          values             (?, ?)   영속 엔티티의 동일성 보장   1 2 3 4 5 6 // DB에서 조회 후 1차 캐시에 저장 Member findMember1 = em.find(Member.class, 2L); // 1차 캐시에서 조회 Member findMember2 = em.find(Member.class, 2L);  System.out.println(\"result = \" + (findMember1 == findMember2));   1 2 3 4 5 6 7 8 9 Hibernate:      select         member0_.id as id1_0_0_,         member0_.name as name2_0_0_      from         Member member0_      where         member0_.id=? result = true   트랜잭션을 지원하는 쓰기 지연   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 EntityManager em = emf.createEntityManager();  EntityTransaction tx = em.getTransaction(); tx.begin(); // 트랜잭션 시작  Member member1 = new Member(150L, \"A\"); Member member2 = new Member(160L, \"B\");  em.persist(member1); em.persist(member2); // 여기까지 Insert 쿼리를 데이터베이스에 보내지 않는다. // 1차 캐시에만 저장 System.out.println(\"============================\");  // 커밋하는 순간 데이터베이스에 Insert 쿼리를 보낸다 tx.commit();   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ============================ Hibernate:      /* insert hellojpa.Member         */ insert          into             Member             (name, id)          values             (?, ?) Hibernate:      /* insert hellojpa.Member         */ insert          into             Member             (name, id)          values             (?, ?)         변경 감지(dirty check)   변경 감지란 영속성 컨텍스트에 있는 엔티티가 변경될 때 이루어진다. 엔티티를 수정 후 트랜잭션이 커밋되고 flush()가 호출되면 엔티티와 스냅샷을 비교한다. 비교했을때 값이 다르다면 영속성 컨텍스트가 자동으로 update 쿼리문을 보낸다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); // [트랜잭션] 시작  // 영속 엔티티 조회 Member memberA = em.find(Member.class, \"memberA\");  // 영속 엔티티 데이터 수정 memberA.setUsername(\"hi\"); memberA.setAge(10);  //em.update(member) 이런 코드가 있어야 하지 않을까?  transaction.commit(); // [트랜잭션] 커밋         참고 스냅샷 값을 읽어 올때 최초 시점의 데이터    ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-PersistenceContext/",
        "teaser": ""
      },{
        "title": "즉시 로딩과 지연 로딩",
        "excerpt":"Member를 조회할 때 Team도 함께 조회해야 할까?   지연 로딩 LAZY을 사용해서 프록시로 조회   지연로딩은 연관된 것(Team)을 프록시로 가져온다.         1 2 3 4 5 6 7 public class Member {     ...      @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Team team = new Team(); team.setName(\"teamA\");  em.persist(team);  Member member1 = new Member(); member1.setUsername(\"member1\"); member1.setTeam(team); em.persist(member1);  em.flush(); em.clear();  // Member만 조회 Member m = em.find(Member.class, member1.getId());  // Team은 Proxy System.out.println(\"m = \" + m.getTeam().getClass());  System.out.println(\"===================\"); // 이땐 조회 안됨. 아래 처럼 실제로 사용할 때 m.getTeam(); // Team 조회 m.getTeam().getName(); System.out.println(\"===================\");   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 Hibernate:      /* insert jpabook.jpashop.domain.Team         */ insert          into             Team             (name, TEAM_ID)          values             (?, ?) Hibernate:      /* insert jpabook.jpashop.domain.Member         */ insert          into             Member             (createdBy, createdDate, lastModifiedBy, modifiedDate, city, name, street, TEAM_ID, username, zipcode, MEMBER_ID)          values             (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_      from         Member member0_      where         member0_.MEMBER_ID=? m = class jpabook.jpashop.domain.Team$HibernateProxy$Y5Aao7FO =================== Hibernate:      select         team0_.TEAM_ID as team_id1_7_0_,         team0_.name as name2_7_0_      from         Team team0_      where         team0_.TEAM_ID=? ===================   Member와 Team을 자주 함께 사용한다면?   즉시 로딩 EAGER를 사용해서 함께 조회         1 2 3 4 5 6 7 public class Member {     ...      @ManyToOne(fetch = FetchType.EAGER)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 Hibernate:      /* insert jpabook.jpashop.domain.Team         */ insert          into             Team             (name, TEAM_ID)          values             (?, ?) Hibernate:      /* insert jpabook.jpashop.domain.Member         */ insert          into             Member             (createdBy, createdDate, lastModifiedBy, modifiedDate, city, name, street, TEAM_ID, username, zipcode, MEMBER_ID)          values             (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_,         team1_.TEAM_ID as team_id1_7_1_,         team1_.name as name2_7_1_      from         Member member0_      left outer join         Team team1_              on member0_.TEAM_ID=team1_.TEAM_ID      where         member0_.MEMBER_ID=? m = class jpabook.jpashop.domain.Team =================== ===================   프록시와 즉시로딩 주의   실무에선 가급적 지연 로딩만 사용하고 즉시로딩은 무조건 쓰지말자. 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생할 가능성이 높다. 또한, 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. @ManyToOne, @OneToOne은 default가 즉시 로딩이므로 LAZY로 설정해줘야 한다. @OneToMany, @ManyToMany는 default가 지연 로딩이다.   [참고] JPQL의 N+1 문제   즉시로딩으로 설정하면 연관관계에 있는 엔티티를 모두 Join 하여 select 쿼리를 가져온다. 그러나, JPQL은 SQL 그대로 번역되므로 EAGER로 설정해도 Member만 먼저 select 한 후, Member 엔티티에 Team이 연관관계로 설정되있으니 Team도 select 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Team team = new Team(); team.setName(\"teamA\"); em.persist(team);  Member member1 = new Member(); member1.setUsername(\"member1\"); member1.setTeam(team); em.persist(member1);  em.flush(); em.clear();  // em.find()는 pk를 지정해서 가져오는 것이기 때문에 내부적으로 최적화 가능 // Member m = em.find(Member.class, member1.getId());  List&lt;Member&gt; members = em.createQuery(\"select m from Member m\", Member.class)                     .getResultList();  // SQL: select * from Member; // SQL: select * from Team where Team_id = member.team.id;   여기서 문제가 발생!   Member가 1,2,3…N 있다면 그에 해당하는 Team을 조회하기 위해 N번 쿼리 날림   최초의 쿼리가 1이면 이에 해당하는 연관관계의 쿼리를 N번 날린다고 하여 N+1이라함   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Team team = new Team(); team.setName(\"teamA\"); em.persist(team);  Team teamB = new Team(); teamB.setName(\"teamB\"); em.persist(teamB);  Member member1 = new Member(); member1.setUsername(\"member1\"); member1.setTeam(team); em.persist(member1);  Member member2 = new Member(); member2.setUsername(\"member2\"); member2.setTeam(teamB); em.persist(member2);  em.flush(); em.clear();  List&lt;Member&gt; members = em.createQuery(\"select m from Member m\", Member.class)                     .getResultList();   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Hibernate:      /* select         m      from         Member m */ select             member0_.MEMBER_ID as member_i1_4_,             member0_.createdBy as createdb2_4_,             member0_.createdDate as createdd3_4_,             member0_.lastModifiedBy as lastmodi4_4_,             member0_.modifiedDate as modified5_4_,             member0_.city as city6_4_,             member0_.name as name7_4_,             member0_.street as street8_4_,             member0_.TEAM_ID as team_id11_4_,             member0_.username as username9_4_,             member0_.zipcode as zipcode10_4_          from             Member member0_ Hibernate:      select         team0_.TEAM_ID as team_id1_7_0_,         team0_.name as name2_7_0_      from         Team team0_      where         team0_.TEAM_ID=? Hibernate:      select         team0_.TEAM_ID as team_id1_7_0_,         team0_.name as name2_7_0_      from         Team team0_      where         team0_.TEAM_ID=?   JPQL을 사용해 Member를 조회(1)했지만 Member에 해당하는 개수(N)만큼 Team을 조회한다. 이를 N + 1 문제라고 한다.   N+1을 해결하는 방법   일단 Lazy로 다 설정. 3가지 방법이 있는데 대부분 fetch 조인 사용해서 해결함   1 2 List&lt;Member&gt; members = em.createQuery(\"select m from Member m join fetch m.team\", Member.class)                     .getResultList();   지연로딩을 실무에서 사용할 때   모든 연관관계에 지연 로딩을 사용하고 실무에서 즉시 로딩을 사용하지 말자. JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라! (뒤에서 설명) 즉시 로딩은 상상하지 못한 쿼리가 나간다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-LazyLoading/",
        "teaser": ""
      },{
        "title": "프록시",
        "excerpt":"Member를 조회할 때 Team도 함께 조회해야 할까?      Member와 Team이 둘다 필요한 경우도 있지만 Member만 필요할 경우엔 Team까지 조회하는건 불필요한 과정이다.   프록시   지연 로딩을 이해하려면 프록시의 개념에 대해 명확하게 이해해야 한다. JPA에는 em.find()와 em.getReference() 메서드가 있다. em.find()는 데이터베이스를 통해서 실제 엔티티 객체를 조회하는 메서드이고 em.getReference()는 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체를 조회하는 메서드이다. (하이버네이트가 어떤 라이브러리를 사용하여 가짜를 조회한다.)      [예시] em.find()   1 2 3 4 5 6 7 8 9 10 11 12 Member member = new Member(); member.setUsername(\"hello\");  em.persist(member);  // 영속성 컨텍스트가 깨끗해짐 em.flush(); em.clear();  Member findMember = em.find(Member.class, member.getId()); System.out.println(\"findMember.id = \" + findMember.getId()); System.out.println(\"findMember.username = \" + findMember.getUsername());   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Hibernate:      call next value for hibernate_sequence Hibernate:      /* insert jpabook.jpashop.domain.Member         */ insert          into             Member             (createdBy, createdDate, lastModifiedBy, modifiedDate, city, name, street, username, zipcode, MEMBER_ID)          values             (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_,         team1_.TEAM_ID as team_id1_7_1_      from         Member member0_      left outer join         Team team1_              on member0_.TEAM_ID=team1_.TEAM_ID      where         member0_.MEMBER_ID=? findMember.id = 1 findMember.username = hello   [예시] em.getReference() 만 작성 했을 때: 조회 안함   1 2 3 4 5 6 7 8 9 Member member = new Member(); member.setUsername(\"hello\");  em.persist(member);  em.flush(); em.clear();  Member findMember = em.getReference(Member.class, member.getId());   1 2 3 4 5 6 7 8 9 10 Hibernate:      call next value for hibernate_sequence Hibernate:      /* insert jpabook.jpashop.domain.Member         */ insert          into             Member             (createdBy, createdDate, lastModifiedBy, modifiedDate, city, name, street, username, zipcode, MEMBER_ID)          values             (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)   [예시] em.getReference() 후 println 했을 때   1 2 3 4 5 6 7 8 9 10 11 12 13 Member member = new Member(); member.setUsername(\"hello\");  em.persist(member);  em.flush(); em.clear(); // 영속성 컨텍스트가 깨끗해짐  Member findMember = em.getReference(Member.class, member.getId()); System.out.println(\"findMember = \" + findMember); System.out.println(\"findMember.id = \" + findMember.getId()); System.out.println(\"findMember.username = \" + findMember.getUsername());   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Hibernate:      /* insert jpabook.jpashop.domain.Member         */ insert          into             Member             (createdBy, createdDate, lastModifiedBy, modifiedDate, city, name, street, username, zipcode, MEMBER_ID)          values             (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_,         team1_.TEAM_ID as team_id1_7_1_      from         Member member0_      left outer join         Team team1_              on member0_.TEAM_ID=team1_.TEAM_ID      where         member0_.MEMBER_ID=? findMember = jpabook.jpashop.domain.Member@6bcb12e6 findMember.id = 1 findMember.username = hello   위의 예제를 살펴보면 알 수 있듯이 프록시는 연관된 객체를 처음부터 DB에서 조회하는 것이 아니라, 실제 사용하는 시점에 DB에서 조회한다.   프록시 구조   프록시 클래스는 실제 클래스(엔티티)를 상속 받아서 만들어져 실제 클래스와 겉 모양이 같다. 따라서, 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. (이론상)      프록시 객체는 실제 객체의 참조(target)를 보관하고 있다가 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.      프록시 객체의 초기화   1 2 3 4 Member member = em.getReference(Member.class, \"id1\");  // 실제 값을 호출할 때 초기화가 진행됨 member.getName();      getName()을 불러옴. 처음엔 Member target에 값이 없음   값이 없으므로 JPA가 영속성 컨텍스트에 실제 엔티티 생성을 요청함(초기화)   영속성 컨텍스트가 DB를 조회   실제 DB 객체를 가져옴   MemberProxy에 있는 target에 엔티티를 연결해줌      프록시의 특징   프록시 객체는 처음 사용할 때 한 번만 초기화된다. 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.   프록시 객체는 원본 엔티티를 상속받은 객체이다. 따라서, 타입 체크 시 주의해서 사용해야 한다.(instance of 사용)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Member member1 = new Member(); member1.setUsername(\"member1\"); em.persist(member1);  Member member2 = new Member(); member2.setUsername(\"member2\"); em.persist(member2);  em.flush(); em.clear();  Member m1 = em.find(Member.class, member1.getId()); Member m2 = em.getReference(Member.class, member2.getId());  System.out.println(\"m1 == m2: \" + (m1.getClass() == m2.getClass())); System.out.println(\"m1 == m2: \" + (m1 instanceof Member)); System.out.println(\"m1 == m2: \" + (m2 instanceof Member));   1 2 3 m1 == m2: false m1 == m2: true m1 == m2: true   영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다.   [예시] 엔티티 조회 후 Proxy 객체 조회할 때   1 2 3 4 5 Member m1 = em.find(Member.class, member1.getId()); System.out.println(\"m1 = \" + m1.getClass());  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(\"reference = \" + reference.getClass());   1 2 m1 = class jpabook.jpashop.domain.Member reference = class jpabook.jpashop.domain.Member   [예시] Proxy 객체 조회 후 엔티티 조회 할 때   1 2 3 4 5 6 7 8 9 Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass());  // Member를 가져올 것 같지만 위에서 Proxy를 한번 호출했기 때문에 // em.find를 해도 Proxy를 가져온다 Member findMember = em.find(Member.class, member1.getId()); System.out.println(\"findMember = \" + findMember.getClass());  System.out.println(\"refMember == findMember: \" + (refMember == findMember));   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 refMember = class jpabook.jpashop.domain.Member$HibernateProxy$VJEp6TpB Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_,         team1_.TEAM_ID as team_id1_7_1_      from         Member member0_      left outer join         Team team1_              on member0_.TEAM_ID=team1_.TEAM_ID      where         member0_.MEMBER_ID=? findMember = class jpabook.jpashop.domain.Member$HibernateProxy$VJEp6TpB refMember == findMember: true   영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제가 발생한다. (하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)   1 2 3 4 5 6 7 8 Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass());  // 준영속 상태로 전환 em.detach(refMember);  // 프록시 초기화 refMember.getUsername();   1 2 3 4 5 6 7 8 refMember = class jpabook.jpashop.domain.Member$HibernateProxy$jeLlOsNZ org.hibernate.LazyInitializationException: could not initialize proxy [jpabook.jpashop.domain.Member#1] - no Session \tat org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:176) \tat org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:322) \tat org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45) \tat org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95) \tat jpabook.jpashop.domain.Member$HibernateProxy$jeLlOsNZ.getUsername(Unknown Source) \tat jpabook.jpashop.JpaMain.main(JpaMain.java:38)   프록시 확인   프록시 인스턴스의 초기화 여부 확인하려면 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 된다.   1 2 3 4 5 6 7 8 Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass());  System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember));  // 프록시 초기화 시킴 refMember.getUsername(); System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember));   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 refMember = class jpabook.jpashop.domain.Member$HibernateProxy$4UHDPuSB isLoaded = false Hibernate:      select         member0_.MEMBER_ID as member_i1_4_0_,         member0_.createdBy as createdb2_4_0_,         member0_.createdDate as createdd3_4_0_,         member0_.lastModifiedBy as lastmodi4_4_0_,         member0_.modifiedDate as modified5_4_0_,         member0_.city as city6_4_0_,         member0_.name as name7_4_0_,         member0_.street as street8_4_0_,         member0_.TEAM_ID as team_id11_4_0_,         member0_.username as username9_4_0_,         member0_.zipcode as zipcode10_4_0_,         team1_.TEAM_ID as team_id1_7_1_      from         Member member0_      left outer join         Team team1_              on member0_.TEAM_ID=team1_.TEAM_ID      where         member0_.MEMBER_ID=? isLoaded = true   프록시 클래스 확인 방법은 entity.getClass().getName() 출력해보면 된다. 클래스 명 뒤에 ..javasist.. 또는 HibernateProxy…이 붙어있으면 프록시인 것을 알 수 있다.   프록시 강제 초기화는 org.hibernate.Hibernate.initialize(entity);를 통해 할 수 있다.   참고로 JPA 표준은 강제 초기화 메소드가 없다. 따라서, 강제로 초기화하려면 member.getName()처럼 프록시의 메소드를 직접 호출하면 된다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-Proxy/",
        "teaser": ""
      },{
        "title": "타임리프(thymleaf)",
        "excerpt":"공식 사이트   Tutorial: Using Thymeleaf   타임리프 특징   1. 서버 사이드 HTML 렌더링 (SSR)   타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용된다.   백엔드 개발자라면 jsp, thymeleaf 중 하나는 알아두는게 좋다!   2. 네츄럴 템플릿   타임리프는 순수 HTML을 최대한 유지하는 특징이 있다.   타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.   JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 열면, 예를 들어서 JSP 파일 자체를 그대로 웹 브라우저에서 열어보면 JSP 소스코드와 HTML이 뒤죽박죽 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해서 JSP가 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.   반면에, 타임리프로 작성된 파일은 해당 파일을 그대로 웹 브라우저에서 열어도 정상적인 HTML 결과를 확인할 수 있다. 물론 이 경우 동적으로 결과가 렌더링 되지는 않는다. 하지만 HTML 마크업 결과가 어떻게 되는지 파일만 열어도 바로 확인할 수 있다.   이렇게 순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 네츄럴 템플릿(natural templates)이라 한다.   3. 스프링 통합 지원   타임리프는 스프링과 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다.       라이브러리   타임리프 사용하기 위한 라이브러리 추가   1 implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'   HTML에 타임리프 사용 선언   1 &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;       기본 표현식   1 th:   태그 안의 값을 서버에서 전달 받은 값에 따라서 표현하고자 할 때 사용       텍스트 출력   th:text   1 &lt;span th:text=\"${data}\"&gt;   태그의 속성에 기능을 정의하여 텍스트를 출력   [[…]]   1 &lt;li&gt;컨텐츠 안에서 직접 출력하기 = [[${data}]]&lt;/li&gt;   태그의 속성이 아닌 콘텐츠 영역안에서 직접 데이터 출력   1 2 3 4 5 6 7 8 9 10 11 12 &lt;!-- ${data} = “Hello &lt;b&gt;Spring&lt;/b&gt;” --&gt;  &lt;h1&gt;text vs utext&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;th:text = &lt;span th:text=\"${data}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;th:utext = &lt;span th:utext=\"${data}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;&lt;span th:inline=\"none\"&gt;[[...]] vs [(...)]&lt;/span&gt;&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;&lt;span th:inline=\"none\"&gt;[[...]] = &lt;/span&gt;[[${data}]]&lt;/li&gt;   &lt;li&gt;&lt;span th:inline=\"none\"&gt;[(...)] = &lt;/span&gt;[(${data})]&lt;/li&gt; &lt;/ul&gt;      th:utext와 [(…)]은 Unesacpe 해준다.      참고    Escape(이스케이프) HTML에서 이스케이프한다는 것은, 몇가지 특별한 문자들을 교체하는 것이다. &lt;, &gt;, “, &amp;등이 여기에 해당한다. (&lt; → &lt;, &gt; → &gt;)        주의   실제 서비스를 개발하다 보면 escape를 사용하지 않아서 HTML이 정상 렌더링 되지 않는 수 많은 문제가 발생한다. escape를 기본으로 하고, 꼭 필요한 때만 unescape를 사용하자.     SpringEL   Object   1 2 3 &lt;li&gt;${user.username} = &lt;span th:text=\"${user.username}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${user['username']} = &lt;span th:text=\"${user['username']}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${user.getUsername()} = &lt;span th:text=\"${user.getUsername()}\"&gt;&lt;/span&gt;&lt;/li&gt;   List   1 2 3 &lt;li&gt;${users[0].username} = &lt;span th:text=\"${users[0].username}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${users[0]['username']} = &lt;span th:text=\"${users[0]['username']}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${users[0].getUsername()} = &lt;span th:text=\"${users[0].getUsername()}\"&gt;&lt;/span&gt;&lt;/li&gt;   Map   1 2 3 &lt;li&gt;${userMap['userA'].username} = &lt;span th:text=\"${userMap['userA'].username}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${userMap['userA']['username']} = &lt;span th:text=\"${userMap['userA']['username']}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;${userMap['userA'].getUsername()} = &lt;span th:text=\"${userMap['userA'].getUsername()}\"&gt;&lt;/span&gt;&lt;/li&gt;   지역 변수 선언 (th:with)   1 2 3 &lt;div th:with=\"first=${users[0]}\"&gt;   &lt;p&gt;처음 사람의 이름은 &lt;span th:text=\"${first.username}\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;       기본 객체들   1 2 3 4 5 6 7 8 9 10 11 12 @GetMapping(\"/basic-objects\") public String basicObjects(HttpSession session) {     session.setAttribute(\"sessionData\", \"Hello Session\");     return \"basic/basic-objects\"; }  @Component(\"helloBean\") static class HelloBean {     public String hello(String data) {         return \"Hello\" + data;     } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;h1&gt;식 기본 객체 (Expression Basic Objects)&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;request = &lt;span th:text=\"${#request}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;response = &lt;span th:text=\"${#response}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;session = &lt;span th:text=\"${#session}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;servletContext = &lt;span th:text=\"${#servletContext}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;locale = &lt;span th:text=\"${#locale}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;편의 객체&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;Request Parameter = &lt;span th:text=\"${param.paramData}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;session = &lt;span th:text=\"${session.sessionData}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;spring bean = &lt;span th:text=\"${@helloBean.hello('Spring!')}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;       유틸리티 객체와 날짜   타임리프 유틸리티 객체들      #message : 메시지, 국제화 처리   #uris : URI 이스케이프 지원   #dates : java.util.Date 서식 지원   #calendars : java.util.Calendar 서식 지원   #temporals : 자바8 날짜 서식 지원   #numbers : 숫자 서식 지원   #strings : 문자 관련 편의 기능   #objects : 객체 관련 기능 제공   #bools : boolean 관련 기능 제공   #arrays : 배열 관련 기능 제공   #lists , #sets , #maps : 컬렉션 관련 기능 제공   #ids : 아이디 처리 관련 기능 제공, 뒤에서 설명   자바8 날짜   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &lt;h1&gt;LocalDateTime&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;default = &lt;span th:text=\"${localDateTime}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;yyyy-MM-dd HH:mm:ss = &lt;span th:text=\"${#temporals.format(localDateTime, 'yyyy-MM-dd HH:mm:ss')}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;LocalDateTime - Utils&lt;/h1&gt; &lt;ul&gt;   &lt;li&gt;${#temporals.day(localDateTime)} = &lt;span th:text=\"${#temporals.day(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.month(localDateTime)} = &lt;span th:text=\"${#temporals.month(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.monthName(localDateTime)} = &lt;span th:text=\"${#temporals.monthName(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.monthNameShort(localDateTime)} = &lt;span th:text=\"${#temporals.monthNameShort(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.year(localDateTime)} = &lt;span th:text=\"${#temporals.year(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.dayOfWeek(localDateTime)} = &lt;span th:text=\"${#temporals.dayOfWeek(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.dayOfWeekName(localDateTime)} = &lt;span th:text=\"${#temporals.dayOfWeekName(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.dayOfWeekNameShort(localDateTime)} = &lt;span th:text=\"${#temporals.dayOfWeekNameShort(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.hour(localDateTime)} = &lt;span th:text=\"${#temporals.hour(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.minute(localDateTime)} = &lt;span th:text=\"${#temporals.minute(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.second(localDateTime)} = &lt;span th:text=\"${#temporals.second(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;${#temporals.nanosecond(localDateTime)} = &lt;span th:text=\"${#temporals.nanosecond(localDateTime)}\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;       URL 링크   1 2 &lt;!-- /hello --&gt; &lt;li&gt;&lt;a th:href=\"@{/hello}\"&gt;basic url&lt;/a&gt;&lt;/li&gt;   1 2 3 4 5 6 @GetMapping(\"/link\") public String link(Model model) {     model.addAttribute(\"param1\", \"data1\");     model.addAttribute(\"param2\", \"data2\");     return \"basic/link\"; }   1 2 3 4 5 6 7 8 9 10 11 &lt;h1&gt;URL 링크&lt;/h1&gt; &lt;ul&gt;   &lt;!-- /hello --&gt;   &lt;li&gt;&lt;a th:href=\"@{/hello}\"&gt;basic url&lt;/a&gt;&lt;/li&gt;   &lt;!-- /hello?param1=data1&amp;param2=data2 --&gt;   &lt;li&gt;&lt;a th:href=\"@{/hello(param1=${param1}, param2=${param2})}\"&gt;hello query param&lt;/a&gt;&lt;/li&gt;   &lt;!-- /hello/data1/data2 --&gt;   &lt;li&gt;&lt;a th:href=\"@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}\"&gt;path variable&lt;/a&gt;&lt;/li&gt;   &lt;!-- /hello/data1?param2=data2 --&gt;   &lt;li&gt;&lt;a th:href=\"@{/hello/{param1}(param1=${param1}, param2=${param2})}\"&gt;path variable + query parameter&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;       Literals   1 2 3 4 5 6 7 8 9 &lt;h1&gt;리터럴&lt;/h1&gt; &lt;ul&gt;   &lt;!--주의! 다음 주석을 풀면 예외가 발생함--&gt;   &lt;!--    &lt;li&gt;\"hello world!\" = &lt;span th:text=\"hello world!\"&gt;&lt;/span&gt;&lt;/li&gt;--&gt;   &lt;li&gt;'hello' + ' world!' = &lt;span th:text=\"'hello' + ' world!'\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;'hello world!' = &lt;span th:text=\"'hello world!'\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;'hello ' + ${data} = &lt;span th:text=\"'hello ' + ${data}\"&gt;&lt;/span&gt;&lt;/li&gt;   &lt;li&gt;리터럴 대체 |hello ${data}| = &lt;span th:text=\"|hello ${data}|\"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;      주의 타임리프에서 문자 리터럴은 항상 ‘(작은 따옴표)로 감싸야 한다.     속성 값 설정   속성 설정   1 2 3 &lt;input type=\"text\" name=\"mock\" th:name=\"userA\"/&gt; &lt;!-- 렌더링 후 --&gt; &lt;input type=\"text\" name=\"userA\"/&gt;   속성 추가   1 2 3 - th:attrappend = &lt;input type=\"text\" class=\"text\" th:attrappend=\"class=' large'\"/&gt;&lt;br/&gt; - th:attrprepend = &lt;input type=\"text\" class=\"text\" th:attrprepend=\"class='large'\"/&gt;&lt;br/&gt; - th:classappend = &lt;input type=\"text\" class=\"text\" th:classappend=\"large\"/&gt;&lt;br/&gt;   checked 처리   1 2 3 4 5 6 7 - checked o &lt;input type=\"checkbox\" name=\"active\" th:checked=\"true\"/&gt;&lt;br/&gt;  &lt;!-- th:checked 는 값이 false 인 경우 checked 속성 자체를 제거 --&gt; - checked x &lt;input type=\"checkbox\" name=\"active\" th:checked=\"false\"/&gt;&lt;br/&gt;  &lt;!-- 이 경우에도 checked 속성이 있기 때문에 checked 처리가 되어버린다. --&gt; - checked=false &lt;input type=\"checkbox\" name=\"active\" checked=\"false\"/&gt;&lt;br/&gt;       반복   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;tr th:each=\"user, userStat : ${users}\"&gt;   &lt;td th:text=\"${userStat.count}\"&gt;username&lt;/td&gt;   &lt;td th:text=\"${user.username}\"&gt;username&lt;/td&gt;   &lt;td th:text=\"${user.age}\"&gt;0&lt;/td&gt;   &lt;td&gt;     index = &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt;     count = &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt;     size = &lt;span th:text=\"${userStat.size}\"&gt;&lt;/span&gt;     even? = &lt;span th:text=\"${userStat.even}\"&gt;&lt;/span&gt;     odd? = &lt;span th:text=\"${userStat.odd}\"&gt;&lt;/span&gt;     first? = &lt;span th:text=\"${userStat.first}\"&gt;&lt;/span&gt;     last? = &lt;span th:text=\"${userStat.last}\"&gt;&lt;/span&gt;     current = &lt;span th:text=\"${userStat.current}\"&gt;&lt;/span&gt;   &lt;/td&gt; &lt;/tr&gt;   1 2 3 4 &lt;tr th:each=\"user, userStat : ${users}\"&gt;  &lt;!-- 위와 같은 표현 --&gt; &lt;tr th:each=\"user : ${users}\"&gt;       조건부 평가   if, unless   1 2 &lt;span th:text=\"'미성년자'\" th:if=\"${user.age lt 20}\"&gt;&lt;/span&gt; &lt;span th:text=\"'미성년자'\" th:unless=\"${user.age ge 20}\"&gt;&lt;/span&gt;   만약 조건이 false인 경우 … 부분 자체가 렌더링 되지 않고 사라진다.   switch   1 2 3 4 5 6 7 8 9 &lt;tr th:each=\"user, userStat : ${users}\"&gt;   &lt;td th:text=\"${userStat.count}\"&gt;1&lt;/td&gt;   &lt;td th:text=\"${user.username}\"&gt;username&lt;/td&gt;   &lt;td th:switch=\"${user.age}\"&gt;     &lt;span th:case=\"10\"&gt;10살&lt;/span&gt;     &lt;span th:case=\"20\"&gt;20살&lt;/span&gt;     &lt;span th:case=\"*\"&gt;기타&lt;/span&gt;   &lt;/td&gt; &lt;/tr&gt;       주석   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;h1&gt;1. 표준 HTML 주석&lt;/h1&gt; &lt;!-- 타임리프가 렌더링 하지 않고, 그대로 남겨둔다. --&gt; &lt;!-- &lt;span th:text=\"${data}\"&gt;html data&lt;/span&gt;  --&gt;  &lt;h1&gt;2. 타임리프 파서 주석&lt;/h1&gt; &lt;!-- 렌더링에서 주석 부분을 제거한다. --&gt; &lt;!--/* [[${data}]] */--&gt;  &lt;!--/*--&gt; &lt;span th:text=\"${data}\"&gt;html data&lt;/span&gt; &lt;!--*/--&gt;  &lt;h1&gt;3. 타임리프 프로토타입 주석&lt;/h1&gt; &lt;!-- HTML 파일을 그대로 열어보면 주석처리가 되지만, 타임리프를 렌더링 한 경우에만 보이는 기능 --&gt; &lt;!--/*/ &lt;span th:text=\"${data}\"&gt;html data&lt;/span&gt; /*/--&gt;          블록   &lt;th:block&gt; 은 HTML 태그가 아닌 타임리프의 유일한 자체 태그   1 2 3 4 5 &lt;th:block th:each=\"user : ${users}\"&gt;   &lt;div&gt;     사용자 이름1 &lt;span th:text=\"${user.username}\"&gt;&lt;/span&gt;   &lt;/div&gt; &lt;/th:block&gt;       자바스크립트 인라인   1 &lt;script th:inline=\"javascript\"&gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &lt;!-- 자바스크립트 인라인 사용 전 --&gt; &lt;script&gt;     var username= [[${user.username}]];     var age= [[${user.age}]];      //자바스크립트 내추럴 템플릿     var username2= /*[[${user.username}]]*/ \"test username\";      //객체     var user= [[${user}]]; &lt;/script&gt;  &lt;!-- 자바스크립트 인라인 사용 후 --&gt; &lt;script th:inline=\"javascript\"&gt;     var username= [[${user.username}]];     var age= [[${user.age}]];      //자바스크립트 내추럴 템플릿     var username2= /*[[${user.username}]]*/ \"test username\";      //객체     var user= [[${user}]]; &lt;/script&gt;          템플릿 조각   th:fragment 가 있는 태그는 다른곳에 포함되는 코드 조각으로 이해하면 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head th:fragment=\"common_header(title,links)\"&gt;    &lt;title th:replace=\"${title}\"&gt;레이아웃 타이틀&lt;/title&gt;    &lt;!-- 공통 --&gt;   &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"all\" th:href=\"@{/css/awesomeapp.css}\"&gt;   &lt;link rel=\"shortcut icon\" th:href=\"@{/images/favicon.ico}\"&gt;   &lt;script type=\"text/javascript\" th:src=\"@{/sh/scripts/codebase.js}\"&gt;&lt;/script&gt;    &lt;!-- 추가 --&gt;   &lt;th:block th:replace=\"${links}\" /&gt; &lt;/head&gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;!DOCTYPE html&gt; &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;  &lt;head th:replace=\"template/layout/base :: common_header(~{::title},~{::link})\"&gt;   &lt;title&gt;메인 타이틀&lt;/title&gt;   &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.min.css}\"&gt;   &lt;link rel=\"stylesheet\" th:href=\"@{/themes/smoothness/jquery-ui.css}\"&gt; &lt;/head&gt;  &lt;body&gt; 메인 컨텐츠 &lt;/body&gt; &lt;/html&gt;  ","categories": ["Spring"],
        "tags": ["Spring","Thymeleaf"],
        "url": "/spring/Spring-Thymeleaf/",
        "teaser": ""
      },{
        "title": "Querydsl 설정",
        "excerpt":"Querydsl 설정   springboot, gradle 버전에 따라 Querydsl 설정 방법이 많이 다르다. 주의하자!      SpringBoot version: 2.7.3   gradle: 7.5   gradle.build  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // 1. querydsl version 정보 추가 buildscript { \text { \t\tqueryDslVersion = \"5.0.0\" \t} }  plugins { \tid 'org.springframework.boot' version '2.7.3' \tid 'io.spring.dependency-management' version '1.0.13.RELEASE' \t// 2. querydsl plugins 추가 \tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\" \tid 'java' }  group = 'study' version = '0.0.1-SNAPSHOT' sourceCompatibility = '11'  configurations { \tcompileOnly { \t\textendsFrom annotationProcessor \t} }  repositories { \tmavenCentral() }  dependencies { \timplementation 'org.springframework.boot:spring-boot-starter-data-jpa' \timplementation 'org.springframework.boot:spring-boot-starter-web'  \t// 3. querydsl dependencies 추가 \timplementation \"com.querydsl:querydsl-jpa:${queryDslVersion}\" \timplementation \"com.querydsl:querydsl-apt:${queryDslVersion}\"  \tcompileOnly 'org.projectlombok:lombok' \truntimeOnly 'com.h2database:h2' \tannotationProcessor 'org.projectlombok:lombok' \ttestImplementation 'org.springframework.boot:spring-boot-starter-test' }  tasks.named('test') { \tuseJUnitPlatform() }  // 4. querydsl 추가 시작 // querydsl 에서 사용할 경로 설정 def querydslDir = \"$buildDir/generated/querydsl\" // JPA 사용 여부와 사용할 경로를 설정 querydsl { \tjpa = true \tquerydslSourcesDir = querydslDir } // build 시 사용할 sourceSet 추가 sourceSets { \tmain.java.srcDir querydslDir } // querydsl 이 compileClassPath 를 상속하도록 설정 configurations { \tquerydsl.extendsFrom compileClasspath } // querydsl 컴파일 시 사용할 옵션 설정 compileQuerydsl { \toptions.annotationProcessorPath = configurations.querydsl } //querydsl 추가 끝   검증용 Q 타입 생성   Gradle IntelliJ 사용법      Gradle → Tasks → build → clean   Gradle → Tasks → other → compileQuerydsl   Gradle 콘솔 사용법      ./gradlew clean compileQuerydsl   ./gradlew clean compileJava   Q 타입 생성 확인      build → generated → querydsl            study.querydsl.entity.QHello.java 파일이 생성되어 있어야 함              참고   Q타입은 컴파일 시점에 자동 생성되므로 버전관리(GIT)에 포함하지 않는 것이 좋다. 앞서 설정에서 생성 위치를 gradle build 폴더 아래 생성되도록 했기 때문에 이 부분도 자연스럽게 해결된다. (대부분 gradle build 폴더를 git에 포함하지 않는다.)     Querydsl Q타입이 정상 동작하는지 확인하는 테스트 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @SpringBootTest @Transactional class QuerydslApplicationTests {      @Autowired     EntityManager em;      @Test     void contextLoads() {         Hello hello = new Hello();         em.persist(hello);          JPAQueryFactory query = new JPAQueryFactory(em); //        QHello qHello = new QHello(\"h\");         QHello qHello = QHello.hello;          Hello result = query                 .selectFrom(qHello)                 .fetchOne();          assertThat(result).isEqualTo(hello);         assertThat(result.getId()).isEqualTo(hello.getId());     } }    Querydsl 관련 라이브러리      querydsl-apt: Querydsl 관련 코드 생성 기능 제공, Q타입 생성해준다.   querydsl-jpa: querydsl 라이브러리, 애플리케이션 코드 작성을 도와준다.   Querydsl 작성   기본 설정   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest @Transactional @Commit public class QuerydslTests {      @Autowired     EntityManager em;      JPAQueryFactory queryFactory;      @BeforeEach     void before() {         queryFactory = new JPAQueryFactory(em);     }  }   기본 Q-클래스 사용 방법   별칭 직접 지정   1 2 3 4 5 6 7 8 @Test void startQuerydsl1() {     QMember m = new QMember(\"m\");      queryFactory             .selectFrom(m)             .where(m.username.eq(\"username1\")); }   기본 인스턴스 사용   1 2 3 4 5 6 7 @Test void startQuerydsl2() {      queryFactory             .selectFrom(QMember.member)             .where(QMember.member.username.eq(\"username1\")); }   기본 인스턴스를 static import와 함께 사용   1 2 3 4 5 6 7 8 9 import static study.querydsl.entity.QMember.*;  @Test void startQuerydsl3() {      queryFactory             .selectFrom(member)             .where(member.username.eq(\"username1\")); }      참고. 같은 테이블을 조인해야 하는 경우가 아니면 기본 인스턴스를 사용하자.    ","categories": ["JPA"],
        "tags": ["JPA","Querydsl","환경설정"],
        "url": "/jpa/JPA-Querydsl-Settings/",
        "teaser": ""
      },{
        "title": "프로젝션(Projection), DTO로 조회하는 방법",
        "excerpt":"프로젝션   프로젝션이란 select 대상을 지정하는 것을 의미한다.   프로젝션 대상이 하나면 타입을 명확하게 지정할 수 있다. 그러나, 프로젝션 대상이 둘 이상이면 튜플이나 DTO로 조회해야 한다.   단일 프로젝션 조회   1 2 3 4 5 6 7 @Test void simpleProjection() {     List&lt;String&gt; result = queryFactory             .select(member.username)             .from(member)             .fetch(); }   프로젝션 대상이 여러개 - 튜플 조회   1 2 3 4 5 6 7 8 9 10 @Test void tupleProjection() {     List&lt;Tuple&gt; result = queryFactory             .select(member.username, member.age)             .from(member)             .fetch();     for (Tuple tuple : result) {         String name = tuple.get(member.username);     } }   프로젝션 타입이 2개 이상인 경우에 Tuple이 반환된다.      주의   튜플은 Querydsl의 Tuple 객체이다. 따라서, JPA에 종속적이기 때문에 Repository 부분에서만 사용하고 그 이후는 DTO로 받는게 좋다.     프로젝션과 결과 반환, DTO 조회   Querydsl에서 DTO로 프로젝션을 조회하는 방법은 4가지가 있다.      setter를 통해 값을 주입   필드에 직접 주입   생성자를 통한 주입   @QueryProjection를 통한 주입   순수 JPA에서 DTO 조회   순수 JPA에서 DTO를 조회할 때는 new 명령어를 사용해야한다. DTO의 package 이름을 다 적어줘야해서 지저분하며 생성자 방식만 지원한다.   1 2 3 4 5 @Test void findDtoByJPQL() {     List&lt;MemberDto&gt; result = em.createQuery(\"select new study.querydsl.dto.MemberDto(m.username, m.age) from Member m\",  MemberDto.class)             .getResultList(); }   프로퍼티 접근 - setter   MemberDTO의 기본 생성자로 객체를 생성 후, 동일한 필드명을 가진 파라미터에 한해 setter로 값을 셋팅한다.   1 2 3 4 5 6 7 8 9 @Test void findDtoBySetter() {     List&lt;MemberDto&gt; result = queryFactory             .select(Projections.bean(MemberDto.class,                     member.username,                     member.age))             .from(member)             .fetch(); }   필드 직접 접근   setter나 생성자를 사용하지 않고 바로 필드에 값을 주입한다. 역시 필드명이 동일한 파라미터에 한해 동작한다.   1 2 3 4 5 6 7 8 9 @Test void findDtoByField() {     List&lt;MemberDto&gt; result = queryFactory             .select(Projections.fields(MemberDto.class,                     member.username,                     member.age))             .from(member)             .fetch(); }   생성자 사용   MemberDTO의 생성자를 이용해 객체를 셋팅한다. 만약, 파라미터에 맞는 생성자가 없는 경우, 런타임 에러가 발생한다.   1 2 3 4 5 6 7 8 9 @Test void findDtoByConstructor() {     List&lt;MemberDto&gt; result = queryFactory             .select(Projections.constructor(MemberDto.class,                     member.username,                     member.age))             .from(member)             .fetch(); }   필드명과 파라미터명이 다른 경우   1 2 3 4 5 6 @Data public class UserDto {      private String name; // username     private int age; // age }   fields 사용 - as()   1 2 3 4 5 6 7 8 9 10 11 12 @Test void findUserDto() {     List&lt;UserDto&gt; result = queryFactory             .select(Projections.fields(UserDto.class,                     member.username.as(\"name\"),                     ExpressionUtils.as(JPAExpressions                             .select(memberSub.age.max())                             .from(memberSub), \"age\")             ))             .from(member)             .fetch(); }      프로퍼티나, 필드 접근 생성 방식에서 이름이 다를 때 해결 방안   ExpressionUtils.as(source,alias): 필드나, 서브 쿼리에 별칭 적용   username.as(“memberName”): 필드에 별칭 적용   construct 사용   생성자를 사용할때는 UserDto에 @NoArgsConstructor, @AllArgsConstructor를 추가해야 한다.   1 2 3 4 5 6 7 8 9 @Test void findUserDtoByConstructor() {     List&lt;UserDto&gt; result = queryFactory             .select(Projections.constructor(UserDto.class,                     member.username,                     member.age))             .from(member)             .fetch(); }   @QueryProjection   위의 3가지 방법보다 @QueryProjection를 사용하는게 깔끔한 방법이다. 생성자에 @QueryProjection 어노테이션을 추가한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data @NoArgsConstructor public class MemberDto {      private String username;     private int age;      @QueryProjection     public MemberDto(String username, int age) {         this.username = username;         this.age = age;     } }    어노테이션 추가 후 ./gradlew compileQuerydsl 실행한다. Q클래스파일(QMemberDto)이 생성되는지 확인한다.   1 2 3 4 5 6 7 8 9 10 11 @Test void findDtoByQueryProjection() {     List&lt;MemberDto&gt; result = queryFactory             .select(new QMemberDto(member.username,member.age))             .from(member)             .fetch();      for (MemberDto memberDto : result) {         System.out.println(\"memberDto = \" + memberDto);     } }   앞서 사용했던 생성자 방법은 컴파일에서 체크하지 못하는 단점이 있다. 반면에, 이 방법은 컴파일러로 타입을 체크할 수 있으므로 가장 안전한 방법이다. 다만, DTO에 QueryDSL 어노테이션을 유지해야 하는 점과 DTO까지 Q 파일을 생성해야 하는 단점이 있다. 즉, DTO가 Querydsl에 독립적이지 못하다는 단점이 있다.  ","categories": ["JPA"],
        "tags": ["JPA","Querydsl"],
        "url": "/jpa/JPA-Projection-DTO/",
        "teaser": ""
      },{
        "title": "equals와 hashCode",
        "excerpt":"equals와 hashCode란?   equals와 hashCode는 Object 클래스에 정의되어 있다. 그렇기 때문에 모든 객체는 Object 클래스에 정의된 equals와 hashCode 함수를 상속받고 있다.   equals(Object obj)   매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean으로 알려주는 역할을 한다.   Object 클래스에 정의되어 있는 equals 메서드   1 2 3 public voolean equals(Object obj) {     return (this==obj); }   두 객체의 같고 다름을 참조변수의 값으로 판단하며 서로 다른 두 객체를 equals 메서드로 비교하면 항상 false를 결과로 얻게 된다. 즉, 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 true를 반환한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class EqualsEx {     public static void main(String[] args) {         Value v1 = new Value(10);         Value v2 = new Value(10);         if(v1.equals(v2))             System.out.println(\"v1과 v2는 같습니다.\");         else             System.out.println(\"v1과 v2는 다릅니다.\");                  v2 = v1;         if(v1.equals(v2))             System.out.println(\"v1과 v2는 같습니다.\");         else             System.out.println(\"v1과 v2는 다릅니다.\");     } }  class Value {     int value;      Value(int value) {         this.value = value;     } }   실행결과   1 2 v1과 v2는 다릅니다. v1과 v2는 같습니다.   hashCode()   hashCode 메서드는 해싱기법에 사용되는 해시함수를 구현한 것이다. 해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다. 해시함수는 찾고자하는 값을 입력하면 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.   일반적으로 해시코드가 같은 두 객체가 존재하는 것이 가능하지만, Object 클래스에 정의된 hashCode 메서드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없다.   equals와 hashCode는 왜 같이 정의해야 할까?   동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로 동일한 객체는 동일한 해시코드를 가져야 한다. 따라서, equals() 메서드와 hashCode() 메서드를 같이 오버라이딩해야 한다.   만일, hashCode 메서드를 오버라이딩하지 않는다면 Object 클래스에 정의된 대로 모든 객체가 서로 다른 해시코드 값을 가질 것이다.   결론은 hashCode를 equals와 함께 재정의하지 않으면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생한다.   Collection은 객체가 논리적으로 같은지 비교할때 기준은 다음과 같다. hashCode() 메서드의 리턴값이 일치하고 equals() 메서드의 리턴값이 true면 논리적으로 같은 객체라고 판단한다.   hashCode() 메서드를 재정의하지 않으면 Object 클래스의 hashCode() 메서드가 사용된다.   Object 클래스의 hashCode() 메서드는 객체의 고유한 주소 값을 int 값으로 변환하기 때문에 객체마다 다른 값을 리턴한다. 두 개의 객체는 equals로 비교도 하기 전에 서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단된 것이다.   따라서, 객체의 정확한 동등 비교를 위해서는 equals() 메서드와 hashCode() 메서드를 같이 재정의해야 한다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-equalsAndHashCode/",
        "teaser": ""
      },{
        "title": "체크 예외, 언체크 예외",
        "excerpt":"예외의 종류      에러 (Error)   예외 (Exception)            체크 예외 (Check Exception)       언체크 예외 (Uncheck Exception)              에러(Error)   java.lang.Error 클래스의 하위 클래스들이다. 메모리 부족, 스택오버플로우 등과 같이 시스템이 비정상적인 상황인 경우에 사용한다. (프로그램 코드에 의해서 수습 될 수 없는 심각한 오류) 참고로 Error도 언체크 예외이다.   예외(Exception)   java.lang.Exception 클래스의 하위 클래스들이다. 개발자가 예외를 대비해 적절한 코드를 미리 작성하여 프로그램의 비정상적인 종료를 막을 수 있다. (프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류)   예외 기본 규칙   예외의 기본 규칙 2가지      예외를 잡아(catch)서 처리하거나 처리할 수 없다면 밖으로 던져야(throws)한다.   예외를 잡거나 던질 때 지정한 예외 뿐만 아니라 그 예외의 자식들도 함께 처리된다. 예를 들어 Exception를 잡으면 하위 예외(SQLException 등)도 모두 잡을 수 있다.   예외를 처리하면 이후에는 애플리케이션 로직이 정상 흐름으로 동작하고 예외를 처리하지 못하면 호출한 곳으로 예외를 계속 던지게 된다.            참고 예외를 처리하지 못하고 계속 던지면 어떻게 될까?           자바 main() 쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다.     웹 애플리케이션의 경우 여러 사용자의 요청을 처리하기 때문에 하나의 예외 때문에 시스템이 종료되면 안된다. WAS가 해당 예외를 받아서 처리하는데 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.       예외는 체크 예외와 언체크 예외로 구분된다.   체크 예외(Check Exception)   체크 예외는 RuntimeException 클래스를 상속받지 않는 예외 클래스들이다. Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. (단, RuntimeException은 예외로 한다.) 체크 예외는 복구가 가능한 예외이므로 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 예외를 처리하기 위해서는 catch 문으로 잡거나 throws로 예외를 자신을 호출한 클래스로 던지는 방법이 있다. 만약, 예외를 처리하지 않으면 컴파일 에러가 발생한다.   예) IOException, SQLException 등   체크 예외는 개발자가 실수로 예외 처리를 누락하지 않도록 컴파일러가 도와준다. 하지만 개발자가 모든 체크 예외를 처리해주어야 하므로 번거롭고 신경쓰지 않고 싶은 예외까지 처리해야 한다는 단점이 있다.   또한 실제 애플리케이션 개발에서 발생하는 예외들은 복구 불가능한 경우가 많다. 예를 들어 SQLException과 같은 체크 예외를 catch해도 쿼리를 수정하여 재배포하지 않는 이상 복구되지 않는다. 그래서 실제 개발에서는 대부분 언체크 예외를 사용한다.   언체크 예외(Uncheck Exception)   RuntimeException 클래스를 상속받는 예외 클래스들은 복구 가능성이 없는 예외들이므로 컴파일러가 예외처리를 강제하지 않는다. 언체크 예외 또는 런타임 예외라고 한다. 언체크 예외는 에러(Error)와 마찬가지로 에러를 처리하지 않아도 컴파일 에러가 발생하지 않는다. 즉, 런타임 예외는 예상치 못했던 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않는다. 이러한 점 때문에 상당히 편리하지만 컴파일러가 예외를 잡아주지 않으므로 개발자가 실수로 예외를 누락할 수 있다는 단점이 있다.   예) NullPointerException, IllegalArgumentException 등   체크 예외 vs 언체크 예외   언체크 예외는 체크 예외와 기본적으로 동일하지만 차이가 있다면 예외를 처리할 수 없을 때 예외를 밖으로 던지는 부분에 있다. 이 부분을 필수로 선언해야 하는가 생략할 수 있는가의 차이다.   1 2 3 4 5 6 7 8 9 10 // 체크 예외, 반드시 throws 입력 public void callThrow() throws MycheckedException {     repository.call(); }  // 언체크 예외, throws 생략 가능 public void callThrow() throws MyUncheckedException { // public void callThrow() {     repository.call(); }  ","categories": ["Java"],
        "tags": ["Java","Spring"],
        "url": "/java/Java-Check-Uncheck-Exception/",
        "teaser": ""
      },{
        "title": "인증과 인가",
        "excerpt":"인증과 인가란?   인증   (식별가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정   인가   권한에 대한 허가, 인증된 사용자에 대한 자원 접근 권한 확인   결국, 인증이 인가보다 선행되어야 한다.   인증의 방법      인증하기 Request Header   인증 유지하기 Browser   안전하게 인증하기 Server   효율적으로 인증하기 Token   다른 채널로 인증하기 OAuth       HTTP는 무상태성이라는 것이 매우중요   서버는 클라이언트가 보낸 요청과 이 다음 요청이 연관관계가 없다고 생각하는 것을 무상태성(Stateless)       클라이언트(사용자)는 서버(네이버)에 이미 회원가입이 돼 있는 상태라고 가정한다.   Request Header를 활용한 로그인   사용자는 아래의 주소를 통해서 서버에 로그인을 요청한다.   1 http://user:1q2w3e!@www.naver.com/login   브라우저는 위의 url에서 사용자 정보(id, pw)를 파싱한 후 Base64 인코더를 이용해 인코딩한다. 그리고 인코딩한 문자열을 요청 헤더 Authorization에 넣어서 보내준다.   1 Authorization: Base dGE2fjdsfGsdkfjs3lssfdQ   그 후 서버에 요청을 하면 서버가 DB에 있는 값과 비교하여 유효한지 확인 후 응답을 해준다.   문제점   사용자가 매번 인증을 해야 한다. 예를 들어 사용자가 게시판에서 글을 쓸때 로그인을 한번 했다. 그런데 작성한 글을 수정하고 싶어졌다. 다시 로그인을 해야한다.   이러한 문제점을 개선하기 위해 Browser에 있는 Storage를 사용한다.   Browser를 활용한 로그인   Storage의 종류에는 로컬스토리지, 세션스토리지, 쿠키가 있는데 이 중 쿠키로 설명.   쿠키에 사용자 정보(ID/PW)를 넣고 인증이 필요할때마다 서버로 보내준다. 매우 편리하죠! 근데 해커도 같이 편리함 ㅎㅎ;   문제점   스토리지에 사용자 정보가 있으니 해커가 가져가기 매우 편하고 클라이언트는 서버에 비해 상대적으로 보안에 취약하다는 점이 매우 큰 단점이다.   이런 두가지 단점을 해결하기 위해 (보안을 향상시키기 위해) 세션이라는 개념이 도입되었다.   Session을 활용한 로그인   세션은 인증된 사용자의 식별자와 랜덤한 문자열로 세션 ID를 만들어서 이를 응답 헤더에 넘겨준다.   이제 클라이언트 쪽에 사용자 정보를 가지고 있지 않기 때문에 해커가 정보를 가져가도 크게는 위험하지 않다. 또한, 세션의 만료기간을 정할 수 있어 만료기간이 지나게 될 경우엔 해커가 정보를 가져가더라도 유효하지 않다는게 장점이다.   그리고 세션관리는 서버에서 하기때문에 세션이 탈취되면 서버에서 삭제해버리면 더 이상 이 세션을 이용하지 못하게 된다는 보안상 이점이 있다.   그러나, 이 방법도 문제가 있다.   문제점   서버를 증설할 경우이다. 서버가 여러개 생기면 로드밸런서가 필요하다. 요청을 보내고 로드밸런서가 서버3으로 인증을 진행했다. 이제 세션은 서버 3에 있다. 그런데 같은 사용자가 다시 어떠한 요청을 보냈는데 로드밸런서가 서버2로 요청을 보냈다. 서버2에는 사용자에 대한 인증정보가 없다. 따라서 문제가 발생한다.   이 문제는 서버 하나하나 자체에서 세션을 관리해서 생긴 문제이다.   Session Storage를 활용해 문제점 해결   이 문제를 해결한 방법은 세션스토리지를 따로 둔다. 모든 서버의 세션에 대한 정보는 세션스토리지에 있다.   그런데 이 방법도 문제가 있다. (ㅠㅠ) 클라이언트가 많을 경우 문제가 생긴다. 수 많은 세션을 세션스토리지 하나에서 관리하므로 문제가 생긴다.   이제 어떻게 해야 할까?   지금까지 클라이언트, 서버, 세션스토리지에 모두 사용자의 정보를 관리할 수 있게 구성을 해봤다.   하지만 모두 문제가 생겼다. 그 이유는 HTTP와 서버자체가 지향하는 Rest API가 무상태성을 기초로 하기 때문이다. 그런데 인증과 인가는 상태성이다. 두 패러다임이 충돌한다. 이 패러다임을 해소해야 문제가 해결된다.   이제 사용자정보를 정보의 흐름에 맡겨보자. 정보의 흐름은 요청/응답을 의미한다.   즉, 요청과 응답에 사용자 정보를 담는다. 이를 토큰을 활용한 인증과 인가방법이라 한다.   Token을 활용한 로그인   JWT(Json Web Token)를 이용한다.   JWT에 대해 간단한게 설명하면 시크릿 키를 사용해서 JWT를 만든다. 그리고 시크릿 키를 사용해서 JWT의 인증과정을 거친다.   JWT 내에는 민감한 정보를 두지 않는다. 그리고 시크릿 키가 중요한 만큼 노출되면 JWT 토큰 자체도 끝난다. 그래서 토큰을 사용하기 위해서는 시크릿 키를 서버 내부에 잘 관리해야 한다.   토큰(JWT) 활용하기   클라이언트가 로그인 요청을 보내고 DB가 유효성을 확인한다. 이전에는 세션스토리지와 연결을 했었는데 이제는 시크릿 키를 이용해 토큰을 생성한다.   생성한 토큰은 헤더에 넣어서 이 키를 이용해 요청을 보내고 응답을 받는 형태가 된다.   토큰에 대해 좀더 알아보면   클라이언트가 토큰을 가지고 서버에 요청을 했다. 그러면 서버는 토큰의 유효성 검사를 본인이 가진 시크릿 키로 진행한다. 유효하지 않다면 버리고 유효하다면 토큰을 디코딩하여 사용자 정보를 파악한다. (디코딩이 쉽기 때문에 절대로 비밀번호를 넣으면 안된다.)   토큰에는 이름, 만료시기, 권한에 관한 정보가 있다.   즉, 시크릿키를 통해서 유효성 검사를 통과한 토큰은 이미 인증을 받은 토큰이라는 것이다.   토큰의 장점   서버가 여러대 있어도 각각의 서버에 있는 시크릿 키로 인증을 진행하면 된다는 장점이 있다. 이 장점이 조금 더 나아가서는 확장성과도 연결되는데 3대였던 서버를 5대로 늘려도 수정없이 똑같이 진행할 수 있다. 즉, 확장성에 용이하다.   하지만 또 단점이 있다.   해킹을 당할 수 있다. 액세스 토큰을 탈취 당할 수 있는데 이를 막기 위해 만료기한을 정한다. 만료기한이 지나면 액세스 토큰을 다시 발급 받아야 하는데 이 부분이 귀찮으니까 리프레시 토큰 개념이 나온다.   흐름 정리   로그인 요청을 보내면 시크릿 키를 통해 토큰을 생성한다. 이 때 서버는 액세스 토큰과 리프레시 토큰을 같이 생성한다. 그리고 액세스 토큰은 저장하지 않고 리프레시 토큰만 저장소에 저장한다. 그 다음 이 둘을 한번에 응답헤더로 보내서 클라이언트는 액세스 토큰과 리프레시 토큰을 모두 저장하고 있다.   시간이 흘러 액세스 토큰이 만료되었다고 가정하자. 사용자는 액세스 토큰이 만료되었다는 사실도 모르고 알 필요도 없다. 사용자는 액세스 토큰이 만료되었다는 사실을 모른체 서버에 요청을 보낸다. 서버는 액세스 토큰이 만료되었다는 사실을 클라이언트에게 알린다. 이제 브라우저는 자동으로 액세스 토큰과 리프레시 토큰을 함께 서버로 보낸다. 서버는 리프레시 토큰이 유효하다면 새로 갱신한 액세스 토큰을 클라이언트에 보내게 된다. 그러면 이제 클라이언트에도 업데이트된 액세스 토큰을 사용할 수 있게 됨   결론   토큰으로 상태 관리를 하기에 따로 세션을 둘 필요가 없다. 효율성이 좋아지고 DB까지 가지 않아도 되기 때문에 속도가 빠르다는 장점이 있다. 하지만 토큰도 관리해야 하는 대상이기 때문에 보안에 있어서 신경을 써야한다.  ","categories": ["Web"],
        "tags": ["Web"],
        "url": "/web/Web-Authentication-Authorization/",
        "teaser": ""
      },{
        "title": "OAuth 2.0",
        "excerpt":"    웹 서핑을 하다보면 Google, Facebook 등의 소셜 로그인 기능을 쉽게 찾아볼 수 있다. 클릭 한 번으로 간편하게 로그인할 수 있으며 연동되는 애플리케이션에서 Google, Facebook 등이 제공하는 기능을 간편하게 사용할 수 있다는 장점이 있다.   이 때 사용되는 프로토콜이 바로 OAuth다.   OAuth란   OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는 접근 위임을 위한 개방형 표준이다.      OAuth에는 3가지 주체가 있다.      사용자, User: 내 사이트를 이용하고자 하는 사용자   내 사이트, mine: xxxxx.com   그들의 서비스, Their: Google, Facebook, Twitter 등      OAuth를 이용하면 우리의 서비스가 그들이 만든 서비스와 상호작용할 수 있다.   User는 mine을 통해 accessToken으로 그들의 서비스에 접근할 수 있다. 최종적으로는 OAuth를 통해 accessToken을 얻어낼 수 있다.   OAuth 주요 용어   OAuth에는 3가지 주체가 있다고 했다. 3가지 주체를 OAuth 용어에 맞게 해석하면 다음과 같다.      사용자(User) ⇒ Resource Owner   내 사이트(mine) ⇒ Client   그들의 서비스(Their) ⇒ Resource Server   Resource Server, Resource Owner, Client 이 세가지의 관계가 OAuth의 핵심이다.       Resource Owner   웹 서비스를 이용하는 사용자, 자원을 소유한 사람 (자원은 개인정보라고 생각하면 된다.)   Client   개인이 만든 애플리케이션 서버   Resource Server   사용자의 개인정보를 가지고 있는 서버 (Google, Facebook 등)   Authorization Server   인증과 관련된 처리를 전담하는 서버   공식 메뉴얼에서는 Resource Server와 Authorization Server를 구분하여 보여주지만 우리는 합쳐서 Resource Server라고 부르겠다.   OAuth2.0 등록   Client가 Resource Server를 이용하기 위해선 Resource Server에게 사전에 승인을 받아야한다. 이를 등록(Register)한다고 하며, 서비스(Google, Facebook 등)마다 등록하는 방법은 다르다.   하지만 아래 세가지 요소를 공통적으로 갖는다.   client id, client secret, authorized redirect URIs   Client ID   애플리케이션을 식별하는 식별자 ID를 의미한다.   Client Secret   식별하는 값에 대한 비밀번호. 즉, Client ID에 대한 비밀번호이다. Client ID는 외부에 노출될 수 있으나 Client Secret은 절대 외부에 노출되면 안된다.   Authorized redirect URIs   authorized는 ‘권한을 부여하다’라는 뜻이다.   Resource Server만 갖는 정보이며 Client에 권한을 부여하는 과정에서 나중에 Authorized code를 전달하는 통로이다. 나중에 Clinet ↔ Resource Server 유효성 검사에서 이 redirect URIs도 체크되며 해당 주소가 아닐 경우 Resource Server는 해당 Client가 아니라고 판단한다.   Scope   Resource Server에서 사전에 사용 가능하도록 미리 정의한 기능   Resource Owner의 승인   등록을 통해 Resource Server는 client id, client secret, redirectURL을 알게 되었고, Client는 client id와 client secret을 알게 되었다.      Resource Server에 4가지 기능이 있다고 가정하고 각각의 기능을 A, B, C, D라고 할때 client는 Resource Server의 모든 기능이 필요한게 아니고 B와 C 기능만 필요하다고 하다고 가정한다. 그렇다면 모든 기능에 대한 인증을 받는게 아니라 최소한의 인증만 받는게 효율적이다.   Resource Owner가 Client에 접속한다. 이때 Resource Server의 기능 중 하나인 페이스북 글쓰기 기능을 사용하려고 한다고 가정하자. 그렇다면 아래와 같이 ‘페이스북으로 로그인하기’라는 페이지가 보이게 된다.      버튼의 링크는 아래와 같다. 이 링크를 통해 Resource Owner는 Resource Server로 접속하게 된다.   1 http://resource.server/?client_id=1&amp;scope=B,C&amp;redirect_uri=http://client/callback   Resource Server는 Resource Owner의 현재 로그인 여부를 확인한다. 로그인이 안되어있으면 로그인을 요청한다. 로그인이 완료되면 그때서야 요청한 링크의 client id와 redirect URL를 Resource Server의 client id와 redirect URL과 비교한다. 같다면 Resource Owner에게 scope에 해당하는 기능을 부여할 것인지를 확인하는 메시지를 전송한다. (향후 redirect_uri를 통해서 Resource Server는 Client에게 임시비밀번호인 Authorization code를 제공한다.)      허용버튼을 누르면 (Resource Owner에서 Resource Server로 요청) Resource Server에 user id, scope 저장됨      Resource Server의 승인   임시비밀번호인 authorization code를 Redirect URL을 통해 Resource Server에서 Resource Owner에게 전송한다.      헤더에 Location 값을 전달하는 것을 redirection이라고 한다. (여기서 ?code=3은 authorization code 이다.) Resource Server가 Resource Owner의 웹 브라우저에게 저 주소(http://client/callback?code=3)로 이동하라고 명령한 것이다.      Resource Owner의 웹 브라우저는 Location의 헤더값에 의해서 사용자가 인식하지도 못하게 주소(http://client/callback?code=3)로 redirect 한다. 주소 중 ?code=3을 통해 Client는 authorization code 값이 3이라는 것을 알게 된다.      Client는 Resource Owner를 통하지 않고 Resource Server로 직접 접근한다. 직접 접근할때 authorization code와 client id, client secret 값을 같이 전송한다. 이제 Resource Server는 authorization code와 client id, client secret 값이 일치하는지 확인하고 일치하면 access token을 발급한다. 그리고 필요없어진 Authorization code는 지운다.   그렇게 토큰을 받은 Client는 사용자에게 최종적으로 로그인이 완료되었다고 응답한다.      OAuth의 목적은 최종적으로 Access Token을 발급하는 것이다.     이제 Client는 Resource Server의 API를 요청해 Resource Owner의 ID와 같은 사용자 정보를 가지고 올 수 있다. 그리고 Access Token의 기간이 만료되면 Refresh Token을 이용해서 Access Token을 재발급 받는다.   OAuth 흐름 정리         Resource Owner는 서비스(client)를 이용하기 위해 로그인 페이지에 접근한다.   그럼 서비스(Client)는 Resource Owner에게 로그인 페이지를 제공하게 된다. 로그인 페이지에서 사용자는 ‘구글/페이스북으로 로그인’ 버튼을 누른다.        Resource Owner가 로그인 버튼을 클릭하게 되면 특정한 url이 구글/페이스북 서버쪽으로 보내지게 된다.       (특정한 url: http://resource.server/?client_id=1&amp;scope=B,C&amp;redirect_uri=http://client/callback)            Resource Owner가 보낸 client_id와 redirect_uri를 Resource Server에 등록된 정보와 비교한다. 확인이 완료되면 Resource Server로 부터 전용 로그인 페이지로 이동하여 사용자에게 보여준다.                   ID/PW로 로그인을 하게되면 Client가 사용하려는 기능(scope)에 대해 Resource Owner의 동의(승인)을 요청한다. 즉, scope에 해당되는 권한을 클라이언트에게 부여할 것인지 사용자에게 재차 확인한다.              위 이미지가 의미하는 것은 다음과 같다.       ‘Client는 Resource Owner를 대신해 해당 기능(scope)를 사용하려고 합니다. 동의하시겠습니까?’       동의를 누르면 Resource Owner는 Client가 해당 기능 사용에 위임했다는 것을 의미한다.       하지만, 이미 Owner가 Client에게 권한 승인을 했더라도 아직 Server가 허락하지 않았다. 따라서, Resource Server도 Client에게 권한 승인을 하기위해 Authorization code를 Redirect URL을 통해 사용자에게 응답하고   사용자는 그대로 Client에게 다시 보낸다.   이제 Client가 Resource Server에게 직접 url(client_id, client_secret, authorization code 등)을 보낸다.   그럼 Resource Server는 Client가 전달한 정보들을 비교해서 일치한다면, Access Token을 발급한다. 그리고 필요없어진 Authorization code는 지운다.   그렇게 토큰을 받은 Client는 사용자에게 최종적으로 로그인이 완료되었다고 응답한다.  ","categories": ["Web"],
        "tags": ["Web"],
        "url": "/web/Web-OAuth/",
        "teaser": ""
      },{
        "title": "JWT, OAuth2.0, Security",
        "excerpt":"    SpringBoot 환경에서 Spring Security를 이용한 인증/인가를 구현할 것, OAuth2.0 인증을 통해 JWT토큰을 발급해줄 것이다. 이후 서버에 요청할 때 발급한 토큰을 Request Header에 입력하여 요청한다.   작성한 코드 구성은 다음과 같다.      사전 작업           인증이 정상처리 되었을 경우 접근할 수 있는 페이지를 작성한다.       1 2 3 4 5 6 7 8 9 10  @RestController  @RequestMapping(\"/members\")  @RequiredArgsConstructor  public class MemberController {           @GetMapping      public String MyPage() {          return \"myPage\";      }  }                OAuth를 사용하기 위해 사전에 발급한 client_id, client_secret, callback uri를 application.yml에 작성한다. client_secret값은 다른 사람에게 공개해서는 안된다.       1 2 3 4 5 6 7 8 9 10 11  spring:    jwt:      secretKey: ****    security:      oauth2:        client:          registration:            github:              client-id: ****              client-secret: ******              redirect-uri: http://localhost:8080/login/oauth2/code/github           OAuth 관련 코드      OAuth2Attribute   CustomOAuth2UserService   OAuth2SuccessHandler   OAuth2Attribute   OAuth 인증 후 보내주는 데이터가 인증 서버마다 다르기 때문에 이곳에서 별도의 처리를 해준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.smtd.smtdApi.github.common;  import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.ToString;  import java.util.HashMap; import java.util.Map;  @ToString @Builder(access = AccessLevel.PRIVATE) @Getter public class OAuth2Attribute {     private Map&lt;String, Object&gt; attributes;     private String attributeKey;     private String email;     private String name;      public static OAuth2Attribute of(String provider, String attributeKey,                                      Map&lt;String, Object&gt; attributes) {         switch (provider) {             case \"github\":                 return ofGithub(attributeKey, attributes);             default:                 throw new RuntimeException();         }     }      private static OAuth2Attribute ofGithub(String attributeKey,                                             Map&lt;String, Object&gt; attributes) {         return OAuth2Attribute.builder()                 .name((String) attributes.get(\"name\"))                 .email((String) attributes.get(\"email\"))                 .attributes(attributes)                 .attributeKey(attributeKey)                 .build();     }      public Map&lt;String, Object&gt; convertToMap() {         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();         map.put(\"id\", attributeKey);         map.put(\"key\", attributeKey);         map.put(\"name\", name);         map.put(\"email\", email);          return map;     } }   CustomOAuth2UserService   OAuth2UserService 인터페이스 구현체이다. OAuth 인증을 완료하고 받은 데이터로 우리의 서비스에 접근할 수 있도록 인증 정보를 생성해준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.smtd.smtdApi.github.common;  import lombok.extern.slf4j.Slf4j; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService; import org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest; import org.springframework.security.oauth2.client.userinfo.OAuth2UserService; import org.springframework.security.oauth2.core.OAuth2AuthenticationException; import org.springframework.security.oauth2.core.user.DefaultOAuth2User; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.stereotype.Service;  import java.util.Collections;  @Slf4j @Service public class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {      @Override     public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {          OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oAuth2UserService = new DefaultOAuth2UserService();         OAuth2User oAuth2User = oAuth2UserService.loadUser(userRequest);          String registrationId = userRequest.getClientRegistration().getRegistrationId();         String userNameAttributeName = userRequest.getClientRegistration()                 .getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName();          OAuth2Attribute oAuth2Attribute =                 OAuth2Attribute.of(registrationId, userNameAttributeName, oAuth2User.getAttributes());          log.info(\"{}\", oAuth2Attribute);          var memberAttribute = oAuth2Attribute.convertToMap();          return new DefaultOAuth2User(                 Collections.singleton(new SimpleGrantedAuthority(\"ROLE_USER\")),                 memberAttribute, \"email\");     } }   OAuth2SuccessHandler   OAuth 로그인 성공 핸들러에서 토큰을 생성하여 회원가입, 로그인 처리하고 Response Header에 토큰을 추가해서 Client로 보내준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package com.smtd.smtdApi.github.common;  import com.fasterxml.jackson.databind.ObjectMapper; import com.smtd.smtdApi.github.dto.MemberDTO; import com.smtd.smtdApi.github.dto.MemberRequestMapper; import com.smtd.smtdApi.github.dto.TokenDTO; import com.smtd.smtdApi.github.entity.Member; import com.smtd.smtdApi.github.repository.MemberRepository; import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.security.core.Authentication; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.security.web.authentication.AuthenticationSuccessHandler; import org.springframework.stereotype.Component;  import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Optional;  @Slf4j @RequiredArgsConstructor @Component public class OAuth2SuccessHandler implements AuthenticationSuccessHandler {      private final JwtTokenProvider jwtTokenProvider;     private final MemberRequestMapper memberRequestMapper;     private final ObjectMapper objectMapper;     private final MemberRepository memberRepository;      @Override     public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {         OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();         MemberDTO memberDTO = memberRequestMapper.toDTO(oAuth2User);         TokenDTO token = null;         Optional&lt;Member&gt; findMember = memberRepository.findByEmail(memberDTO.getEmail());         if (findMember.isPresent()) {             token = TokenDTO.builder()                     .refreshToken(findMember.get().getRefreshToken())                     .build();             log.info(\"{} 로그인\", findMember.get().getEmail());         } else {             token = jwtTokenProvider.createToken(memberDTO.getEmail(), \"USER\");             log.info(\"{}\", token);             Member member = Member.builder()                     .email(memberDTO.getEmail())                     .name(memberDTO.getName())                     .refreshToken(token.getRefreshToken())                     .build();             memberRepository.save(member);             log.info(\"{} 회원가입\", memberDTO.getEmail());         }          writeTokenResponse(response, token);     }      private void writeTokenResponse(HttpServletResponse response, TokenDTO token) throws IOException {         response.setContentType(\"text/html;charset=UTF-8\");          response.addHeader(\"Auth\", token.getAccessToken());         response.addHeader(\"Refresh\", token.getRefreshToken());         response.setContentType(\"application/json;charset=UTF-8\");          var writer = response.getWriter();         writer.println(objectMapper.writeValueAsString(token));         writer.flush();     } }   Token 관련 코드      TokenDTO   JwtTokenProvider   JwtAuthenticationFilter   TokenController   TokenDTO   Access Token과 Refresh Token으로 이루어져있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.smtd.smtdApi.github.dto;  import lombok.*;  @ToString @NoArgsConstructor @AllArgsConstructor @Getter @Builder public class TokenDTO {      private String accessToken;     private String refreshToken; }   JwtTokenProvider   Access Token과 Refresh Token을 발급하고 토큰 값이 유효한지 검증한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 package com.smtd.smtdApi.github.common;  import com.smtd.smtdApi.github.dto.TokenDTO; import com.smtd.smtdApi.github.entity.Member; import com.smtd.smtdApi.github.repository.MemberRepository; import io.jsonwebtoken.*; import lombok.RequiredArgsConstructor; import org.springframework.beans.factory.annotation.Value; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.stereotype.Component;  import javax.annotation.PostConstruct; import java.util.Arrays; import java.util.Base64; import java.util.Date; import java.util.Optional;  @Component @RequiredArgsConstructor public class JwtTokenProvider {      @Value(\"${spring.jwt.secretKey}\")     private String secretKey;      private long tokenValidTime = 1000L * 60 * 60 * 3; // 3시간     private long refreshTokenValidTime = 1000L * 60 * 60 * 24 * 7; // 7일      private final MemberRepository memberRepository;      @PostConstruct     protected void init() {         secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());     }      /**      * jwt token 발급      */     public TokenDTO createToken(String email, String role) {         Claims claims = Jwts.claims().setSubject(email);         claims.put(\"role\", role);         Date now = new Date();          return new TokenDTO(                 Jwts.builder()                         .setClaims(claims)                         .setIssuedAt(now)                         .setExpiration(new Date(now.getTime() + tokenValidTime))                         .signWith(SignatureAlgorithm.HS256, secretKey)                         .compact(),                 Jwts.builder()                         .setClaims(claims)                         .setIssuedAt(now)                         .setExpiration(new Date(now.getTime() + refreshTokenValidTime))                         .signWith(SignatureAlgorithm.HS256, secretKey)                         .compact());     }      // 토큰이 유효한지 확인     public Authentication getAuthentication(String token) {         Optional&lt;Member&gt; findMember = memberRepository.findByEmail(getMemberEmail(token));         Member member = findMember.get();         return new UsernamePasswordAuthenticationToken(member, \"\",                 Arrays.asList(new SimpleGrantedAuthority(\"ROLE_USER\")));     }      // 이메일 디코딩     public String getMemberEmail(String token) {         try {             return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();         } catch (ExpiredJwtException e) {             return e.getClaims().getSubject();         }     }      // 토큰의 만료 여부 확인     public boolean validateTokenExpiration(String token) {         try {             Jws&lt;Claims&gt; claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);             return !claims.getBody().getExpiration().before(new Date());         } catch (Exception e) {             return false;         }     } }   JwtAuthenticationFilter   발급받은 토큰을 이용해 Security 인증을 처리하는 필터를 만든다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.smtd.smtdApi.github.common;  import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.util.StringUtils; import org.springframework.web.filter.GenericFilterBean;  import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import java.io.IOException;  @RequiredArgsConstructor @Slf4j public class JwtAuthenticationFilter extends GenericFilterBean {      private final JwtTokenProvider jwtTokenProvider;      /**      * JWT 토큰 검증      */     @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         String token = ((HttpServletRequest) request).getHeader(\"Auth\");          if (token != null &amp;&amp; jwtTokenProvider.validateTokenExpiration(token)) {             if (StringUtils.hasText(token) &amp;&amp; jwtTokenProvider.validateTokenExpiration(token)) {                 Authentication auth = jwtTokenProvider.getAuthentication(token);                 SecurityContextHolder.getContext().setAuthentication(auth);             } else {                 log.debug(\"유효한 JWT 토큰이 없습니다.\");             }          }         chain.doFilter(request, response);     } }   TokenController   Access Token이 만료되었을 경우 Refresh Token을 이용해 Access Token을 재발급 받는다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.smtd.smtdApi.github.controller;  import com.smtd.smtdApi.github.dto.TokenDTO; import com.smtd.smtdApi.github.service.MemberService; import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  @RequiredArgsConstructor @RestController @RequestMapping(\"/token\") @Slf4j public class TokenController {      private final MemberService memberService;      @GetMapping(\"/expired\")     public String auth() {         throw new RuntimeException();     }      @GetMapping(\"/refresh\")     public String refreshAuth(HttpServletRequest request, HttpServletResponse response) {         String refreshToken = request.getHeader(\"Refresh\");          TokenDTO newToken = memberService.refresh(refreshToken);          response.addHeader(\"Auth\", newToken.getAccessToken());         response.addHeader(\"Refresh\", newToken.getRefreshToken());         response.setContentType(\"application/json;charset=UTF-8\");          return \"HAPPY NEW TOKEN\";     } }   Security      SecurityConfig   SecurityConfig   OAuth 로그인을 활성화하고 앞서 만든 서비스와 인증이 성공하면 처리할 Handler를 등록한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.smtd.smtdApi.github.common;  import lombok.RequiredArgsConstructor; import org.springframework.context.annotation.Bean; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig {      private final JwtTokenProvider jwtTokenProvider;     private final CustomOAuth2UserService oAuth2UserService;     private final OAuth2SuccessHandler successHandler;      @Bean     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {         http                 .httpBasic().disable()                 .csrf().disable()                 .formLogin().disable()                 .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                 .and()                 .authorizeRequests()                 .antMatchers(\"/auth/**\", \"/login\", \"/token/**\").permitAll()                 .anyRequest().authenticated()                 .and()                 .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class)                 .oauth2Login().loginPage(\"/token/expired\")                 .successHandler(successHandler)                 .userInfoEndpoint().userService(oAuth2UserService);          http.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class);         return http.build();     }      @Bean     public BCryptPasswordEncoder encodePassword() {         return new BCryptPasswordEncoder();     } }   테스트      http://localhost:8080/oauth2/authorization/github로 로그인 시도            처음 로그인하는 유저에겐 서버에서 Access Token과 Refresh Token을 발급해준다.                         기존에 로그인을 한적 있는 유저에겐 기존의 Refresh Token만 보여준다.                       새로 발급받은 AccessToken과 RefreshToken으로 페이지 접속 (Auth: Access Token, Refresh: Refresh Token)                   AccessToken이 만료되면 에러 발생                   RefreshToken을 통해 새로운 AccessToken과 RefreshToken을 재발급 받음. Header 값을 확인하면 토큰값을 확인 할 수 있음             ","categories": ["Spring"],
        "tags": ["Spring","JWT","OAuth"],
        "url": "/spring/Spring-JWT-OAuth-Security/",
        "teaser": ""
      },{
        "title": "JDBC",
        "excerpt":"JDBC 등장배경   애플리케이션 서버는 커넥션 연결, SQL 전달, 결과 응답을 통해 데이터베이스를 사용한다.              커넥션 연결: 주로 TCP/IP를 사용해서 커넥션을 연결            SQL 전달: 애플리케이션 서버는 DB가 이해할 수 있는 SQL을 연결된 커넥션을 통해 DB에 전달            결과 응답: DB는 전달된 SQL을 수행하고 그 결과를 응답하고 애플리케이션 서버는 응답 결과를 활용함       이때 문제점은 각각의 데이터베이스마다 커넥션을 연결하는 방법, SQL을 전달하는 방법, 결과를 응답 받는 방법이 모두 다르다는 점이다. 만약, DB를 다른 종류의 DB로 변경하게 되면 애플리케이션 서버에 개발된 DB 사용 코드도 변경해야 한다. 또한, 개발자가 각각의 DB마다 커넥션 연결, SQL 전달, 결과를 응답 받는 방법을 새로 학습해야 한다.   이런 문제들을 해결하기 위해 JDBC라는 자바 표준이 등장했다.   JDBC란?   JDBC(Java Database Connectivity)는 자바에서 DB에 접속할 수 있도록 하는 자바 API이다. (자바 표준)      JDBC 표준 인터페이스는 대표적으로 다음 3가지 기능을 표준 인터페이스로 정의하여 제공한다.      java.sql.Connection: 연결   java.sql.Statement: SQL을 담은 내용   java.sql.ResultSet: SQL 요청 응답   JDBC 드라이버   JDBC 인터페이스를 각각의 DB 벤더(회사)에서 자신의 DB에 맞게 구현해서 라이브러리로 제공하는데 이것을 JDBC 드라이버라 한다.   이제 JDBC의 등장으로 위에서 언급했던 DB 변경 시 애플리케이션 서버의 DB 사용 코드도 변경해야 하는 문제를 해결하였다.   다른 종류의 DB로 변경하고 싶으면 JDBC 구현 라이브러리만 변경하면 된다. 또한, 개발자가 DB마다 학습해야하는 문제를 해결하였다. 개발자는 이제 JDBC 표준 인터페이스 사용법만 학습하면 된다.   JDBC 사용방법   DB에 연결하려면 JDBC가 제공하는 DriverManager.getConnection()를 사용한다.   1 2 3 4 import java.sql.Connection; import java.sql.DriverManager;  Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);   JDBC DriverManager 연결 이해   JDBC가 제공하는 DriverManager는 라이브러리에 등록된 DB 드라이버들을 관리하고 커넥션을 획득하는 기능을 제공한다.     ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-JDBC/",
        "teaser": ""
      },{
        "title": "JDBC와 최신 데이터 접근 기술(SQL Mapper, ORM)",
        "excerpt":"최근에는 JDBC를 직접 사용하기 보다 SQL Mapper, ORM을 통해 JDBC를 편리하게 사용할 수 있다.   SQL Mapper   SQL Mapper는 JDBC를 편리하게 사용할 수 있도록 도와준다. SQL 응답 결과를 객체로 편리하게 변환해주고 JDBC의 반복 코드를 제거해준다. 하지만 개발자가 직접 SQL을 작성해야 한다는 단점도 있다. 대표적으로 JdbcTemplate, MyBatis가 SQL Mapper에 해당한다.      ORM 기술   ORM(Object Relational Mapper)은 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술이다. ORM 덕분에 개발자는 SQL을 직접 작성하지 않는다. 또한, 개발자 대신 ORM 기술이 SQL을 동적으로 생성해준다. 대표적으로 JPA, 하이버네이트, 이클립스 링크가 있다.   이 중에서 JPA는 자바 진영의 ORM 표준 인터페이스이고 이것을 구현하는 기술이 하이버네이트와 이클립스 링크가 있다. 주로 하이버네이트를 사용한다.      그렇다면 SQL Mapper과 ORM 기술 중 어느 것을 사용하는 것이 좋을까?   SQL Mapper는 SQL만 직접 작성하면 나머지 번거로운 일은 SQL Mapper가 대신 해결해준다. ORM 기술은 SQL을 직접 작성하지 않아도 되서 개발 생산성이 높다. 편리한 반면 쉬운 기술은 아니므로 실무에서 사용하려면 깊이있는 학습이 필요하다.   SQL Mapper와 ORM 기술은 모두 JDBC를 사용한다. JDBC가 어떻게 동작하는지 알고 기본 원리를 알아야 해당 기술을 더 깊이 있게 이해할 수 있고 문제가 발생했을 때 근본적인 문제를 찾아 해결할 수 있다.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-SQLMapper-ORM/",
        "teaser": ""
      },{
        "title": "커넥션 풀",
        "excerpt":"커넥션 풀 등장배경   JDBC 드라이버를 통해 DB 커넥션을 획득하는 과정은 매우 복잡하다. 아래는 DB 커넥션을 획득하는 과정이다.         애플리케이션 로직은 DB 드라이버를 통해 커넥션 조회   DB 드라이버는 DB와 TCP/IP 커넥션을 연결함. (이 과정에서 3 way handshake 같은 TCP/IP 연결을 위한 네트워크 동작이 발생함)   DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달   DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성   DB는 커넥션 생성이 완료되었다는 응답을 보냄   DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환함   이처럼 커넥션을 새로 만드는 것은 과정도 복잡하고 시간도 많이 소요된다. 결과적으로 응답 속도에 영향을 준다.   이를 해결하기 위해 커넥션 풀을 사용한다.   커넥션 풀   커넥션 풀이란 애플리케이션에서 DB 연결을 위해 미리 일정수의 커넥션 객체를 만들어 풀에 보관했다가 사용자의 요청이 발생하면 풀에 생성되어 있는 커넥션 객체를 넘겨주고 사용자가 사용이 끝나면 커넥션 객체를 다시 풀에 반환하여 보관하는 것이다.   커넥션 풀을 사용하는 과정은 다음과 같다.      커넥션 풀 초기화: 애플리케이션을 시작하는 시점에 커넥션 풀은 필요한 만큼 커넥션을 미리 확보해서 풀에 보관한다. 서비스의 특징과 스펙에 따라 다르지만 기본값은 10이다.   커넥션 풀의 연결 상태: 커넥션 풀에 들어있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이기 때문에 언제든지 즉시 SQL을 DB에 전달할 수 있다.   커넥션 풀 사용            커넥션 풀을 통해 이미 생성되어 있는 커넥션을 객체 참조로 가져와 사용한다.       커넥션 풀에 커넥션을 요청하면 커넥션 풀은 자신이 가지고 있는 커넥션 중에 하나를 반환한다.       애플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용해 SQL을 데이터베이스에 전달하고 그 결과를 받아서 처리한다.       커넥션을 모두 사용하고 나면 해당 커넥션을 커넥션 풀에 반환한다. 여기서 주의할 점은 커넥션을 종료하는 것이 아니라 커넥션이 살아있는 상태로 커넥션 풀에 반환한다는 것이다.           커넥션 풀을 사용해서 얻는 이점   서버의 부하를 줄여주고 서버의 한정적인 자원을 효율적으로 사용할 수 있다.   커넥션 풀은 서버당 최대 커넥션 수를 제한할 수 있고 DB에 무한정 연결이 생성되는 것을 맞아주어 DB를 보호하는 역할을 한다. 적절한 커넥션 풀 숫자는 서비스의 특징과 애플리케이션 서버 스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해서 정해야 한다.   커넥션 풀 오픈소스   커넥션 풀은 이점이 매우 크기 때문에 실무에서는 항상 기본으로 사용한다. 커넥션 풀은 개념적으로 단순하여 직접 구현할 수 있지만, 사용도 편리하고 성능도 뛰어난 오픈소스 커넥션 풀이 많아 오픈소스를 사용하는게 좋다. 대표적 커넥션 풀 오픈소스는 commons-dbcp2, tomcat-jdbc pool, HikariCP 등이 있다. 성능과 사용의 편리함 측면에서 최근에는 HikariCP를 주로 사용한다.   HikariCP   JDBC의 커넥션 풀 프레임워크로 가벼운 용량과 빠른 속도가 장점이다. SpringBoot는 커넥션 풀 관리를 위해 HikariCP를 사용한다.   HikariCP 동작 원리      스레드가 커넥션을 요청한다.   이전에 사용했던 커넥션 정보 존재 여부를 확인   이전에 사용했던 커넥션 목록 중 사용 가능한 존재 여부 확인   전체 커넥션 목록 중 사용 가능한 존재 여부 확인   2, 3, 4를 순서대로 동작하며 유효한 커넥션 존재 시 바로 반환한다.   유효한 커넥션이 존재하지 않는다면 HandOffQueue를 Polling하면서 커넥션을 반납하기를 기다린다.   커넥션을 반납하면 커넥션 풀은 HandOffQueue에 반납된 커넥션을 삽입하고 쓰레드는 커넥션을 획득한다.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-ConnectionPool/",
        "teaser": ""
      },{
        "title": "DataSource (데이터 소스)",
        "excerpt":"DataSource 이해   커넥션을 얻는 방법은 DriverManager를 직접 사용해서 커넥션을 생성하는 방법과 커넥션 풀을 사용하는 방법이 있다.   우리가 앞서 JDBC로 개발한 애플리케이션처럼 DriverManager를 통해 커넥션을 획득하다가 커넥션 풀을 사용하는 방법(HikariCP 같은)으로 변경하려면 커넥션을 획득하는 애플리케이션 코드도 함께 변경해야 한다. 의존관계가 DriverManager에서 HikariCP로 변경되기 때문이다.   따라서, 커넥션을 획득하는 방법을 추상화해야 한다.   자바에서는 커넥션을 획득하는 방법을 추상화하기 위해 javax.sql.DataSource라는 인터페이스를 제공한다. 즉, DataSource는 커넥션을 획득하는 방법을 추상화하는 인터페이스이다.      대부분의 커넥션 풀은 DataSource 인터페이스를 미리 구현해두어 추상화했다. 따라서, DBCP2 커넥션 풀, HikariCP 커넥션 풀의 코드를 직접 의존하는 것이 아닌 DataSource 인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다. 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 변경하면 된다.   DriverManager는 DataSource 인터페이스를 사용하지 않으므로 직접 사용해야 한다. 따라서 DriverManager를 사용하다가 DataSource기반의 커넥션 풀을 사용하도록 변경하면 관련 코드를 다 고쳐야 하는데 이런 문제를 해결하기 위해 스프링은 DriverManager도 DataSource를 통해서 사용할 수 있도록 DriverManagerDataSource라는 DataSource를 구현한 클래스를 제공한다.   DriverManager를 통해 커넥션을 획득하는 방법   1 2 3 4 5 6 7 @Test void driverManager() throws SQLException {     Connection con1 = DriverManager.getConnection(URL,USERNAME,PASSWORD);     Connection con2 = DriverManager.getConnection(URL,USERNAME,PASSWORD);     log.info(\"connection={}, class={}\", con1, con1.getClass());     log.info(\"connection={}, class={}\", con2, con2.getClass()); }   DriverManagerDataSource를 통해 커넥션을 획득하는 방법   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test void dataSourceDriverManager() throws SQLException {     // DriverManagerDataSource는 DataSource를 구현하고 있기 때문에 아래과 같이 작성할 수 있다. (28, 29 같은 코드)     // DataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);     DriverManagerDataSource dataSource = new DriverManagerDataSource(URL,USERNAME,PASSWORD);      useDataSource(dataSource); }  private void useDataSource(DataSource dataSource) throws SQLException {     Connection con1 = dataSource.getConnection();     Connection con2 = dataSource.getConnection();     log.info(\"connection={}, class={}\", con1, con1.getClass());     log.info(\"connection={}, class={}\", con2, con2.getClass()); }   기존 DriverManager와 DataSource를 통해 커넥션을 획득하는 방법은 비슷해보이지만 큰 차이가 있다. DriverManager는 커넥션을 획득할 때마다 URL, USERNAME, PASSWORD 같은 파라미터를 계속 전달해야 한다. 반면, DataSource는 처음 객체를 생성할 때만 필요한 파라미터를 전달하고 커넥션을 획득할 때는 dataSource.getConnection()만 호출하면 된다.   결과적으로 설정과 사용을 분리한 것이다.   설정과 사용의 분리   설정: DataSource를 만들고 필요한 속성들을 사용해서 URL, USERNAME, PASSWORD 같은 부분을 입력하는 것을 의미한다. 이렇게 설정과 관련된 속성들은 한곳에 있는 것이 향후 변경에 더 유연하게 대처할 수 있다.   사용: 설정은 신경쓰지 않고 DataSource의 getConnection()만 호출해서 사용하면 된다.   DataSource 적용   DataSource를 외부에서 주입 받아 사용한다.(의존관계 주입, DI+OCP) DataSource는 표준 인터페이스이기 때문에 DriverManagerDataSource에서 HikariDataSource로 변경되어도 해당 코드를 변경하지 않아도 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /**  * JDBC - DataSource 사용. JdbcUtils 사용  */ @Slf4j public class MemberRepositoryV1 {      private final DataSource dataSource;      public MemberRepositoryV1(DataSource dataSource) {         this.dataSource = dataSource;     }      //save()...     //findById()...     //update()....     //delete()....      private void close(Connection con, Statement stmt, ResultSet rs) {         JdbcUtils.closeResultSet(rs);         JdbcUtils.closeStatement(stmt);         JdbcUtils.closeConnection(con);     }      private Connection getConnection() throws SQLException {         Connection con = dataSource.getConnection();         log.info(\"get connection={}, class={}\", con, con.getClass());         return con;     } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Slf4j class MemberRepositoryV1Test {      MemberRepositoryV1 repository;      @BeforeEach     void beforeEach() {         // 기본 DriverManager - 항상 새로운 커넥션을 획득         // DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);          // 커넥션 풀링         HikariDataSource dataSource = new HikariDataSource();         dataSource.setJdbcUrl(URL);         dataSource.setUsername(USERNAME);         dataSource.setPassword(PASSWORD);          repository = new MemberRepositoryV1(dataSource);     }      ... }   DriverManagerDataSource 사용   DriverManagerDataSource를 사용하면 conn0~5 번호를 통해서 항상 새로운 커넥션이 생성되어서 사용되는 것을 확인할 수 있다.      1 2 3 4 5 6 get connection=conn0: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection get connection=conn1: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection get connection=conn2: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection get connection=conn3: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection get connection=conn4: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection get connection=conn5: url=jdbc:h2:.. user=SA class=class org.h2.jdbc.JdbcConnection   HikariDataSource 사용   반면에, 커넥션 풀 사용 시 conn0 커넥션이 재사용되는 것을 확인 할 수 있다.         참고 HikariDataSource   HikariDataSource는 HikariCP로부터 커넥션을 얻어올 수 있도록 하는 DataSource의 구현체이다.    HikariDataSource를 만든 뒤 getConnection()을 하게 되면 HikariDataSource 내에 HikariPool이라는 클래스로부터 커넥션을 가져오게 된다.     참고 링크   HikariCP 커넥션 풀 최적 갯수 구하기  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-DataSource/",
        "teaser": ""
      },{
        "title": "DB 락(Lock)",
        "excerpt":"DB 락 (Lock)   데이터베이스는 여러 사용자들이 같은 데이터를 동시에 접근하는 상황에서 데이터의 무결성과 일관성을 지키기 위해 락을 사용한다.   예를 들어, 세션 1에서 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 세션 2에서 동시에 같은 데이터를 수정하게 되면 트랜잭션의 원자성이 깨진다. 또한, 세션 1이 중간에 롤백하게 되면 세션 2는 잘못된 데이터를 수정하는 문제가 발생한다. 이러한 문제를 해결하지 위해 데이터베이스는 락(Lock)이라는 개념을 제공한다.   세션 1과 세션 2가 같은 데이터 변경을 시도한다고 가정해보자.      세션 1이 트랜잭션을 시작하고 데이터 변경을 시도하면 이때 로우의 락을 획득해야 한다. 비슷한 시점에 세션 2가 트랜잭션을 시작하고 세션 1과 같은 데이터를 변경 시도 한다. 이때 해당 로우의 락을 먼저 획득해야 하는데 락이 없으므로(세션 1이 락을 가지고 있음) 락이 돌아올 때까지 대기하며 락 대기 시간이 넘어가면 락 타임아웃 오류가 발생한다. 세션 1이 커밋을 수행한다. 커밋으로 트랜잭션이 종료되었으므로 락도 반환한다. 락을 획득하기 위해 대기하던 세션 2가 락을 획득하고 데이터 변경을 시도한다.   DB 락 종류   DB 락의 종류에는 공유 락, Shared Lock (Read Lock)과 베타 락, Exclusive Lock (Write Lock)이 있다.   공유 락   공유 락은 데이터를 읽을 때 사용되는 락이다. Read Lock이라고도 불린다. 공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능하다. 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다. 그러나 공유 락이 설정된 데이터에 베타 락은 접근할 수 없다.   베타 락   베타 락은 데이터를 변경할 때 사용되며 트랜잭션이 완료될 때까지 유지된다. 베타락은 락이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.   락의 설정 범위      데이터베이스: 전체 데이터베이스를 기준으로 락을 한다. 즉, 1개의 세션만이 DB의 데이터에 접근이 가능하다. 이 기능은 보통 사용하지 않는다. 사용할 땐 주요한 DB의 업데이트에 사용한다.   파일: DB 파일을 기준으로 락을 설정한다. 파일이란 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소이다.   테이블: 테이블을 기준으로 락을 설정한다. 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행 할 때 유용하다. 즉, DDL(create, alter, drop 등)구문과 함께 사용되며 DDL Lock이라고도 한다.   페이지와 블럭: 파일의 일부인 페이지와 블록을 기준으로 Lock을 설정한다. 잘 사용하지 않는다.   컬럼: 컬럼을 기준으로 Lock을 설정한다. 이 형식은 락 설정 및 해제의 리소스가 많이 들기 때문에 일반적으로 사용되지 않는다.   행: 행 수준의 Lock은 1개의 행을 기준으로 락을 설정한다. DML(select, insert, update, delete)에 대한 락으로 가장 일반적으로 사용하는 락이다.   블로킹(Blocking)   블로킹은 Lock간(베타-베타, 베타-공유)의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춰선 상태를 말한다. 공유락끼리는 블로킹이 발생하지 않지만 베타락은 블로킹이 발생한다. 블로킹을 해소하기 위해서는 이전의 트랜잭션이 완료(commit or rollback)되어야 한다. 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하다. 이런 경합은 성능에 좋지 않은 영향을 주므로 경합을 최소화 해야 한다.   블로킹 해결 방안      한 트랜잭션의 길이를 짧게하여 경합의 확률을 줄인다.   처음부터 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야한다.   트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다.   쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행한다.   교착상태(DeadLock)   교착상태는 두 트랜잭션이 각각 Lock 설정된 상태에서 서로의 락에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 락이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지 않게 되는 상태를 말한다. 예를 들어 트랜잭션 A는 master 테이블의 5번 로우를 수정하고 detail 테이블의 5번 로우를 수정한다. 트랜잭션 B는 detail 테이블의 5번 로우를 수정하고 master 테이블의 5번 로우를 수정한다. 트랜잭션 A,B 모두 락이 설정되어 교착상태(데드락)가 된다.   교착상태가 발생하면 DBMS가 둘 중 한 트랜잭션에 에러를 발생시켜 문제를 해결한다. 교착상태가 발생할 가능성을 줄이기 위해서는 접근 순서를 동일하게 하는 것이 중요하다. 예를 들어 master를 업데이트 한 후 detail을 업데이트 하는 것처럼 접근 순서를 동일하게 하는 것이 중요하다.   DB 락, 조회   일반적인 조회는 락을 사용하지 않지만 조회 시점에 락이 필요한 경우가 있다. 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.   이럴 때는 select for update 구문을 사용하면 된다. 이렇게 하면 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다. 물론 이 경우도 트랜잭션을 커밋하면 락을 반납한다.      참고 select for update 예시   SELECT * FROM book WHERE id=1 FOR UPDATE;    ","categories": ["DB"],
        "tags": ["DB"],
        "url": "/db/DB-Lock/",
        "teaser": ""
      },{
        "title": "트랜잭션",
        "excerpt":"트랜잭션이란   트랜잭션은 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위이다. 모든 작업이 성공해서 DB에 정상 반영하는 것을 커밋(commit)이라 하고, 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것을 롤백(rollback)이라 한다.   트랜잭션 특징, ACID      원자성(Atomicity): 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다. (All or Nothing)   일관성(Consistency): 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다. 예를 들어 DB에서 정한 무결성 제약 조건을 항상 만족해야 한다.   독립성, 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.   영속성, 지속성(Durability): 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 DB 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.      참고 무결성(Integrity)   무결성이란 데이터의 정확성, 일관성을 의미한다.   데이터에 결함이 없는 상태. 즉, 데이터를 정확하고 일관되게 유지하는 것을 의미한다.        참고 무결성 제약 조건(Integrity Constraint)   무결성 제약조건이란 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건을 뜻한다. 데이터베이스에 저장된 데이터의 무결성을 보장하고 데이터베이스의 상태를 일관되게 유지하는 것이 주 목적이다.     트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성인데 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 하는데 이렇게 하면 동시 처리 성능이 매우 나빠진다. 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.   트랜잭션 격리 수준 - Isolation level      READ UNCOMMITED(커밋되지 않은 읽기)   READ COMMITTED(커밋된 읽기) - 일반적으로 사용   REPEATABLE READ(반복 가능한 읽기)   SERIALIZABLE(직렬화 가능)   데이터베이스 연결 구조와 DB 세션   트랜잭션을 이해하기 위해 데이터베이스 서버 연결 구조와 DB 세션에 대해 알아보자.   사용자는 웹 애플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스 서버에 접근할 수 있다. 클라이언트가 DB 서버에 연결을 요청하고 커넥션을 맺게 되면 DB 서버는 내부에 세션이라는 것을 만든다. 그리고 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다. 즉, 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다.      세션은 트랜잭션을 시작하고 커밋, 롤백을 통해 트랜잭션을 종료한다. 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있다. 사용자가 커넥션을 닫으면 세션은 종료된다. 커넥션 풀이 10개의 커넥션을 생성하면 세션도 10개가 생성된다.   트랜잭션 이해   데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 커밋 명령어인 commit을 호출하고, 결과를 반영하고 싶지 않으면 롤백 명령어인 rollback을 호출하면 된다.   커밋을 호출하기 전까지는 임시로 데이터를 저장하기 때문에 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.   등록, 수정, 삭제 모두 같은 원리로 동작하며 앞으로는 등록, 수정, 삭제를 간단히 변경이라는 단어로 표현하겠다.   트랜잭션을 사용하려면 자동 커밋과 수동 커밋을 이해해야 한다.   트랜잭션 자동/수동 커밋   자동 커밋   자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다. 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있지만 쿼리를 하나 실행할 때 마다 자동으로 커밋이 되기 때문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다. 따라서, 커밋과 롤백을 호출하면서 트랜잭션 기능을 제대로 수행하려면 자동 커밋을 끄고 수동 커밋을 사용해야 한다.   수동 커밋   보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다. 수동 커밋 설정을 하면 이후에 꼭 commit, rollback을 호출해야 한다.   1 2 3 4 5 6 // 자동 커밋 모드 설정 set autocommit true;  // 수동 커밋 모드 설정 set autocommit false; commit;  ","categories": ["DB"],
        "tags": ["DB"],
        "url": "/db/DB-Transaction/",
        "teaser": ""
      },{
        "title": "트랜잭션 매니저(추상화, 동기화)",
        "excerpt":"트랜잭션 추상화   트랜잭션을 사용하는 코드는 데이터 접근 기술(JDBC, JPA 등)마다 다르다. 따라서 데이터 접근 기술이 변경되면 서비스 코드도 변경해야 하므로 OCP 원칙을 위반하고 유지보수 측면에서도 좋지 않다. 이 문제를 해결하기 위해 트랜잭션 기능을 추상화한다.   트랜잭션 추상화 인터페이스   트랜잭션은 단순하다. 트랜잭션을 시작하고, 비즈니스 로직의 수행이 끝나면 커밋, 롤백하면 된다.   1 2 3 4 5 public interface TxManager {     begin();     commit();     rollback(); }   트랜잭션을 추상화하면 서비스는 특정 트랜잭션 기술에 직접 의존하는 것이 아닌 추상화된 인터페이스에 의존하게 된다.(DI) 따라서, OCP 원칙을 지키게 된다. 트랜잭션을 사용하는 서비스 코드를 전혀 변경하지 않고 트랜잭션 기술을 변경할 수 있다.      스프링의 트랜잭션 추상화   스프링은 트랜잭션 추상화 기술을 트랜잭션 매니저 객체를 통해 제공한다. 스프링 트랜잭션 추상화의 핵심은 PlatformTransactionManager 인터페이스이다.   PlatformTransactionManager 인터페이스   1 2 3 4 5 6 7 8 9 10 package org.springframework.transaction;  public interface PlatformTransactionManager extends TransactionManager {     // 트랜잭션 시작     TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;     // 트랜잭션 커밋     void commit(TransactionStatus status) throws TransactionException;     // 트랜잭션 롤백     void rollback(TransactionStatus status) throws TransactionException; }   트랜잭션 동기화   트랜잭션 매니저의 역할은 크게 2가지 이다.      트랜잭션 추상화 (위에서 언급)   리소스 동기화   리소스 동기화   트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지해야 한다.   같은 커넥션을 동기화(맞추어 사용)하기 위해 이전에는 파라미터로 커넥션을 전달하는 방법을 사용했으나 이 방법은 코드가 지저분하고 커넥션을 넘기는 메서드와 넘기지 않는 메서드를 중복해서 만들어야 하는 등 여러가지 단점들이 많다.   이러한 문제를 해결하기 위해 스프링은 트랜잭션 동기화 매니저를 제공한다. 트랜잭션 동기화 매니저는 쓰레드 로컬(ThreadLocal)을 사용해서 커넥션을 동기화 해준다. 그렇기 때문에 멀티 쓰레드 상황에서도 안전하게 커넥션을 동기화 할 수 있다. 따라서, 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다.      참고 쓰레드 로컬   여러개의 쓰레드가 존재할 때, 해당 쓰레드만 접근할 수 있는 특별한 저장소를 의미한다. ThreadLocal 클래스는 오직 한 쓰레드에 의해 읽고/쓰여질 수 있는 변수를 생성한다.     트랜잭션 매니저 동작 흐름      클라이언트의 요청으로 서비스 로직을 실행한다.      서비스 계층에서 transactionManager.getTransaction()을 호출해서 트랜잭션을 시작한다.   트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성한다.   커넥션을 수동 커밋 모드로 변경해서 데이터베이스 트랜잭션을 시작한다.   커넥션을 트랜잭션 동기화 매니저에 보관한다.   트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 이제 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.   서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. 이때 커넥션을 파라미터로 전달하지 않는다.   리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는 DataSourceUtils.getConnection()을 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 사용한다. 이 과정을 통해서 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지된다.   획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.   트랜잭션 매니저를 적용한 코드   1 2 3 4 5 6 7 8 /**  * MemberRepositoryV3  */ // 커넥션을 얻을 때 DataSourceUtils.getConnection(dataSource);  // 커넥션을 닫을 때, 유지할 때 DataSourceUtils.releaseConnection(con, dataSource);   트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.   DataSourceUtils.getConnection()은 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환하고 없으면 새로운 커넥션을 생성해서 반환한다.   커넥션을 con.close()를 사용해서 직접 닫아버리면 커넥션이 유지되지 않는 문제가 발생한다. 따라서, DataSourceUtils.releaseConnection()를 사용한다. DataSourceUtils.releaseConnection()을 사용하면 트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지하며 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Slf4j @RequiredArgsConstructor public class MemberServiceV3_1 {      private final PlatformTransactionManager transactionManager;     private final MemberRepositoryV3 memberRepository;      public void accountTransfer(String fromId, String toId, int money) {         // 트랜잭션 시작, 트랜잭션 상태값을 반환         TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());          try {             // 비즈니스 로직             bizLogic(fromId, toId, money);             transactionManager.commit(status); // 성공 시 commit         } catch (Exception e) {             transactionManager.rollback(status); //실패 시 rollback             throw new IllegalStateException(e);         }         // transactionManager가 commit, rollback 할 때 close 해주므로 따로 close 해줄 필요 없다.     }      ... }   PlatformTransactionManager 트랜잭션 매니저를 주입받는다. PlatformTransactionManager은 인터페이스이기 때문에 JDBC 기술에서 JPA로 변경해도 문제가 없다. new DefaultTransactionDefinition()은 트랜잭션과 관련된 옵션을 지정할 수 있다.   1 2 3 4 5 6 7 8 9 @BeforeEach void before() {     DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);     // PlatformTransactionManager의 구현체     DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(dataSource);     postRepository = new PostRepositoryV3(dataSource);     // PlatformTransactionManager에 transactionManager 주입     postService = new PostServiceV3_1(transactionManager, postRepository); }  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-TransactionManager/",
        "teaser": ""
      },{
        "title": "스프링 AOP",
        "excerpt":"AOP란?   AOP(Aspect Oriented Programming)는 관점 지향 프로그래밍이라고 하며 자바와 같은 객체 지향 프로그래밍(OOP)을 더욱 OOP 답게 사용할 수 있도록 도와주는 역할을 한다.   AOP는 여러 개의 핵심 비즈니스 로직 외에 공통으로 처리되어야 하는 로그 출력, 보안 처리, 예외 처리 같은 코드를 별도로 분리해서 하나의 단위로 묶는 모듈화의 개념으로 생각할 수 있다.   AOP에서 관점은 핵심적인 관점과 부가적인 관점으로 나눌 수 있다.   핵심적인 관점은 핵심 비즈니스 로직을 의미하고, 부가적인 관점은 공통으로 처리되어야 하는 코드를 의미한다.   MVC 패턴의 특성상, 컨트롤러 → 서비스 → DAO(Mapper) 순으로 작동한다. 필수적으로 처리되어야 하는 로그, 보안, 트랜잭션, 예외 처리와 같은 부가적인 기능들이 각각의 핵심 기능마다 추가된다면 코드가 매우 길어진다.   AOP는 이러한 문제를 관점이라는 개념을 통해 해결할 수 있다.   부가적인 관점에서는 핵심 비즈니스 로직이 어떤 기능을 수행하는지에 대해 전혀 알 필요 없고 핵심 비즈니스 로직 안에서 필요한 시점에 부가적인 관점이 포함되기만 하면 되는 것이다.      왼쪽: 객체 지향 프로그래밍, 오른쪽, 관점 지향 프로그래밍   객체 지향 프로그래밍과 달리 부가적인 관점이 핵심 비즈니스 로직의 바깥에 포함되어 있다. AOP를 적용하면 로그, 보안, 트랜잭션, 예외 처리와 같은 부가적인 기능들을 일일이 추가하지 않아도 된다.   AOP 용어   관점(Aspect)   공통적으로 정의될 기능을 의미한다. 부가적인 기능을 정의한 코드인 어드바이스와 어드바이스를 어느 곳에 적용할지 결정하는 포인트컷의 조합으로 만들어진다.   어드바이스(Advice)   실제로 부가적인 기능을 구현한 객체를 의미한다.   포인트컷(Pointcut)   어드바이스를 적용할 조인 포인트를 선별하는 과정이나 그 기능을 정의한 모듈을 의미한다. 정규표현식이나 AspectJ 문법을 사용해서 어떤 조인 포인트를 사용할지 결정한다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Java-AOP/",
        "teaser": ""
      },{
        "title": "트랜잭션 AOP",
        "excerpt":"트랜잭션 AOP   트랜잭션을 처리하는 코드의 중복과 순수 자바코드를 삭제 하기 위해 트랜잭션 추상화, 트랜잭션 템플릿을 도입했다. 트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있었으나, 서비스 계층에 순수한 비즈니스 로직만 남긴다는 목표는 아직 달성하지 못했다. 이럴 때 스프링 AOP를 통해 프록시를 도입하면 문제를 깔끔하게 해결할 수 있다.      참고   스프링 AOP와 프록시에 대해서는 @Transactional을 사용하면 스프링이 AOP를 사용해서 트랜잭션을 편리하게 처리해준다 정도로 이해하자     프록시를 통한 문제 해결   프록시를 도입하기 전에는 서비스 로직에서 트랜잭션을 시작하지만, 프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 분리할 수 있다. 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져가고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에서는 순수한 비즈니스 로직만 남길 수 있다.      트랜잭션을 처리하는 프록시 코드를 스프링이 만들어준다. try, catch 같은 코드를 자동으로 만들어주고 자동으로 빈으로 등록해준다. 트랜잭션 프록시에서 실제 비즈니스 서비스를 호출하고 응답이 왔을 때 성공했으면 commit, 언체크(런타임) 예외가 올 경우 rollback을 한다.   트랜잭션 프록시 적용한 서비스 코드 예시   1 2 3 4 5 6 public class Service {     public void logic() {         //트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음         bizLogic(fromId, toId, money);     } }   스프링 트랜잭션 AOP   스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만 스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다. 트랜잭션 처리가 필요한 곳에 @Transactional 애노테이션를 붙여주면 트랜잭션 프록시를 적용해준다.   1 2 3 4 5 6 import org.springframework.transaction.annotation.Transactional  @Transactional public void accountTransfer(String fromId, String toId, int money) throws SQLException {     bizLogic(fromId, toId, money); }   이제 순수한 비즈니스 로직만 남고 트랜잭션 관련 코드는 모두 제거되었다.   @Transactional은 메서드에 붙여도 되고, 클래스에 붙여도 된다. 클래스에 붙이면 외부에서 호출 가능한 public 메서드가 AOP 적용 대상이 된다.   이후 서비스 코드에서 service.getClass()를 출력하면 EnhancerBySpringCGLIB.. 라는 부분을 통해 프록시(CGLIB)가 적용된 것을 확인할 수 있다.         참고   스프링 AOP를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요함. 스프링은 트랜잭션 AOP 처리를 위해 다음 클래스를 제공. 스프링 부트를 사용하면 해당 빈들은 스프링 컨테이너에 자동으로 등록됨.         어드바이저: BeanFactoryTransactionAttributeSourceAdvisor     포인트컷: TransactionAttributeSourcePointcut     어드바이스: TransactionInterceptor       선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리   선언적 트랜잭션 관리는 @Transactional 애노테이션을 선언해서 트랜잭션을 적용하는 것을 의미하며, 프로그래밍 방식 트랜잭션 관리는 트랜잭션 관련 코드를 직접 작성하는 것을 말한다.   선언적 트랜잭션 관리가 프로그래밍 방식에 비해 간결하고 실용적이기 때문에 실무에서는 대부분 선언적 트랜잭션 관리를 사용한다.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-TransactionAOP/",
        "teaser": ""
      },{
        "title": "트랜잭션 템플릿",
        "excerpt":"트랜잭션 템플릿   트랜잭션 템플릿을 사용하면 JDBC의 같은 패턴이 반복되는 것을 제거할 수 있다.   트랜잭션을 시작하려면 try, catch, finally를 포함한 성공시 커밋, 실패시 롤백 코드가 반복된다.   이런 형태는 각각의 서비스에서 반복되며 달라지는 부분은 비즈니스 로직 뿐이다. 이때 템플릿 콜백 패턴을 사용하면 중복을 제거할 수 있다.   템플릿 콜백 패턴을 적용하려면 템플릿을 제공하는 클래스를 작성해야 하는데 스프링은 TransactionTemplate라는 템플릿 클래스를 제공한다.   1 2 3 4 5 6 7 public class TransactionTemplate {     private PlatformTransactionManager transactionManager;     // 응답값이 있을 때 사용     public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action){..}     // 응답값이 없을 때 사용     void executeWithoutResult(Consumer&lt;TransactionStatus&gt; action){..} }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /**  * 트랜잭션 - 트랜잭션 템플릿  */ @Slf4j public class MemberServiceV3_2 {      //    private final PlatformTransactionManager transactionManager;     private final TransactionTemplate txTemplate;     private final MemberRepositoryV3 memberRepository;      public MemberServiceV3_2(PlatformTransactionManager transactionManager, MemberRepositoryV3 memberRepository) {         this.txTemplate = new TransactionTemplate(transactionManager);         this.memberRepository = memberRepository;     }      public void accountTransfer(String fromId, String toId, int money) {         txTemplate.executeWithoutResult((status) -&gt; {             // 비즈니스 로직             try {                 bizLogic(fromId, toId, money);             } catch (Exception e) {                 throw new IllegalStateException(e);             }         });     }      ... }   트랜잭션 템플릿 덕분에 트랜잭션을 시작하고 커밋하거나 롤백하는 코드가 모두 제거되었다. 트랜잭션 템플릿은 비즈니스 로직이 정상 수행되면 커밋하고 언체크 예외가 발생하면 롤백한다. 그 외의 경우엔 커밋한다. SQLException 체크 예외는 언체크 예외로 바꾸어 던진다.   트랜잭션 템플릿을 통해 JDBC 반복되는 코드를 제거할 수 있었다. 그러나 아직도 서비스 계층에서 트랜잭션을 사용하기 위한 코드가 존재한다. 비즈니스 로직은 핵심 기능이고 트랜잭션은 부가 기능이다. 이렇게 두 관심사를 하나의 클래스에서 처리하면 유지보수가 어려워진다. 서비스 로직은 핵심 비즈니스 로직만 있어야 한다. 이 문제를 트랜잭션 AOP를 통해 해결할 수 있다.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-TransactionTemplate/",
        "teaser": ""
      },{
        "title": "Git commit 로그 수정",
        "excerpt":"직전에 작성한 commit 변경   아래 명령어 입력하고 수정한 다음 :wq 로 저장   1 git commit --amend   이전에 작성한 commit 변경   1 git rebase -i &lt;commit&gt;   위 명령어를 입력하면 커밋 목록이 표시된다. 그 중에서 수정하려는 커밋을 찾아 그 행의 pick 문자를 edit으로 변경하고 저장, 종료한다.   그 후 아래 명령어 입력하여 commit 변경한다.   1 git commit --amend   마지막으로 –continue옵션을 지정하여 rebase를 실행한다.   1 git rebase --continue   commit 날짜 변경   1 2 3 4 5 # 마지막 Commit 날짜를 현재 날짜로 설정 git commit --amend --no-edit --date \"$(date)\"  # 마지막 Commit 날짜를 임의의 날짜로 설정 git commit --amend --no-edit --date \"Mon 20 Aug 2018 20:19:19 KST\"   author 변경   1) commit 만 했을 때   1 git commit --amend --author=\"yessm621 &lt;yessm621@gmail.com&gt;\"  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/Git-GitCommitModify/",
        "teaser": ""
      },{
        "title": "언체크 예외 사용과 예외 사용 시 주의점",
        "excerpt":"언체크 예외를 사용해야 하는 이유   현재 트렌드는 언체크 예외를 사용하고 체크 예외는 거의 사용하지 않는다.   체크 예외는 컴파일러가 예외 누락을 체크해주기 때문에 개발자가 실수하는 것을 막아준다. 이러한 점을 보았을 때 체크 예외를 사용하는 것이 언체크 예외보다 안전하고 좋아보이는데 왜 체크 예외를 사용하지 않을까?   체크 예외의 문제점 2가지      복구 불가능한 예외: 대부분의 예외는 복구 불가능하다. 따라서, 공통으로 오류 로그를 남기고 개발자가 해당 오류를 빠르게 인지하는 것이 필요하다.   의존관계에 대한 문제: 체크 예외는 복구 불가능한 예외이다. 컴파일러가 예외를 확인하기 때문에 처리할 수 없어도 throws를 통해 던지는 예외를 선언해야 한다. 결과적으로 컨트롤러나 서비스에서 JDBC 기술을 의존하게 되어 OCP, DI를 지키지 못한다. (JDBC 기술에서 JPA로 변경 시 예외처리 관련 코드를 모두 변경해야 한다)   이러한 문제점을 해결하기 위해 언체크(런타임) 예외를 사용한다.   런타임 예외를 사용하면 복구 불가능한 예외에 대해 신경 쓸 필요가 없다. (일관성 있게 공통으로 처리하면 된다) 또한, 처리할 수 없는 예외에 대해선 무시하면 되므로 예외를 강제로 의존하지 않아도 된다. 결과적으로 JDBC 기술을 의존하다가 JPA로 변경하여도 영향이 없다.   체크 예외 사용 테스트   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Test void checked() {     Controller controller = new Controller();     assertThatThrownBy(() -&gt; controller.request())             .isInstanceOf(Exception.class); }  static class Controller {     Service service = new Service();      public void request() throws SQLException, ConnectException {         service.logic();     } }  static class Service {     Repository repository = new Repository();     NetworkClient networkClient = new NetworkClient();      public void logic() throws SQLException, ConnectException {         repository.call();         networkClient.call();     } }   언체크 예외 사용 테스트   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test void unchecked() {     Controller controller = new Controller();     assertThatThrownBy(() -&gt; controller.request())             .isInstanceOf(Exception.class);             // .isInstanceOf(RuntimeSQLException.class); }  static class Controller {     Service service = new Service();      public void request() {         service.logic();     } }  static class Service {     Repository repository = new Repository();     NetworkClient networkClient = new NetworkClient();      public void logic() {         repository.call();         networkClient.call();     } }   예외 포함과 스택 트레이스   중요한 내용! 실무에서 많이 하는 실수이다.   예외를 전환할 때 기존 예외를 반드시 포함해야 한다. (예를 들면 체크 예외를 언체크 예외로 전환할 때) 그렇지 않으면 스택 트레이스를 확인할 때 심각한 문제가 발생한다.   1 2 3 4 5 6 7 8 9 10 @Test void printEx() {     Controller controller = new Controller();     try {         controller.request();     } catch (Exception e) { //        e.printStackTrace();         log.info(\"ex\", e);     } }   로그를 출력할 때 마지막 파라미터에 예외를 넣어주면 로그에 스택 트레이스를 출력할 수 있다. System.out으로도 출력 가능하다. 하지만 실무에선 로그를 사용하는게 좋다.   1 2 3 4 5 6 7 // 로그 출력 // 마지막 파라미터에 ex를 전달. log.info(\"message={}\", \"message\", ex) log.info(\"ex\", ex)  // System.out으로 출력 e.printStackTrace()      참고 스택 트레이스란?   프로그램이 시작된 시점부터 현재 위치까지의 메서드 호출 목록이다. 이는 예외가 어디서 발생했는지 알려주기 위해 JVM이 자동으로 생성한다.     기존 예외를 포함하는 경우   1 2 3 4 5 6 7 public void call() {     try {         runSQL();     } catch (SQLException e) {         throw new RuntimeSQLException(e); //기존 예외(e) 포함      } }   1 2 3 4 5 6 7 8 9 10 23:35:32.280 [main] INFO hello.jdbc.exception.basic.UnCheckedAppTest - ex hello.jdbc.exception.basic.UnCheckedAppTest$RuntimeSQLException: java.sql.SQLException: ex \tat hello.jdbc.exception.basic.UnCheckedAppTest$Repository.call(UnCheckedAppTest.java:59) \tat hello.jdbc.exception.basic.UnCheckedAppTest$Service.logic(UnCheckedAppTest.java:43) \tat hello.jdbc.exception.basic.UnCheckedAppTest$Controller.request(UnCheckedAppTest.java:34) \tat hello.jdbc.exception.basic.UnCheckedAppTest.printEx(UnCheckedAppTest.java:24) \tCaused by: java.sql.SQLException: ex \tat hello.jdbc.exception.basic.UnCheckedAppTest$Repository.runSQL(UnCheckedAppTest.java:64) \tat hello.jdbc.exception.basic.UnCheckedAppTest$Repository.call(UnCheckedAppTest.java:57) \t... 72 common frames omitted   기존 예외를 포함하면 RuntimeSQLException 뿐만 아니라 기존에 발생한 java.sql.SQLException과 스택 트레이스를 확인할 수 있다.   기존 예외를 포함하지 않는 경우   1 2 3 4 5 6 7 public void call() {     try {         runSQL();     } catch (SQLException e) {         throw new RuntimeSQLException(); //기존 예외(e) 제외      } }   1 2 3 4 5 6 23:52:52.921 [main] INFO hello.jdbc.exception.basic.UnCheckedAppTest - ex hello.jdbc.exception.basic.UnCheckedAppTest$RuntimeSQLException: null \tat hello.jdbc.exception.basic.UnCheckedAppTest$Repository.call(UnCheckedAppTest.java:60) \tat hello.jdbc.exception.basic.UnCheckedAppTest$Service.logic(UnCheckedAppTest.java:44) \tat hello.jdbc.exception.basic.UnCheckedAppTest$Controller.request(UnCheckedAppTest.java:35) \tat hello.jdbc.exception.basic.UnCheckedAppTest.printEx(UnCheckedAppTest.java:24)   기존 예외를 포함하지 않으면 기존에 발생한 java.sql.SQLException과 스택 트레이스를 확인할 수 없고 변환한 RuntimeSQLException부터 예외를 확인할 수 있다. 만약, 실제 DB에 연동했다면 DB에서 발생한 예외를 확인할 수 없는 심각한 문제가 발생한다.   1 💡 예외를 전환할 때는 꼭 기존 예외를 포함하자.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-UncheckedExceptionUsed/",
        "teaser": ""
      },{
        "title": "JDBC Template",
        "excerpt":"템플릿 패턴   템플릿 패턴이란 어떤 작업을 처리할 때 전체적인 구조는 동일하면서 부분적으로 다른 구문으로 구성하여 코드의 중복을 최소화 할 때 유용한 패턴이다.   JDBC Template   JDBC 템플릿은 JDBC와 마찬가지로 데이터를 저장하기 위해 사용하는 API이다. 스프링의 가장 기본적인 Data Access 템플릿으로 쿼리 기반으로 데이터베이스의 접근이 가능하다. JDBC 템플릿을 사용하면 리포지토리에서 JDBC를 사용함으로써 발생하는 반복 문제를 해결할 수 있다.   JDBC 반복 문제      커넥션 조회, 커넥션 동기화   PreparedStatement 생성 및 파라미터 바인딩   쿼리 실행   결과 바인딩   예외 발생 시 스프링 예외 변환기 실행   리소스 종료   리포지토리의 각각의 메서드를 살펴보면 상당히 많은 부분이 반복되는데 이런 반복을 효과적으로 처리하는 방법이 바로 템플릿 콜백 패턴이다. 또한, 스프링은 JDBC의 반복 문제를 해결하기 위해 JdbcTemplate이라는 템플릿 제공한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /**  * JdbcTemplate 사용  */ @Slf4j public class MemberRepositoryV5 implements MemberRepository {      private final JdbcTemplate template;      public MemberRepositoryV5(DataSource dataSource) {         this.template = new JdbcTemplate(dataSource);     }      @Override     public Member save(Member member) {         String sql = \"insert into member(member_id, money) values (?, ?)\";         template.update(sql, member.getMemberId(), member.getMoney());         return member;     }      @Override     public Member findById(String memberId) {         String sql = \"select * from member where member_id =?\";         return template.queryForObject(sql, memberRowMapper(), memberId);     }      private RowMapper&lt;Member&gt; memberRowMapper() {         return (rs, rowNum) -&gt; {             Member member = new Member();             member.setMemberId(rs.getString(\"member_id\"));             member.setMoney(rs.getInt(\"money\"));             return member;         };     }      ... }   JdbcTemplate은 JDBC로 개발할 때 발생하는 반복을 대부분 해결한다. 또한, 지금까지 학습했던 트랜잭션을 위한 커넥션 동기화와 예외 발생 시 스프링 예외 변환기도 자동으로 실행해주므로 따로 코드를 작성할 필요가 없다.  ","categories": ["Spring"],
        "tags": ["Spring","DB"],
        "url": "/spring/Spring-JdbcTemplate/",
        "teaser": ""
      },{
        "title": "람다식(Lambda Expression)",
        "excerpt":"지네릭스(Generics)의 등장과 람다식(Lambda Expression)의 등장으로 인해 자바는 새로운 변화를 맞이했다. 그 중 람다식에 대해 알아보겠다.   람다식이란?   람다식(Lambda Expression)이란 메서드를 하나의 식으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지기 때문에, 람다식은 익명 함수라고도 한다.   람다식은 간결하면서도 이해하기 쉽다는 장점이 있다. 또한, 메서드는 클래스에 포함되어야 한다는 제약이 있지만 람다식은 특별한 제약 없이 람다식 자체만으로도 이 메서드의 역할을 대신할 수 있다.      참고 메서드와 함수의 차이   메서드는 함수와 같은 의미이지만, 특정 클래스에 반드시 속해야 한다는 제약이 있다. 그래서 기존의 함수와 같은 의미의 다른 용어를 선택해서 사용한 것이다. 그러나 이제 다시 람다식을 통해 메서드가 하나의 독립적인 기능을 하기 때문에 함수라는 용어를 사용한다.     람다식 작성하기   람다식은 익명 함수 답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 → 를 추가한다.   1 2 3 4 5 6 7 반환티입 메소드명 (매개변수, ...) { \t  실행문 }  (매개변수, ...) -&gt; { \t  실행문 }   1 2 3 4 5 6 7 int max(int a, int b) {     return a &gt; b ? a : b; }  (int a, int b) -&gt; {     return a &gt; b ? a : b; }   반환값이 있는 메서드의 경우, return문 대신 식으로 대신 할 수 있다. 식의 연산결과가 자동적으로 반환값이 된다. 이때는 문장이 아닌 식이므로 끝에 ;을 붙이지 않는다.   1 2 3 4 5 (int a, int b) {     return a &gt; b ? a : b; }  (int a, int b) -&gt; a &gt; b ? a : b   람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다. 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.   1 2 3 (int a, int b) -&gt; a &gt; b ? a : b  (a, b) -&gt; a &gt; b ? a : b   람다식의 장점과 단점   람다식을 사용하면 코드가 간결해지고 가독성이 높아진다.   하지만 디버깅이 어려우며 재사용이 불가능하므로 람다를 자주 사용하면 비슷한 함수가 중복 생성되어 코드가 지저분해 질 수 있다. 또한, 재귀로 만들 경우에 부적합하다. 결국, 상황에 따라 필요에 맞는 방법을 사용하는 것이 좋다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-LambdaExpression/",
        "teaser": ""
      },{
        "title": "[CentOS] vi 편집기 꾸미기",
        "excerpt":"vi 편집기를 이쁘게 꾸며보겠다.   우선 vim을 설치하고 alias를 설정해 vi를 vim으로 변경하겠다.   아래 명령어를 통해 vim 설치한다.   1 yum install vim   alias 설정하기 위해 .bashrc 파일을 수정한다.   1 vi ~/.bashrc   아래 코드를 넣고 :wq로 저장하고 나온다.   1 alias vi='vim'   수정한 .bashrc 파일을 적용한다.   1 source ~/.bashrc   이제 Syntax Highlighting을 설정하기 위해 colorscheme를 선택한다. 필자는 jellybeans 테마를 선택했다.   아래 경로에 선택한 colorscheme를 넣는다.   (다운로드 링크) jellybeans.vim   1  cd /usr/share/vim/vim74/colors/      참고   mac에서 적용할 때는 ~/.vim/colors 폴더에 테마를 넣으면 된다.     그리고 root 경로에 있는 .vimrc 파일을 수정한다. (없으면 새로 만들어도 된다.)   1 vi ~/.vimrc   .vimrc 파일에 아래 내용 입력하고 :wq로 저장하고 나온다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 set hlsearch \" 검색어 하이라이팅 set nu \" 줄번호 set autoindent \" 자동 들여쓰기 set scrolloff=2 set wildmode=longest,list set ts=4 \"tag select set sts=4 \"st select set sw=1 \" 스크롤바 너비 set autowrite \" 다른 파일로 넘어갈 때 자동 저장 set autoread \" 작업 중인 파일 외부에서 변경됬을 경우 자동으로 불러옴 set cindent \" C언어 자동 들여쓰기 set bs=eol,start,indent set history=256 set laststatus=2 \" 상태바 표시 항상 \"set paste \" 붙여넣기 계단현상 없애기 set shiftwidth=4 \" 자동 들여쓰기 너비 설정 set showmatch \" 일치하는 괄호 하이라이팅 set smartcase \" 검색시 대소문자 구별 set smarttab set smartindent set softtabstop=4 set tabstop=4 set ruler \" 현재 커서 위치 표시 set incsearch set statusline=\\ %&lt;%l:%v\\ [%P]%=%a\\ %h%m%r\\ %F\\  \" 마지막으로 수정된 곳에 커서를 위치함 au BufReadPost * \\ if line(\"'\\\"\") &gt; 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | \\ exe \"norm g`\\\"\" | \\ endif \" 파일 인코딩을 한국어로 if $LANG[0]=='k' &amp;&amp; $LANG[1]=='o' set fileencoding=korea endif \" 구문 강조 사용 if has(\"syntax\")  syntax on endif  colorscheme jellybeans   이제 아래와 같이 보기 좋은 vi 편집기를 볼 수 있다.     ","categories": ["Linux"],
        "tags": ["Linux"],
        "url": "/linux/Linux-Vi-Editor/",
        "teaser": ""
      },{
        "title": "[Mac] Django 프로젝트 셋팅 중 mysqlclient 오류",
        "excerpt":"Django 프로젝트를 셋팅하는 중에 mysqlclient 패키지 설치 시 오류가 발생했다.   원인을 찾아보던 중 mysqlclient 패키지의 버전에 따라 python의 버전을 변경해줘야 한다는 것을 보고 python 버전을 3.9에서 3.7로 낮춰주었다.   brew 설치된 상태에서 아래 명령어를 입력하여 python3.7 버전 설치   1 brew install python@3.7   python 3.7 버전으로 설치되었는지 확인   1 python3   설치한 파이썬 경로를 .bash_profile에 환경변수 등록해야 한다.   1 vi ~/.bash_profile   아래 내용을 .bash_profile에 입력하고 :wq 로 저장하고 나옴   1 2 export PATH=/usr/local/opt/python@3.7/libexec/bin:$PATH export LDFLAGS=\"-L/usr/local/opt/python@3.7/lib\"   터미널을 껏다 켜도 적용되도록 아래 명령어 입력   1 source ~/.bash_profile   새로운 터미널을 열어 환경변수가 잘 적용되었는지 확인하면 끝난다.   만약, 새로운 터미널을 열었는데 적용이 안된다면 zsh 문제일 수 있다. (필자의 경우가 그랬다.)   터미널 테마가 zsh였는데, zsh의 경우엔 터미널이 실행될 때 ~/.zshrc를 실행한다고 한다. .zshrc에는 파이썬과 관련된 환경변수를 설정하지 않았으니 당연히 초기화 되는 것처럼 보일 수 밖에 없다.   따라서, .bash_profile을 수정하면 .zshrc에서도 수정되도록 설정하자.   1 vi ~/.zshrc   .zshrc에 아래 내용을 입력 후 :wq 명령어를 통해 저장하고 나온다.   1 2 3 if [ -f ~/.bash_profile ]; then \t. ~/.bash_profile fi   환경변수를 적용한다.   1 source ~/.zshrc   만약 아래와 같은 오류가 발생한다면,   1 compinit:503: no such file or directory: /usr/local/share/zsh/site-functions/_brew_services   아래 명령어를 통해 해결   1 brew cleanup   다시 터미널을 새로 열어서 환경변수가 잘 적용되었는지 확인한다.  ","categories": ["Mac"],
        "tags": ["Mac","MySQL","Python"],
        "url": "/mac/Mac-MysqlClient/",
        "teaser": ""
      },{
        "title": "Github 접속을 위한 SSH 키 생성 및 등록",
        "excerpt":"   참고   MAC m1 부터는 이 방법이 아닌 token 인증 방식으로 진행해야 한다고 한다..     SSH 키   Github을 사용할 때 SSH 키를 등록하는 이유   로컬 개발 환경에서 Git을 사용할 경우엔 SSH가 없어도 상관없다. 하지만, Git 서버에 코드를 Clone하거나 Push 할 때 SSH 프로토콜을 사용한다.   SSH를 사용하는 이유는 (로컬이 아닌)다른 서버에 명령어를 전달하고 결과를 받아 볼 때 안전한 방식으로 통신하기 때문이다. SSH는 여러가지 인증 방법을 제공하는데 그 중에서도 편리성이나 안정성 면에서 추천하는 방식이 공개키 인증 방식이다.   공개키 인증 방식   공개키 인증 방식을 사용하려면 공개키와 개인키 한쌍을 만든다. 공개키는 접속하고자 하는 서버에 등록하는 용도로 사용한다. 사용자는 개인키를 통해 SSH에 접속하고 연결 요청을 받은 SSH 서버에서 서버에 등록된 공개키 중 요청 받은 개인키와 매치되는 공개키가 있는지 찾고 있다면 인증에 성공하고 서버에 접속된다. (없다면 인증에 실패한다.) 공개키는 어디에 공개되어도 문제가 없으나 개인키는 다른 사람에게 노출하지 않도록 안전하게 보관해야 한다.   SSH 키 생성   Github에서도 SSH 방식을 사용한다. 공개키 인증 방식을 사용하기 전에 이미 생성된 키가 있는지 확인하는게 좋다.   1 2 ➜  ~/.ssh ➜  ls      디렉토리에 **.pub(공개키), **(개인키)가 있다면 이미 키를 생성한 적이 있는 것이다. 키가 있다면 아래 키 생성과정은 생략해도 좋다.   키 생성은 ssh-keygen으로 생성한다.   1 ➜  ssh-keygen -t rsa -b 4096 -C \"yessm621@gmail.com\"   위 명령어를 입력하면 첫번째로 키를 어디에 생성하지 묻는데 기본 위치인 ~/.ssh 에 저장하는게 좋다. 다음으로 SSH 키에 대한 비밀번호를 지정할지 묻는데 비밀번호를 지정해도 되고 생략하고 싶다면 엔터키를 누르면 된다.         참고 Github에서는 패스워드 설정을 권장한다.     이제 SSH 키가 생성되었다. 공개키는 ***.pub 형식으로 저장된다.      cat 명령어를 통해 생성된 공개키를 확인할 수 있다.   1 ➜  cat id_rsa.pub   다시 한번 강조하지만 개인키는 절대로 공개되어선 안된다.      ##Github에 SSH 키 등록   이제 Github에 공개키를 등록해보자.   Github 페이지 (https://github.com )에 접속 &gt; 오른쪽 상단의 프로필 클릭 &gt; Settings 메뉴 &gt; 오른쪽 사이드 바 &gt; SSH and GPG keys 메뉴 &gt; SSH keys      New SSH key 버튼을 클릭하면 아래와 같은 화면이 나온다.      Title 필드에 등록하려는 키의 이름(구분 값)을 입력한다. Key type은 Authentication Key를 사용하고 Key 필드에 생성했던 SSH 공개키를 입력한다.   이제 아래와 같이 공개키가 등록된 것을 확인할 수 있다.     ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/Git-Github-SSHKeys/",
        "teaser": ""
      },{
        "title": "빈 생명주기 콜백",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   빈 생명주기 콜백 시작   데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.   데이터베이스 커넥션에 대해 얘기한 이유는 빈 생명주기 콜백과 비슷하기 때문이다. 빈 생명주기 콜백도 시작과 안전한 종료를 위한 작업이 필요하다.   스프링 빈은 객체 생성 후에 의존관계 주입을 한다. (객체 생성이 미리 완료해야 의존관계를 주입할 수 있다. 단, 생성자 주입은 예외이다. 생성자는 객체를 만들때 이미 스프링 빈이 같이 들어와야 하기 때문이다.)   스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에 필요한 데이터를 사용할 수 있는 준비가 완료된다. 따라서, 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.   개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있나?   스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한, 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서, 안전하게 종료 작업을 진행할 수 있다.   스프링 빈의 이벤트 라이프사이클   1 스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링 종료      초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출   소멸전 콜백: 빈이 소멸되기 직전에 호출      참고 의존관계 주입은 수정자 주입, 필드 주입에서 발생한다. 생성자 주입은 객체가 생성되어야 하기 때문에 스프링 빈 생성 단계에서도 일부 시작된다.     생성자를 생성하는 것과 수정자 주입하는 것을 분리한 이유는 생성자에서 모두 처리하면 단일 책임 원칙(SRP)에 위배되기 때문이다.   1 2 3 4 5 6 // 기존 NetworkClient networkClient = new NetworkClient(); networkClient.setUrl(\"http://hello-spring.dev\");  // 생성자에 파라미터 전달: SRP 원칙 위배 NetworkClient networkClient = new NetworkClient(\"http://hello-spring.dev\");      참고 객체의 생성과 초기화를 분리하자 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에, 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다. 따라서, 이 두 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.        참고 강의에서 말하는 초기화란? 객체가 생성되어 사용되기 전에 진행되어야 할 일련의 과정들이다. 초기화는 ‘객체를 생성하는 작업이 아니고 객체안에 필요한 값이 다 연결되어있고 처음 제대로 일을 시작하는 것이다.’ 라고 볼 수 있다. 왜 번거롭게 객체를 생성할 때 초기화를 진행하지 않을까? 그 이유는 생성과 초기화를 서로 다른 관심사로 보고 각 과정을 분리했다고 이해하면 좋다. (SRP 원칙) 스프링 관점에서의 초기화는 객체 생성 및 의존관계 주입 이후 객체를 사용하기 위해 필요한 추가 작업이다.     1 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(LifeCycleConfig.class);   new AnnotationConfigApplicationContext(LifeCycleConfig.class);를 생성하는 동안 ‘컨테이너 생성, 스프링 빈 생성, 의존관계 주입, 초기화 콜백’까지 다 끝난 상태이다.   스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.      인터페이스(InitializingBean, DisposableBean)   설정 정보에 초기화 메서드, 종료 메서드 지정   @PostConstruct, @PreDestroy 애노테이션 지원   인터페이스 InitializingBean, DisposableBean   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.study.core.lifecycle;  import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean;  public class NetworkClient implements InitializingBean, DisposableBean {      ...      @Override     public void afterPropertiesSet() throws Exception {         System.out.println(\"NetworkClient.afterPropertiesSet\");         connect();         call(\"초기화 연결 메시지\");     }      @Override     public void destroy() throws Exception {         System.out.println(\"NetworkClient.destroy\");         disconnect();     } }   1 2 3 4 5 6 생성자 호출, url = null NetworkClient.afterPropertiesSet connect: http://hello-spring.dev call: http://hello-spring.devmessage = 초기화 연결 메시지 NetworkClient.destroy close http://hello-spring.dev      InitializingBean은 afterPropertiesSet() 메서드로 초기화를 지원함            afterPropertiesSet(): 의존관계 주입이 끝나면 호출           DisposableBean은 destory() 메서드로 소멸을 지원함            destroy(): 빈이 종료될 때 호출           초기화, 소멸 인터페이스 단점      이 인터페이스는 스프링 전용 인터페이스다. 해당 코드가 스프링 전용 인터페이스에 의존한다.   초기화, 소멸 메서드의 이름을 변경할 수 없다. (afterPropertiesSet(), destroy()로 고정된다.)   내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.   인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기(2003년)에 나온 방법들이고, 지금은 다음의 더 나은 방법들이 있어서 거의 사용하지 않는다.   빈 등록 초기화, 소멸 메서드 지정   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class NetworkClient {      ...      public void init() throws Exception {         System.out.println(\"NetworkClient.init\");         connect();         call(\"초기화 연결 메시지\");     }      public void close() throws Exception {         System.out.println(\"NetworkClient.close\");         disconnect();     } }   1 2 3 4 5 6 7 8 9 @Configuration static class LifeCycleConfig {     @Bean(initMethod = \"init\", destroyMethod = \"close\")     public NetworkClient networkClient() {         NetworkClient networkClient = new NetworkClient();         networkClient.setUrl(\"http://hello-spring.dev\");         return networkClient;     } }   설정 정보 사용 특징      메서드 이름을 자유롭게 줄 수 있다.   스프링 빈이 스프링 코드에 의존하지 않는다.   코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다. (가장 큰 장점)   종료 메서드 추론      @Bean의 destroyMethod 속성에는 특별한 기능이 있음   라이브러리는 대부분 close, shutdown 이라는 이름의 종료 메서드를 사용하는데 @Bean의 destoryMethod는 기본값이 inferred(추론)으로 등록되어 있다.   이 추론 기능은 close, shutdown라는 이름의 메서드를 자동으로 호출해준다. (즉, 종료 메서드를 추론해서 호출해준다.)   따라서, 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.   추론 기능을 사용하기 싫으면 destroyMethod=””처럼 빈 공백을 지정하면 된다. (굳이 그럴일은 없겠지..;;)   애노테이션 @PostConstruct, @PreDestroy   결론부터 얘기하면 이 방법을 쓰면 된다!   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package hello.core.lifecycle;  import javax.annotation.PostConstruct; import javax.annotation.PreDestroy;  public class NetworkClient {      ...      @PostConstruct     public void init() {         System.out.println(\"NetworkClient.init\");         connect();         call(\"초기화 연결 메시지\");     }      @PreDestroy     public void close() {         System.out.println(\"NetworkClient.close\");         disconnect();     } }   @PostConstruct , @PreDestroy 이 두 애노테이션을 사용하면 가장 편리하게 초기화와 종료를 실행할 수 있다.      참고 javax로 시작하는 애노테이션은 자바에서 공식적으로 제공하는 애노테이션이다. 따라서, 스프링이 아니고 다른 컨테이너를 쓴다고 해도 그대로 적용된다.     @PostConstruct, @PreDestroy 애노테이션 특징      최신 스프링에서 가장 권장하는 방법이다.   애노테이션 하나만 붙이면 되므로 매우 편리하다.   패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니고 자바 표준이다. 따라서, 스프링이 아닌 다른 컨테이너에서도 동작한다.   컴포넌트 스캔과 잘 어울린다.   유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 기능을 사용하자.   정리   기본적으로는 @PostConstruct, @PreDestroy 애노테이션을 사용하고 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean의 initMethod, destroyMethod를 사용한다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-BeanLifeCycle/",
        "teaser": ""
      },{
        "title": "TailwindCSS 설정",
        "excerpt":"tailwindCSS를 사용하기 위해서는 node를 먼저 설치해야 한다.   node 설치   node 버전은 14로 설치하였다.   1 brew install node@14   각자의 환경변수 설정 파일에 아래 코드를 입력하면 된다.   1 2 # 환경변수 설정하기 위해 zshrc 열기 vi ~/.zshrc   1 export PATH=\"/usr/local/opt/node@14/bin:$PATH\"   1 2 # 환경변수 적용 source ~/.zshrc   node를 설치하였다. node와 npm 버전을 확인하여 잘 설치되었는지 확인하자.   1 2 node -v npm -v   tailwindCSS 설치   이제 tailwindCSS를 설치할 건데 에러도 많이 나고 많은 시도 끝에 성공하였다.   여기서 gulp라는 것을 사용할 건데 scss 파일은 웹브라우저가 이해할 수 없는 언어라고 한다. 따라서, 컴파일을 통해 css 파일로 변경해줘야 하는데 이때 gulp를 사용한다.   프로젝트 경로로 가서 아래 명령어를 입력한다.   1 npm init -y   그 후 package.json, gulpfile.js, assets/scss/styles.scss, tailwind.config.js 파일을 수동으로 만들어주자.   package.json   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // devDependencies 버전을 주의하자 {   \"name\": \"haedal-css\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"scripts\": {     \"css\": \"gulp\"   },   \"devDependencies\": {     \"autoprefixer\": \"^9.8.8\",     \"gulp\": \"^4.0.2\",     \"gulp-concat\": \"^2.6.1\",     \"gulp-csso\": \"^4.0.1\",     \"gulp-postcss\": \"^9.0.0\",     \"gulp-sass\": \"^5.0.0\",     \"node-sass\": \"^4.14.0\",     \"postcss\": \"^8.4.14\",     \"sass\": \"^1.45.0\",     \"tailwindcss\": \"^2.2.19\"   } }      주의 node 버전에 따라 node-sass 버전이 달라지므로 아래 이미지를 참고하여 설치한다.          gulpfile.js   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const gulp = require('gulp')  const css = () =&gt; {     const postCSS = require('gulp-postcss')     const sass = require('gulp-sass')(require('sass'));     const minify = require('gulp-csso')     sass.compiler = require('node-sass')      return gulp         .src('assets/scss/styles.scss', {allowEmpty: true})         .pipe(sass().on('error', sass.logError))         .pipe(postCSS([             require('tailwindcss'),             require('autoprefixer')         ]))         .pipe(minify())         .pipe(gulp.dest('static/css')) };  exports.default = css   assets/scss/styles.scss   1 2 3 @tailwind base; @tailwind components; @tailwind utilities;   tailwind.config.js   1 2 3 4 5 6 7 module.exports = {   theme: {     extend: {}   },   variants: {},   plugins: [] }   이제 npm i를 통해 devDependencies로 설정한 라이브러리들을 설치한다. 만약, 이미 생성된 node_modules, package-lock.json 파일이 있다면 삭제하고 설치를 진행한다.   1 npm i   그러나, 오류가 발생했다…😢   1 2 3 4 5 6 7 8 9 10 11 12 13 gyp WARN install got an error, rolling back install gyp ERR! configure error  gyp ERR! stack Error: unable to get local issuer certificate gyp ERR! stack     at TLSSocket.onConnectSecure (_tls_wrap.js:1515:34) gyp ERR! stack     at TLSSocket.emit (events.js:400:28) gyp ERR! stack     at TLSSocket._finishInit (_tls_wrap.js:937:8) gyp ERR! stack     at TLSWrap.ssl.onhandshakedone (_tls_wrap.js:709:12) gyp ERR! System Darwin 22.1.0 gyp ERR! command \"/usr/local/Cellar/node@14/14.21.1/bin/node\" \"/usr/local/Cellar/node@14/14.21.1/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\" gyp ERR! cwd /Users/seungmi/dev/haedal/haedal-css/node_modules/fsevents gyp ERR! node -v v14.21.1 gyp ERR! node-gyp -v v5.1.0 gyp ERR! not ok   구글링을 통해 해결하였다. 아래 명령어들을 순서대로 입력하면 된다.   1 2 3 4 5 6 7 8 9 10 11 $ cd ~  $ echo quit | openssl s_client -showcerts -servername www.naver.com -connect www.naver.com:443 &gt; cacert.pem  $ npm config set cafile ~/cacert.pem --global  $ export NODE_EXTRA_CA_CERTS=~/cacert.pem  $ cd ~/workspace/myApp  $ npm i   이제 아래 명령어를 통해 컴파일 한다. 컴파일이 완료되면 static/css/styles.css 파일이 생성된다.   1 npm run css   이제 tailwindCSS를 사용할 준비가 완료되었다. css가 잘 적용되는지 아래 코드를 통해 확인해보자. 그림과 같이 나오면 잘 적용된 것이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;link href=\"./static/css/styles.css\" rel=\"stylesheet\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;div class=\"block m-4\"&gt;         &lt;button class=\"px-4 py-2 mr-2 text-white bg-red-500 rounded-3xl\"&gt;빨간색 버튼&lt;/button&gt;         &lt;button class=\"px-8 py-3 mr-2 font-semibold text-white bg-green-700\"&gt;녹색 버튼&lt;/button&gt;         &lt;button class=\"px-16 py-5 text-2xl text-white bg-black rounded-2xl\"&gt;검은색 버튼&lt;/button&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;     ","categories": ["TailwindCSS"],
        "tags": ["TailwindCSS","CSS"],
        "url": "/tailwindcss/TailwindCSS-settings/",
        "teaser": ""
      },{
        "title": "내부 클래스",
        "excerpt":"내부 클래스란?   내부 클래스는 클래스 내에 선언된 클래스다. 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.   내부 클래스의 장점      내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.   코드의 복잡성을 줄일 수 있다.   1 2 3 4 5 6 7 class A {     ... }  class B {     ... }   1 2 3 4 5 6 7 8 // 외부 클래스(outer class) class A { // B의 외부 클래스      // 내부 클래스(inner class)     class B { // A의 내부 클래스         ...     } }   내부 클래스의 종류와 특징   내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스는 마치 변수를 선언한 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스 변수, 클래스 변수, 지역 변수로 구분되는 것과 같이 내부 클래스도 선언위치에 따라 아래와 같이 구분된다.                  내부 클래스       특징                       인스턴스 클래스       외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스 멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.                 스태틱 클래스       외부 클래스의 멤버변수 선언위치에 선언하며 외부 클래스의 static 멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static 메서드에서 사용될 목적으로 선언된다.                 지역 클래스       외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                 익명 클래스       클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)           1 2 3 4 5 6 7 8 9 10 11 12 13 14  class A {      // 인스턴스 클래스     class InstanceInner {}      // 스태틱 클래스     static class StaticInner {}      void methodA() {         // 지역 클래스         class LocalInner {}     }     }      참고 내부 클래스의 선언과 변수의 선언     내부 클래스는 변수와 마찬가지로 선언된 위치에 따라 종류가 달라진다. 또한, 유효범위(scope)와 접근성(accessibility)도 변수와 동일하다.     1 2 3 4 5 6 7 8 9 // 변수 선언 위치에 따른 종류 class Outer {     int iv = 0; // 인스턴스 변수     static int cv = 0; // 클래스(스태틱) 변수      void myMethod() {         int lv = 0; // 지역변수     } }       내부 클래스의 제어자와 접근성   내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있을 뿐만 아니라, 멤버 변수들처럼 private, protected과 접근제어자도 사용이 가능하다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class InnerEx1 {     class InstanceInner {         int iv = 100;         //static int cv = 100; // 오류 발생         final static int CONST = 100;     }      static class StaticInner {         int iv = 200;         static int cv = 200;     }      void myMethod() {         class LocalInner {             int iv = 300;             //static int cv = 300; // 오류 발생             final static int CONST = 300;         }     }      public static void main(String args[]) {         System.out.println(InstanceInner.CONST);         System.out.println(StaticInner.cv);     } }   실행결과   1 2 100 200   내부 클래스 중에서 스태틱 클래스만 static 멤버를 가질 수 있다. 내부 클래스에 static 변수를 선언해야 한다면 스태틱 클래스로 선언해야 한다. 다만, final과 static이 동시에 붙은 변수는 상수이므로 모든 내부 클래스에서 정의가 가능하다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package hello.core;  class InnerEx2 {     class InstanceInner {     }      static class StaticInner {     }      // 인스턴스 멤버 간에는 서로 직접 접근가능     InstanceInner iv = new InstanceInner();      // static 멤버 간에는 서로 직접 접근가능     static StaticInner cv = new StaticInner();      static void staticMethod() {         // static 멤버는 인스턴스 멤버에 직접 접근 불가         //InstanceInner obj1 = new InstanceInner(); // 에러 발생         StaticInner obj2 = new StaticInner();          // 굳이 접근을 하려면 외부 클래스를 먼저 생성하고 인스턴스 클래스를 생성         InnerEx2 outer = new InnerEx2();         InstanceInner obj = outer.new InstanceInner();     }      void instanceMethod() {         // 인스턴스 메서드에서는 인스턴스 멤버와 static 멤버 모두 접근 가능         InstanceInner obj1 = new InstanceInner();         StaticInner obj2 = new StaticInner();          // 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근 불가         //LocalInner lv = new LocalInner(); // 에러 발생     }      void myMethod() {         class LocalInner {}          LocalInner lv = new LocalInner();     } }   인스턴스 클래스는 외부 클래스의 인스턴스 멤버를 객체 생성 없이 사용할 수 있지만, 스태틱 클래스는 외부 클래스의 인스턴스 멤버를 객체 생성 없이 사용할 수 없다. 마찬가지로 인스턴스 클래스는 스태틱 클래스의 멤버들을 객체 생성 없이 사용할 수 있지만, 스태틱 클래스에서는 인스턴스 클래스의 멤버들을 객체 생성 없이 사용할 수 없다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class InnerEx3 {     private int outerIv = 0;     static int outerCv = 0;      class InstanceInner {         int iiv = outerIv;         int icv = outerCv;     }      static class StaticInner {         //int siv = outerIv; // 에러 발생         int scv = outerCv;     }      void myMethod() {         int lv = 0;         final int LV = 0;          class LocalInner {             int liv = outerIv;             int lcv = outerCv;              int liv3 = lv; // JDK 1.8부터 에러 안남             int liv4 = LV;         }     } }   내부 클래스에서 외부 클래스의 변수들에 대한 접근성을 보여주는 예제이다. 인스턴스 클래스는 외부 클래스의 인스턴스 멤버이기 때문에 인스턴스 변수와 static 변수를 모두 사용할 수 있다.   스태틱 클래스는 외부 클래스의 static 멤버이기 때문에 인스턴스 멤버는 사용할 수 없다.   익명 클래스   익명 클래스(anonymous class)는 다른 내부 클래스와 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용할 수있고 오직 하나의 객체만 생성할 수 있는 일회용 클래스이다.   1 2 3 4 5 6 7 8 9 new 조상클래스이름() { \t// 멤버 선언 }  new 구현인터페이스이름() { \t// 멤버 선언 }  // new Object {}   이름이 없기 때문에 생성자도 가질 수 없고, 조상 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용하여 정의하기 때문에 하나의 클래스를 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스를 구현해야만 한다.   익명 클래스는 구문이 다소 생소하지만, 인스턴스 클래스를 익명 클래스로 바꾸는 연습을 몇 번만 하면 곧 익숙해질 것이다.   아래 예제는 익명클래스의 사용 예이다.   1 2 3 4 5 6 7 8 class InnerEx4 {     Object iv = new Object() { void method() {} };     static Object cv = new Object() { void method() {} };      void method() {         Object lv = new Object() { void method() {} };     } }   위 코드를 컴파일하면 4개의 클래스파일이 생성된다.   1 2 3 4 InnerEx4.class InnerEx4$1.class &lt;- 익명 클래스 InnerEx4$2.class &lt;- 익명 클래스 InnerEx4$3.class &lt;- 익명 클래스   익명 클래스는 이름이 없기 때문에 외부 클래스명$숫자.class의 형식으로 클래스 파일명이 결정된다.   익명 클래스 적용 전   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package hello.core;  import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  class InnerEx5 {     public static void main(String[] args) {         Button b = new Button(\"Start\");         b.addActionListener(new EventHandler());     } }  class EventHandler implements ActionListener {     public void actionPerformed(ActionEvent e) {         System.out.println(\"ActionEvent occurred!!!\");     } }   익명 클래스 적용 후   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package hello.core;  import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  public class InnerEx6 {     public static void main(String[] args) {         Button b = new Button(\"Start\");         b.addActionListener(new ActionListener() {             public void actionPerformed(ActionEvent e) {                 System.out.println(\"ActionEvent occurred!!!\");             }         });     } }   InnerEx5를 익명 클래스를 이용해 변경한 것이 InnerEx6이다. 먼저 두 개의 독립된 클래스를 작성한 후 다시 익명 클래스를 이용하여 변경하면 보다 쉽게 코드를 작성할 수 있다.  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-InnerClass/",
        "teaser": ""
      },{
        "title": "지네릭스(Generics)",
        "excerpt":"지네릭스(Generics)   지네릭스는 컴파일 시 타입을 체크해주는 기능을 하며 객체의 타입 안정성을 높이고 형변환의 번거로운을 줄여준다.   컴파일 체크   컴파일 시 타입을 체크해주는 기능 (compile-time type check) - JDK 1.5   지네릭스 적용 전   1 2 3 4 ArrayList tvList = new ArrayList();  tvList.add(new Tv()); // OK tvList.add(new Audio()); // OK   ArrayList는 Object 배열을 가지고 있으므로 모든 종류의 객체를 저장할 수 있다. 따라서, Tv 타입만 저장하고 싶어도 tvList.add(new Audio());처럼 다른 타입을 저장해도 오류가 발생하지 않았다.   지네릭스 적용 후   1 2 3 4 ArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  tvList.add(new Tv()); // OK tvList.add(new Audio()); // 컴파일 에러. Tv 외에 다른 타입은 저장 불가   하지만, 지네릭스가 도입되면서 타입(Tv)을 지정해주고 객체를 생성하면 해당 타입을 제외한 다른 타입을 사용하면 오류가 발생하게 된다. 즉, 컴파일러가 타입을 체크해준다.   형변환 체크   객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여준다.   지네릭스 사용 전   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class GenericTest {      public static void main(String[] args) {         // JDK 1.5 이후         ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); // 아래와 같은 코드이다.  //        ArrayList list = new ArrayList(); // JDK 1.5 이전, 위에처럼 쓴다고 에러가 발생하는 것은 아니지만 이렇게 쓰는게 좋다.          list.add(10);         list.add(20);         list.add(\"30\");          Integer i = (Integer) list.get(2); // 컴파일 OK, 실제 실행 시 형변환 에러(ClassCastException)가 발생한다.         System.out.println(\"list = \" + list);     } }   ArrayList가 Object 타입이므로 형변환을 해줘야하는 번거로움이 있다. 형변환 에러는 실행 시 발생하는 에러이다. 실행 시 발생하는 에러보다 컴파일 에러가 좋은 에러이다.   지네릭스 사용 후   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class GenericTest {      public static void main(String[] args) {         ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();         list.add(10);         list.add(20); //        list.add(\"30\"); // 지네릭스 덕분에 타입체크가 강화되어 컴파일 에러가 발생함         list.add(30);  //        Integer i = (Integer) list.get(2);         Integer i = list.get(2); // 형변환 생략 가능         System.out.println(\"list = \" + list);     } }   지네릭스 덕분에 타입체크가 강화되어 컴파일 에러가 발생한다. 따라서, 개발자는 코드를 잘못 작성한 것을 바로 알 수 있다. 또한, 이미 타입을 알고 있기 때문에 형변환을 생략할 수 있다.      참고 형변환 에러(ClassCastException)는 RuntimeException이다. RuntimeException은 실행 중 발생하는 에러이다. 실행 중 에러가 발생하는 것보다 컴파일 에러가 좋은 에러이다.     정리하자면, 지네릭스를 사용하면 런타임 에러를 컴파일 에러로 끌어오기 때문에 좋은 코드를 작성하는데 있어 더 적합하다.   타입 변수   일반 클래스에선 Object 타입을 사용하지만, 지네릭 클래스를 작성할 때는 Object 타입 대신 타입 변수(E)를 선언해서 사용한다. 일반 클래스(Object 타입 사용)에서 지네릭 클래스(타입 변수 E)로 변경되었다. (JDK 1.5부터 변경)   지네릭 클래스는 타입 변수 E를 선언한다.   1 2 3 4 5 6 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; {     private transient E[] elementData;     public boolean add(E o) {}     public E get(int index) {}     ... }   타입 변수에 대입하기   객체를 생성 시, 타입 변수(E) 대신 실제 타입(Tv)을 지정(대입)한다. 참조변수와 생성자에 넣어주며 타입이 일치 해야 한다.   1 2 // 타입 변수 E 대신에 실제 타입 Tv를 대입 ArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();   E(타입 변수) 에서 Tv(실제 타입)로 변경하면 아래와 같은 코드가 된다. (Tv가 E에 대입됨)   1 2 3 4 5 6 public class ArrayList&lt;Tv&gt; extends AbstractList&lt;Tv&gt; {     private transient Tv[] elementData;     public boolean add(Tv o) {}     public Tv get(int index) {}     ... }   타입 변수 대신 실제 타입(여기선 Tv)이 지정되면, 형변환 생략이 가능하다.   1 2 3 4 5 ArrayList tvList = new ArrayList();  tvList.add(new Tv()); Tv t = (Tv)tvList.get(0); // 참조변수는 Tv, tvList.get(0)는 Object이므로 타입 불일치. 따라서, 형변환이 필요   1 2 3 4 ArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  tvList.add(new Tv()); Tv t = tvList.get(0); // 형변환 불필요   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Tv { }  class Audio { }  public class GenericTest {      public static void main(String[] args) {         /*ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();         list.add(new Tv());         list.add(new Audio());         Tv t = (Tv) list.get(0); // 형변환 해주어야 한다.*/          ArrayList&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;(); // Tv 타입의 객체만 저장 가능         list.add(new Tv()); //        list.add(new Audio()); // 에러 발생          Tv t = list.get(0); // 형변환 불필요     } }   지네릭스 용어      Box: `지네릭 클래스`. T의 Box 또는 T Box라고 읽는다.   T: 타입 변수 또는 타입 매개변수(T는 타입 문자)   Box: 원시 타입(raw type) 일반클래스   1 2 class Box&lt;T&gt; {} Box&lt;String&gt; b = new Box&lt;String&gt;(); // 생성할 때마다 다른 타입을 넣어줄 수 있다.   지네릭 타입과 다형성   참조 변수와 생성자의 대입된 타입은 일치해야 한다.   1 2 ArrayList&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;(); // OK. 일치 ArrayList&lt;Product&gt; list = new ArrayList&lt;Tv&gt;(); // 에러. 불일치   지네릭 클래스간의 다형성은 성립한다. (여전히 대입된 타입은 일치해야 함)   1 2 List&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;(); // OK. 다형성 ArrayList가 List를 구현 List&lt;Tv&gt; list = new LinkedList&lt;Tv&gt;(); // OK. 다형성 LinkedList가 List를 구현   매개변수의 다형성도 성립한다.   1 2 3 4 5 6 7 8 class Product {} class Tv extends Product {} class Audio extends Product {}  ArrayList&lt;Product&gt; list = new ArrayList&lt;Product&gt;(); list.add(new Product()); list.add(new Tv()); // Tv는 Product의 자손. OK list.add(new Audio()); // Tv는 Product의 자손. OK   지네릭스 클래스. 다형성에 대한 예제 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Product {} class Tv extends Product {} class Audio extends Product {}  public class Ex12_1 {     public static void main(String[] args) {         ArrayList&lt;Product&gt; productList = new ArrayList&lt;Product&gt;();         ArrayList&lt;Tv&gt; tvList1 = new ArrayList&lt;Tv&gt;(); //        ArrayList&lt;Product&gt; tvList2 = new ArrayList&lt;Tv&gt;(); // 에러 //        List&lt;Tv&gt; tvList3 = new ArrayList&lt;Tv&gt;(); // OK. 다형성          productList.add(new Tv()); // public boolean add(Product e) {} : Product와 그 자손은 다 OK. 이것이 다형성         productList.add(new Audio()); // OK.          tvList1.add(new Tv()); // public boolean add(Tv e) {} : Tv 또는 그 자손 객체만 OK. //        tvList1.add(new Audio()); // 에러          printAll(productList); //        printAll(tvList1); // 컴파일 에러가 발생     }      private static void printAll(ArrayList&lt;Product&gt; list) {         for (Product p : list) {             System.out.println(\"p = \" + p);         }     } }  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "/java/Java-Generic/",
        "teaser": ""
      },{
        "title": "빈 스코프",
        "excerpt":"목차      좋은 객체 지향 설계의 원칙: SOLID   DIP, OCP와 의존관계 주입(DI)   IoC와 DI   스프링 컨테이너와 스프링 빈   싱글톤 컨테이너   컴포넌트 스캔   의존관계 주입 방법   빈 생명주기 콜백   빈 스코프   빈 스코프란?   스프링 빈은 스프링 컨테이너의 시작과 함께 생성되고 스프링 컨테이너가 종료될 때 까지 유지된다. 이것은 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문이다. 스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다.   스프링은 다양한 스코프를 지원한다.      싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.   프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.   웹 관련 스코프            request: 웹 요청이 들어오고 나갈때까지 유지되는 스코프       session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프       application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프           빈 스코프 지정 방법   컴포넌트 스캔 자동 등록   1 2 3 @Scope(\"prototype\") @Component public class HelloBean {}   수동 등록   1 2 3 @Scope(\"prototype\") @Bean public class HelloBean {}   지금까지 사용한 것은 싱글톤 스코프이다. 이제부터 프로토타입 스코프를 확인해보자.      참고   이전에 사용했던 예제들은 모두 싱글톤 빈이었기 때문에 new AnnotationConfigApplicationContext()로 스프링 컨테이너를 생성할 때, 컴포넌트 스캔으로 빈이 자동 등록되는 과정에서 스프링 빈 객체도 모두 생성되었다.     프로토타입 스코프   싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다. 반면, 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.   싱글톤 스코프와 프로토타입 스코프의 차이         프로토타입 빈 요청 과정      프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.   스프링 컨테이너는 요청하는 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.   스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.   이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.   정리   여기서 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 @PreDestory 같은 종료 메서드가 호출되지 않는다.   프로토타입 빈의 특징      스프링 컨테이너에 요청할 때 마다 새로 생성된다.   스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.   종료 메서드가 호출되지 않는다.   그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.      참고 프로토타입 빈은 언제 사용될까?   요청할 때마다 객체를 항상 새로 생성해야 하는데, 의존관계 주입이 필요하다면 이때 프로토타입 빈을 사용한다. 하지만 실무에서 프로토타입 빈을 잘 활용하진 않는다.        참고   빈 등록과 빈 생성 같은 의미이다.        참고   싱글톤 스코프를 가진 스프링 빈은 생성되면 스프링 컨테이너에 저장되어 관리된다. 반면, 프로토타입 스코프를 가진 스프링 빈을 생성하게 되면 생성은 컨테이너에서 해주지만 관리는 컨테이너에서 하지 않는다. 따라서, getBean()으로 프로토타입 빈을 조회하게 되면 생성한 프로토타입 빈의 참조값을 반환한다.        참고   프로토타입 스코프의 경우 컨테이너를 생성할 때 넘겨준 클래스 정보(PrototypeConfig.class)를 바탕으로 빈 메타데이터를 생성하고 등록까지 진행한다. (메타데이터를 생성하는 것이지 실제 빈이 생성되는 것이 아니다) 빈 조회가 발생해야 프로토타입 빈이 생성되고 그에 관련된 의존관계가 주입된다.     프로토타입 스코프와 싱글톤 빈   프로토타입 스코프와 싱글톤 빈과 함께 사용시 문제점   스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다. 하지만 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의해야 한다.   스프링 컨테이너에 프로토타입 빈 직접 요청      클라이언트 A는 스프링 컨테이너에 프로토타입 빈을 요청한다.   스프링 컨테이너는 프로토타입 빈을 새로 생성하여 반환한다. (프로토타입에 count라는 필드가 있다면 그 값의 초기값은 0이다.)   클라이언트는 조회한 프로토타입 빈에 addCount()를 호출하면서 count 필드를 +1 하면 프로토타입 빈의 count는 1이 된다.   클라이언트 B가 스프링 컨테이너에 프로토타입 빈을 요청하고 마찬가지로 count 필드가 있다. 클라이언트가 addCount()를 호출하면 이 값 역시 1이 된다.   결론: 프로토타입 빈은 요청할 때마다 새로 생성된다.      싱글톤 빈에서 프로토타입 빈 사용   문제는 싱글톤 빈에서 프로토타입을 사용할 때 발생한다.   가정 ClientBean이라는 싱글톤 빈이 있다. ClientBean은 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용한다.      clientBean은 싱글톤이므로 스프링 컨테이너 생성 시점에 함께 생성되고 의존관계 주입도 발생한다.   clientBean은 의존관계 자동 주입을 사용하고 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청한다.   스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean에 반환하며 프로토타입 빈의 count 값은 0이다.   이제 clientBean은 프로토타입 빈을 내부 필드에 보관한다. (정확히는 참조값을 보관함)   클라이언트 A는 clientBean을 스프링 컨테이너에 요청해서 받고 싱글톤이므로 항상 같은 clientBean이 반환된다.   클라이언트 A는 프로토타입의 addCount()를 호출하며 count 값은 1이 된다.   클라이언트 A는 clientBean을 스프링 컨테이너에 요청해서 받고 클라이언트 A에서 사용한 것과 같은 clientBean이 반환된다.   클라이언트 B는 프로토타입의 addCount()를 호출하며 count 값은 2가 된다.   결론: 프로토타입 빈은 clientBean 생성 시점에 생성되고 의존관계 주입이 이루어졌기 때문에 프로토타입 빈을 싱글톤에서 관리한다.   스프링은 일반적으로 싱글톤 빈을 사용하므로 싱글톤 빈이 프로토타입 빈을 사용하게 된다. 그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받으므로 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다. 즉, 프로토타입 빈의 목적에 맞게 사용하지 못하게 된다. 사실상 프로토타입 빈이 싱글톤처럼 동작하고 있기 때문에 동시성 문제가 발생한다.   프로토타입 빈은 그 목적에 맞게 프로토타입 빈을 주입 시점에만 새로 생성하는 것이 아닌 사용할 때마다 새로 생성해서 사용하는 것을 원할 것이다.      참고   싱글톤 객체가 프로토타입 스코프 객체를 들고 있어 생기는 문제는 싱글톤 객체의 특성 때문에 발생하는 문제이다.     그렇다면 싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 항상 새로운 프로토타입 빈을 생성하는 방법이 뭘까?      스프링 컨테이너에 요청   ObjectFactory, ObjectProvider 사용   JSR-330 Provider   해결1. 스프링 컨테이너에 요청   가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는 것이다.      실행해보면 ac.getBean()을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.   의존관계를 외부에서 주입(DI) 받는게 아니라 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색) 이라 한다.   그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고 단위테스트도 어려워진다.   지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 DL 정도의 기능만 제공하는 무언가가 있으면 된다.      참고 DL(Dependency Lookup)   DL은 의존성 검색이다. 빈에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lookup하는 것이다. 예를 들어 프로토타입 스코프의 빈을 이용해야 하는 경우가 대표적이다.     해결2. ObjectFactory, ObjectProvider   지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 ObjectProvider이다. ObjectFactory에 편의 기능을 추가한 것이 ObjectProvider이다.   1 2 3 4 5 6 7 8 9 10 // 테스트니까 간편하게 필드주입 사용 @Autowired private ObjectProvider&lt;PrototypeBean&gt; prototypeBeanProvider;  public int logic() {     PrototypeBean prototypeBean = prototypeBeanProvider.getObject();     prototypeBean.addCount();     int count = prototypeBean.getCount();     return count; }      prototypeBeanProvider.getObject()를 통해 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.   ObjectProvider의 getObject()를 호출하면 그 시점에 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)   스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.   ObjectProvider는 DL 정도의 기능만 제공한다.   특징      ObjectFactory: 기능이 단순, 별도의 라이브러리 필요 없으며 스프링에 의존한다.   ObjectProvider: ObjectFactory 상속, 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리 필요 없으며 스프링에 의존한다.   해결3. JSR-330 Provider   마지막 방법은 javax.inject.Provider라는 JSR-330 자바 표준을 사용하는 방법이다.   build.gradle에 추가   1 implementation 'javax.inject:javax.inject:1'   1 2 3 4 5 6 7 8 9 @Autowired private Provider&lt;PrototypeBean&gt; provider;  public int logic() {     PrototypeBean prototypeBean = provider.get();     prototypeBean.addCount();     int count = prototypeBean.getCount();     return count; }      실행해보면 provider.get()을 통해 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.   provider의 get()을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)   자바 표준, 기능이 단순하여 단위테스트를 작성하거나 mock 코드를 만들기 쉽다.   Provider는 DL 정도의 기능만 제공한다.   특징      get() 메서드 하나로 기능이 매우 단순하다.   별도의 라이브러리가 필요하다.   자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.   정리      그러면 프로토타입 빈을 언제 사용할까? 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 그런데 실무에서 웹 애플리케이션을 개발해보면, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.   ObjectProvider, JSR330 Provider 등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용할 수 있다.      참고   스프링이 제공하는 메서드에 @Lookup 애노테이션을 사용하는 방법도 있지만, 이전 방법들로 충분하기 때문에 생략하겠다.        참고   스프링을 사용하다 보면 자바 표준(JSR-330 Provier)과 스프링이 제공(ObjectProvider)하는 기능이 겹칠때가 많이 있다. 대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다.     웹 스코프   웹 스코프에 대해 알아보자.   웹 스코프의 특징      웹 스코프는 웹 환경에서만 동작한다.   웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서, 종료 메서드가 호출된다.   웹 스코프 종류      request: HTTP 요청하나가 들어오고 나갈때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.   session: HTTP Session과 동일한 생명주기를 가지는 스코프   application: 서플릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프   websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프   여기서는 request 스코프를 예제로 설명하겠다. 나머지도 범위만 다르지 동작 방식은 비슷하다.   request 스코프 예제 만들기   웹 스코프는 웹 환경에서만 동작하므로 web 환경이 동작하도록 라이브러리를 추가하자.   build.gradle에 추가   1 implementation 'org.springframework.boot:spring-boot-starter-web'      참고   spring-boot-starter-web 라이브러리를 추가하면 스프링 부트는 내장 톰켓 서버를 활용해서 웹 서버와 스프링을 함께 실행시킨다.        참고   스프링 부트는 웹 라이브러리가 없으면 AnnotationConfigApplicationContext을 기반으로 애플리케이션을 구동한다. 웹 라이브러리가 추가되면 웹과 관련된 추가 설정과 환경들이 필요하므로 AnnotationConfigServletWebServerApplicationContext를 기반으로 애플리케이션을 구동한다.     request 스코프 예제 개발   동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다. 이럴때 사용하는 것이 request 스코프이다.   기능정의 다음과 같이 로그가 남도록 request 스코프를 활용해서 추가 기능을  개발한다.   1 2 3 4 [d06b992f...] request scope bean create [d06b992f...][http://localhost:8080/log-demo] controller test [d06b992f...][http://localhost:8080/log-demo] service id = testId [d06b992f...] request scope bean close      기대하는 공통 포멧: [UUID][requestURL] {message}   UUID를 사용해서 HTTP 요청을 구분하자.   requestURL 정보도 추가로 넣어서 어떤 URL을 요청해서 남은 로그인지 확인하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Component @Scope(value = \"request\") public class MyLogger {      private String uuid;     private String requestURL;      public void setRequestURL(String requestURL) {         this.requestURL = requestURL;     }      public void log(String message) {         System.out.println(\"[\" + uuid + \"]\" + \"[\" + requestURL + \"]\" + message);     }      @PostConstruct     public void init() {         uuid = UUID.randomUUID().toString();         System.out.println(\"[\" + uuid + \"] request scope bean create:\" + this);     }      @PreDestroy     public void close() {         System.out.println(\"[\" + uuid + \"] request scope bean close:\" + this);     } }      로그를 출력하기 위한 MyLogger 클래스이다.   @Scope(value = “request”)를 사용해서 request 스코프로 지정했다. 이제 이 빈은 HTTP 요청 당 하나씩 생성되고, HTTP 요청이 끝나는 시점에 소멸된다.   이 빈이 생성되는 시점에 자동으로 @PostConstruct 초기화 메서드를 사용해서 uuid를 생성해서 저장해둔다. 이 빈은 HTTP 요청 당 하나씩 생성되므로 uuid를 저장해두면 다른 HTTP 요청과 구분할 수 있다.   이 빈이 소멸되는 시점에 @PreDestroy를 사용해서 종료 메시지를 남긴다.   requestURL은 이 빈이 생성되는 시점에는 알 수 없으므로, 외부에서 setter로 입력 받는다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Controller @RequiredArgsConstructor public class LogDemoController {      private final LogDemoService logDemoService;     private final MyLogger myLogger;      @RequestMapping(\"log-demo\")     @ResponseBody     public String logDemo(HttpServletRequest request) {         String requestURL = request.getRequestURL().toString();         myLogger.setRequestURL(requestURL);          myLogger.log(\"controller test\");         logDemoService.logic(\"testId\");         return \"OK\";     } }      로거가 잘 작동하는지 확인하는 테스트용 컨트롤러다.      참고   requestURL을 MyLogger에 저장하는 부분은 컨트롤러 보다는 공통 처리가 가능한 스프링 인터셉터나 서블릿 필터 같은 곳을 활용하는 것이 좋다. (예제에서는 단순화하기 위해 컨트롤러 사용함)     1 2 3 4 5 6 7 8 9 10 @Service @RequiredArgsConstructor public class LogDemoService {      private final MyLogger myLogger;      public void logic(String id) {         myLogger.log(\"service id = \" + id);     } }      비즈니스 로직이 있는 서비스 계층에서도 로그를 출력해보자.   request scope를 사용하지 않고 파라미터로 이 모든 정보를 서비스 계층에 넘긴다면 파라미터가 많아서 지저분해진다. 더 문제는 requestURL 같은 웹과 관련된 정보가 웹과 관련없는 서비스 계층까지 넘어가게 된다. 웹과 관련된 부분은 컨트롤러까지만 사용해야 한다. 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.   request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고 MyLogger의 멤버변수에 저장해서 코드와 계층을 깔끔하게 유지할 수 있다.   이제 실행하면 잘 될 것 같지만 기대와는 다르게 실행 시점에 오류가 발생한다.   스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있다.   해결1. 스코프와 Provider   위에서 발생한 문제를 해결할 수 있는 방법 중 첫번째는 ObjectProvider를 사용하는 것이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Controller @RequiredArgsConstructor public class LogDemoController {      private final LogDemoService logDemoService;     private final ObjectProvider&lt;MyLogger&gt; myLoggerProvider;      @RequestMapping(\"log-demo\")     @ResponseBody     public String logDemo(HttpServletRequest request) throws InterruptedException {         String requestURL = request.getRequestURL().toString();         MyLogger myLogger = myLoggerProvider.getObject();         myLogger.setRequestURL(requestURL);          myLogger.log(\"controller test\");         Thread.sleep(1000);         logDemoService.logic(\"testId\");         return \"OK\";     } }   1 2 3 4 5 6 7 8 9 10 11 @Service @RequiredArgsConstructor public class LogDemoService {      private final ObjectProvider&lt;MyLogger&gt; myLoggerProvider;      public void logic(String id) {         MyLogger myLogger = myLoggerProvider.getObject();         myLogger.log(\"service id = \" + id);     } }      ObjectProvider 덕분에 ObjectProvider.getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.   ObjectProvider.getObject()를 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.   ObjectProvider.getObject()를 LogDemoController, LogDemoService에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다.   여기서 더 코드를 줄일 수 있는 방법이 프록시를 사용하는 것이다.   해결2. 스코프와 프록시   프록시 방법을 알아보자.   1 2 3 @Component @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS) public class MyLogger { ... }      proxyMode = ScopedProxyMode.TARGET_CLASS가 핵심이다.            적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS를 사용       적용 대상이 인터페이스면 INTERFACES 사용           이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.   이제 나머지 코드를 Provider 사용 이전으로 돌려둔다. 실행해보면 잘 동작한다.   웹 스코프와 프록시 동작 원리   먼저 주입된 myLogger를 확인해보자   1 System.out.println(\"myLogger = \" + myLogger.getClass());   출력결과   1 myLogger = class hello.core.common.MyLogger$$EnhancerBySpringCGLIB$$4bb1c28b   CGLIB라는 라이브러리로 내 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입한다.      @Scope의 proxyMode = ScopedProxyMode.TARGET_CLASS를 설정하면 스프링 컨테이너는 CGLIB라는 바이트코드를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를 생성한다.   결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아니라 MyLogger$$EnhancerBySpringCGLIB이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다.   그리고 스프링 컨테이너에 myLogger라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.   ac.getBean(”myLogger”, MyLogger.class)로 조회해도 프록시 객체가 조회되는 것을 확인할 수 있다.   그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다.      가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.      이 가짜 프록시 빈은 내부에 실제 MyLogger를 찾는 방법을 알고 있다.   클라이언트가 myLogger.logic()을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다.   가짜 프록시 객체는 request 스코프의 진짜 myLogger.logic()를 호출한다.   가짜 프록시 객체는 원본 클래스를 상속받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다 (다형성)   동작 정리      CGLIB라는 라이브러리로 내 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입한다.   이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.   가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.   특징 정리      프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다.   사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.   단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.   꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.   주의점      마치 싱글톤처럼 사용하는 것 같지만 다르게 동작하기 때문에 주의해서 사용해야 한다.   이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자. 무분별하게 사용하면 유지보수하기 어려워진다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-BeanScope/",
        "teaser": ""
      },{
        "title": "프로세스와 스레드",
        "excerpt":"들어가기 전에   키워드           실행 단위: cpu core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념       → 실행단위는 프로세스와 스레드 모두를 포괄한 개념이다. 따라서, 실행단위라고 했을 때 프로세스일 수도 있고 스레드일 수도 있다.            (부연 설명이 없는) 프로세스: 하나의 스레드만 가지고 있는 단일 스레드 프로세스       → 프로세스와 스레드가 완전히 다른 무언가가 아니다.            동시성: 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보이는 것이다.       프로그램과 프로세스      프로그램: 코드 파일, 프로그램: 실행시키기 전에는 코드가 구현되어 있는 파일일 뿐이다.   프로세스: 프로그램이 실행 되어서 사용할 수 있는 무언가가 되는데 그게 프로세스이다.   미리 알면 좋은 Process 지식   프로그램이 프로세스가 되면서 2가지 일이 일어난다.   일단 프로세스가 필요로 하는 재료들이 메모리에 올라간다. 메모리 영역은 4가지 영역(Code, Data, Heap, Stack)이 있다.      Code: 실행 명령을 포함하는 코드들   Data: Static 변수 혹은 Global 변수   Head: 동적 메모리 영역   Stack: 지역변수, 매개변수, 반환 값 등등 일시적인 데이터   두번째로 해당 프로세스에 대한 정보를 담고 있는 PCB(Process Control Block) 블럭이 프로세스 생성 시 만들어진다.      Pointer: 프로세스 상태 중에 준비 상태나 대시 상태의 큐를 구현하기 위한 포인터   Process State: 현재 프로세스 상태를 담는다.   Process Number(ID): 고유 번호를 담는 PID   Program Counter: 다음 명령어를 가리키는 프로그램 카운터   등등이 있다.      Process &amp; Thread   프로세스   개발자는 코딩을 하기 전에 유튜브에서 ‘이노래 뭐지’ 팝송 플레이리스트를 튼다. 그 후 코딩을 하기 위해 Intellij를 연다. 중요한 알람이 올 수 있으므로 slack을 켠다. 그리고 개발 필수템인 크롬을 킨다. 이렇게 대부분의 사람들은 하나의 프로세스를 사용하기 보다 여러가지를 동시에 사용한다.   하지만 원래 하나의 프로세스가 실행되기 위해서 CPU를 점유하고 있으면 다른 프로세스는 실행 상태에 있을 수 없다. 노래를 듣다가 코딩을 하기 위해 Intellij를 키면 노래가 꺼지게 된다. 즉, 여러 프로세스가 동시에 실행되고 관리되는 것처럼 보이지만 실제론 여러개의 프로세스를 시분할, 즉 짧은 텀을 반복하면서 전환해서 실행 시키는 것이다.   동시에 실행시키고 싶은 프로세스 A와 B가 있다고 가정하자. A를 실행시키기 위해 실행 상태로 전환하고 CPU에 적재된다. B는 준비상태에 있다. 이제 B를 실행시키기 위해서는 A를 먼저 준비상태로 전환하고 B가 CPU에 적재 되어야 한다. 이 과정을 반복하게 될때 발생하는 것이 컨텍스트 스위칭이다.      컨텍스트 스위칭은 매우 번거로운 작업이다. 이 부분을 개선하기 위해 등장한 것이 경량화된 프로세스 버전인 스레드이다.      참고 컨텍스트 스위칭 컨텍스트 스위칭이란 CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 말한다.     스레드   스레드를 경량화된 프로세스라고 부르는 이유는 하나의 프로세스 안에 다수의 스레드가 있을 때 공유되는 자원이 있기 때문이다. 프로세스의 메모리 구조 중 Stack을 제외한 나머지 Code, Data, Heap을 모두 공유한다. 공유되는 자원이 있기 때문에 이전 처럼 컨텍스트 스위칭이 일어날 때 캐싱 적중률이 올라간다.      프로세스와 스레드 예   예를 들어 공용 회의실이 있고 그 안에는 티비, 스피커, 리모컨이 있다고 가정하자. A팀이 먼저 회의실을 예약하여 사용했다. 이때 프로세스라면 A팀이 회의를 마치고 티비, 스피커, 리모컨을 가지고 나간다. 그 다음 팀인 B팀이 회의실을 사용하려면 티비, 스피커, 리모컨을 가지고 와야 회의실을 이용할 수 있다. 그러나, 스레드를 사용하면 공용자원인 티비, 스피커, 리모컨은 그대로 두고 자신들의 개인 노트북만 가지고 와서 연결하여 사용하면 된다.   Multi-process vs Multi-thread   멀티 프로세스와 멀티 스레드는 두가지 개념이 모두 처리 방식의 일종이다. 한 어플리케이션에 대한 처리 방식이라고 생각하면 편하다.   한 어플리케이션이 여러가지 일을 처리할 때가 있다. 예를 들어 여러 사용자가 로그인을 요청하는 상황이 있다고 가정한다. 한 프로세스는 매번 하나의 로그인을 처리하기 때문에 동시에 처리할 수가 없다. 그래서 부모 프로세스가 fork()해서 자식 프로세스를 만들어서 일을 처리한다. 이때 자식 프로세스는 부모와 별개의 메모리 영역을 확보하게 된다.   반면, 스레드는 한 프로세스 내에서 구분이 지어진 실행 단위이다. 한 어플리케이션에 대한 작업의 단위가 나눠질 때가 많다. (Intellij를 사용하는데 테스트도 실행하면서 동시에 코드를 수정하는 경우) 이때 각각의 스레드가 그 작업들을 담당한다.   차이점   멀티 프로세스는 각 프로세스에 독립적이므로 IPC를 사용해 통신해야 한다. 자원 소모적이며 개별 메모리 차지한다. 따라서, 컨텍스트 스위칭 비용이 크다. 하지만 독립적으로 존재하기 때문에 동기화 작업이 필요없다.   반면, 멀티 스레드는 스레드끼리 긴밀하게 연결되어 있다. 따라서, 공유된 자원으로 통신 비용이 절감되고 메모리를 효율적으로 사용할 수 있어 컨텍스트 스위칭 비용이 적다. 단, 공유 자원 관리를 해야한다. (동기화 작업)      이렇게 보면 멀티 프로세스보다 멀티 스레드가 훨씬 좋아보이는데 왜 멀티 프로세스를 이용할까?   그 이유에 대한 예시는 크롬과 IE를 얘기할 수 있다.   크롬은 멀티 프로세스 사용, IE는 멀티 스레드 사용한다.   IE를 사용하면서 다수의 탭을 사용하고 있다가 경고 메시지가 나오며 창 전체가 꺼지는 경험을 한적이 있을 것이다. 멀티 스레드를 이용했기 때문에 발생하는 문제이다. 긴밀하게 연결되어 있기 때문에 한 스레드(1개의 탭)에 문제가 생기면 전체 프로세스에 영향이 있다. 반면, 구글 크롬은 다소 비효율적인 부분이 있을 수 있지만 멀티 프로세스를 사용하기 때문에 멀티탭 간에 영향을 덜 받는다.   Multi-core   멀티 프로세스와 멀티 스레드는 처리방식의 일종이기 때문에 소프트웨어 분야에 가깝고 멀티 코어는 하드웨어 측면에 가깝다. 멀티 코어와 관련된 키워드는 동시성과 병렬처리이다.   동시성이란 하나의 코어에서 하나 이상의 프로세스(혹은 스레드)가 번갈아가면서 진행되지만 동시에 진행되는 것처럼 보이는 것이다. (동시성은 짧은 순간에 CPU의 시간을 분할해서 동시에 하는 것처럼 보이게 한다.)   하지만 멀티코어는 병렬처리 즉, 물리적으로 여러 코어를 사용해서 다수의 실행 단위를 한 순간에 동시에 처리할 수 있게 해준다. (병렬처리란 둘 이상의 코어에서 동시에 하나 이상의 프로세스(혹은 스레드)가 한꺼번에 진행되는 것)      참고 리눅스에서 프로세스와 스레드     리눅스 커널에서는 프로세스와 스레드를 동일하게 본다.     스레드는 사용자 스레드와 커널 스레드로 나뉜다. 이름에서 알 수 있듯이 각 스레드를 담당하는 레벨이 하나는 사용자 레벨이고 하나는 커널 레벨이다. 사용자 스레드와 커널 스레드는 어떠한 연관관계가 있다.     리눅스는 일대일 모델이다. 하나의 사용자 스레드당 커널 스레드 하나가 매칭된다. 그래서 리눅스 커널 입장에서 보면 ‘각각의 스레드가 하나의 프로세스다’ 라고 표현한다. 그런데 여기서의 프로세스는 이전에 설명했던 프로세스가 각각 다른 메모리를 가진 것과는 다르게 메모리를 공유한다. 그래서 이것들을 light weight process라고 구분해서 부른다. 이전에 설명했던 프로세스는 프로세스 고유번호(PID)를 가지고 있다. 그렇다면 리눅스는 스레드가 각각 다른 PID를 가지고 있을까? 그건 아니다. 확인해보면 한 프로세스의 생성된 스레드는 모두 같은 PID를 가지고 있다.     더 자세히 보면 TGID라는 스레드 그룹 아이디를 가지고 있고 TID라는 스레드 아이디도 있다. 그래서 사용자 레벨입장에서 보면 스레드 그룹 아이디가 PID로 보여지고 커널 입장에서 보면 TID가 PID로 인식이 된다. 그래서 관점을 다르게 해서 이해 해야 한다. 그래서 커널 입장에서는 각각이 다른 프로세스로 보이게 된다.          [참조] 이 글은 해당 영상(링크)을 참고하여 작성한 글입니다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "/cs/CS-ProcessandThread/",
        "teaser": ""
      },{
        "title": "@BeforeEach, @BeforeAll 차이",
        "excerpt":"@BeforeEach, @BeforeAll 애노테이션은 JUnit5에서 나온 애노테이션들이다.   @BeforeEach, @BeforeAll 애노테이션을 사용하려면 dependency에 아래 라이브러리를 추가해야 한다.   build.gradle   1 testImplementation('org.junit.jupiter:junit-jupiter:5.5.0')   1 import static org.junit.jupiter.api.Assertions.*;   @BeforeEach   @BeforeEach는 각각의 테스트 메소드가 실행될 때 호출되는 메소드이다. 각각의 메소드가 실행 전에 호출되어 처리된다.      리턴 타입으로는 반드시 void   접근 제한자로 pirvate 사용 금지   static으로 선언 금지      참고 @AfterEach 애노테이션 각각의 테스트 메소드가 실행된 후 종료되어야 할 리소스를 처리하는 부분으로 사용된다.     @BeforeAll   @BeforeAll은 모든 테스트 메소드가 실행되기 전에 한 번 실행된다.      리턴 타입으로는 반드시 void   접근 제한자로 pirvate 사용 금지   반드시 static으로 선언      참고 @AfterAll 애노테이션 모든 테스트 메소드가 실행된 후 한 번 실행된다.     @BeforeEach, @BeforeAll 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import org.junit.jupiter.api.*;  public class LifecycleTest {      @BeforeAll     static void init() {         System.out.println(\"LifecycleTest.init\");     }      public LifecycleTest() {         System.out.println(\"new LifecycleTest\");     }      @BeforeEach     void setUp() {         System.out.println(\"setUp\");     }      @Test     void a() {         System.out.println(\"A\");     }      @AfterEach     void tearDown() {         System.out.println(\"tearDown\");     }      @AfterAll     static void close() {         System.out.println(\"LifecycleTest.close\");     } }   1 2 3 4 5 6 7 8 9 10 11 # 실행 결과 LifecycleTest.init new LifecycleTest setUp A tearDown new LifecycleTest setUp B tearDown LifecycleTest.close  ","categories": ["TestCode"],
        "tags": ["TestCode","JAVA"],
        "url": "/testcode/TESTCODE-BeforeAll-BeforeEach/",
        "teaser": ""
      },{
        "title": "JUnit Assertions, AssertJ",
        "excerpt":"JUnit Assertions와 AssertJ   테스트 코드를 작성할 때 사용하는 Assertions는 JUnit이 구현한 클래스도 있고 AssertJ의 Assertions가 있다.   JUnit에서 제공하는 공식 기능인 Jupiter보다 AssertJ를 선호하는데 그 이유는 무엇일까?   Jupiter의 단점   공식 가이드에서 제공하는 메서드를 보면 단순하다. 기대값과 실제값을 넣고 일치하는지, 아니면 조건이 True 인지 False 만 판단하는 기능만 구성되어 있다. 무엇을 검사하는지 파악하기 힘들다.   또한, 메서드 체이닝이 없어서 AssertJ에 비해 사용하기 불편하다.   1 2 3 4 // JUnit assertEquals(expected, actual); // AssertJ (메서드 체이닝) assertThat(actual).isEqualTo(expected);   AssertJ 란?   테스트에 관련된 많은 기능을 제공하고 가독성이 높은 테스트 코드 작성을 지원하는 오픈 라이브러리이다.   JUnit의 Assertions와 같은 클래스 명을 가지므로 주의해서 import 해야 한다.      JUnit Assertions → import org.junit.jupiter.api.Assertions;   AssertJ → import org.assertj.core.api.Assertions;   assertThat(검증 대상)로 시작하며 메서드 체이닝을 이용하여 검증 메서드를 연쇄적으로 사용할 수 있다.      참고 메서드 체이닝   말 그대로 메소드를 고리처럼 엮어서 메소드를 계속해서 사용할 수 있게끔 하는 방법이다.    ","categories": ["TestCode"],
        "tags": ["TestCode","JAVA"],
        "url": "/testcode/TESTCODE-Junit-AssertJ/",
        "teaser": ""
      },{
        "title": "연관관계 편의 메서드",
        "excerpt":"연관관계 편의 메서드는 양방향 연관관계일 경우에 해당된다.   연관관계 편의 메서드에 설명하기 위해 Member 객체와 Order 객체가 있고 이 둘은 양방향 연관관계라고 가정하자. Order 입장에선 다대일 관계이고 Member 입장에선 일대다 관계이다.   양방향 연관관계의 경우 각각 객체에 다른 객체를 참조할 수 있는 참조용 필드를 정의한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Member 엔티티 public class Member {      @Id     @GeneratedValue     @Column(name = \"member_id\")     private Long id;      ...      @OneToMany(mappedBy = \"member\")     private List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); }  // Order 엔티티 public class Order {      @Id     @GeneratedValue     @Column(name = \"order_id\")     private Long id;      @ManyToOne(fetch = LAZY)     @JoinColumn(name = \"member_id\")     private Member member;      ... }   양방향 연관관계는 양 쪽 객체를 모두 신경써야 한다. 만약, Member 객체와 Order 객체를 저장한다고 하면 아래 코드와 같이 입력해야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13  Order order = new Order(); order.setName(\"order\") em.persist(order);  Member member = new Member(); member.setName(\"memberA\");  // 양방향 연관관계 시 양쪽에 연관관계 설정 member.getOrders().add(order); order.setMember(member);  em.persist(member);   JPA 입장에서는 연관관계 설정을 위해 주인 쪽에만 연관관계를 설정하면 된다. 하지만, 객체 입장에서 보면 양쪽에 연관관계를 모두 넣어주는게 좋다. 따라서, 순수 객체 상태를 고려하여 항상 양쪽에 값을 넣어주자.   하지만, 개발을 하다보면 까먹는 경우가 생길 수 밖에 없다. 따라서, 연관관계 편의 메서드(createMember())를 새로 정의하여 한번만 호출해도 두 줄의 코드를 수행할 수 있게 만든다.   1 2 3 4 5 public void createMember(Member member) {     this.member = member;     member.getOrders().add(this); } // 여기서 this는 현재 인스턴스를 의미한다.      참고  연관관계 편의 메서드를 정의하는 곳은 핵심 로직을 가진 쪽에 정의하는 것이 좋다.        참고 연관관계 편의 메서드 삭제 양방향 연관관계인 경우 삭제할 때도 연관관계 편의 메서드를 만들어야 할까? 이론적인 관점에서 보면 삭제를 위한 연관관계 편의 메서드를 정의하는 것이 맞으나 실용적인 관점에서 생각하면 삭제한 이후 삭제한 객체를 활용하는 로직이 대부분 없기 때문에 편의 메서드는 생략해도 상관없다. 또한, 실무에선 삭제를 하는 경우는 거의 없고 삭제 yn 필드를 변경하는 방식을 사용하기 때문에 이러한 고민을 크게 하지 않는다.    ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-Convenience-Method/",
        "teaser": ""
      },{
        "title": "연관 관계 매핑",
        "excerpt":"연관 관계를 매핑할 때 생각해야 할 것 3가지      방향: 단방향, 양방향   연관 관계의 주인: 양방향일 때, 연관 관계에서 관리 주체   다중성: 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)   단방향, 양방향   DB 테이블은 외래 키 하나로 양 쪽 테이블 조인이 가능하다. 따라서, DB는 단방향, 양방향을 나눌 필요가 없다.   그러나, 객체는 참조용 필드가 있는 객체만 다른 객체를 참조하는 것이 가능하다. 따라서, 한쪽만 참조하면 단방향 관계, 양쪽이 서로 참조하면 양방향 관계이다. 엄밀하게 말하면 양방향 관계는 없고 두 객체가 단방향 참조를 각각 가져서 양방향 관계처럼 사용하고 말하는 것이다.   JPA를 사용해서 DB와의 패러다임을 맞추기 위해서 객체는 단방향 연관 관계를 가질지, 양방향 연관 관계를 가질지 선택해야 한다.   선택은 비즈니스 로직에서 두 객체가 참조가 필요한지 여부를 고민하면 된다. 비즈니스 로직에 맞게 선택했을 때 두 객체가 서로 단방향 참조를 했다면 양방향 연관 관계가 된다.   무조건 양방향 관계로 하면 좋을까?   객체 입장에서 양방향 매칭을 했을 때 오히려 복잡해진다. 예를 들어 일반적인 비스니스 애플리케이션에서 User 엔티티는 다양한 엔티티와 연관 관계를 갖는다. 이런 경우 모든 엔티티를 양방향으로 설정하면 User 클래스가 복잡해지고, 불필요한 연관 관계 매핑으로 인해 복잡성이 증가할 수 있다. 따라서, 양방향으로 할지 단방향으로 할지 구분해줘야 한다.   기본적으로 단방향 매핑으로 설계하고 추후에 역방향 객체 탐색이 필요하면 추가하는 것이 좋다.   연관 관계의 주인(자세한 내용)   양방향 연관 관계의 경우 연관 관계의 주인을 정해야 한다. 연관 관계의 주인을 지정하는 것은 두 단방향 관계 중 제어의 권한을 갖는 실질적인 관계가 어떤 것인지 JPA에게 알려주는 것이라고 생각하면 된다.   연관 관계의 주인은 연관 관계를 갖는 두 객체 사이에서 조회, 저장, 수정, 삭제를 할 수 있지만, 연관 관계의 주인이 아니면 조회만 가능하다. 연관 관계의 주인이 아닌 객체에서 mappedBy 속성을 사용해서 주인을 지정해줘야 한다. 보통 외래 키가 있는 곳을 연관 관계의 주인으로 정한다.   왜 연관 관계의 주인을 정해야할까?   예를 들어 Member 객체와 Order 객체가 있고 양방향 연관 관계라고 가정하자.   사용자의 주문을 수정하려고 할 때 Member 객체에서 setOrder() 같은 메서드를 이용해서 수정하는게 좋을지 Order 객체에서 getMember() 같은 메서드를 이용해서 수정하는게 좋은지 헷갈릴 수 있다.   두 객체 입장에서는 두 방법 다 맞는 방법이지만, JPA 입장에서는 혼란이 온다. 즉, Member에서 Order를 수정할때 FK를 수정할 지, Order에서 Member를 수정할 때 FK를 수정할 지를 결정하기 어렵다. 때문에 두 객체 사이의 연관 관계의 주인을 정해서 명확하게 정하는 것이다.   연관 관계의 주인만 제어하면 되나?   DB에 외래 키가 있는 테이블을 수정하려면 연관 관계의 주인만 변경하면 된다. 그러나, 객체를 생각했을 때는 두 군데에서 변경하는 것이 좋다. (이 부분은 연관관계 편의 메서드를 사용하면 편리하다.)   다중성   DB를 기준으로 다중성을 결정한다.   다대일   게시판(Post)과 게시글(Board)을 예로 들면, 게시글이 N이고 게시판이 1이다. 외래 키를 게시글이 관리하는 일반적인 형태이다.   다대일 단방향 연관 관계   다대일 단방향에선 다 쪽인 Post에서 @ManyToOne만 추가해줬다. 반대로 Board에서는 참조하지 않았다. (단방향)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Entity public class Post {     @Id @GeneratedValue     @Column(name = \"POST_ID\")     private Long id;      @Column(name = \"TITLE\")     private String title;      @ManyToOne     @JoinColumn(name = \"BOARD_ID\")     private Board board;     //... getter, setter }  @Entity public class Board {     @Id @GeneratedValue     private Long id;     private String title;     //... getter, setter }   다대일 양방향 연관 관계   다대일 양방향은 1 쪽에 @OneToMany를 추가하고 연관관계의 주인을 설정하기 위해 주인이 아닌 쪽에 mappedBy를 지정한다. mappedBy로 지정할 때 값은 대상이 되는 변수명을 따라 지정하면 된다. 여기서는 Post 객체의 board라는 이름의 변수이기 때문에 똑같이 board로 지정했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Entity public class Post {     @Id @GeneratedValue     @Column(name = \"POST_ID\")     private Long id;      @Column(name = \"TITLE\")     private String title;      @ManyToOne     @JoinColumn(name = \"BOARD_ID\")     private Board board;     //... getter, setter }  @Entity public class Board {     @Id @GeneratedValue     private Long id;     private String title;      @OneToMany(mappedBy = \"board\")     List&lt;Post&gt; posts = new ArrayList&lt;&gt;();     //... getter, setter }   일대다   일대다와 다대일은 다르다. 다대일의 기준은 연관관계의 주인 다(N)쪽에 둔 것이고 이번에 언급할 일대다의 기준은 연관관계의 주인을 1 쪽에 둔 것이다.   일대다 단방향 연관 관계      참고 실무에서는 일대다 단방향은 거의 쓰지 않는다.     DB 입장에서는 무조건 다쪽에서 외래키를 관리한다. 하지만 일대다 단방향은 1쪽 객체에서 다쪽 객체를 조작(생성, 수정, 삭제)하는 방법이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Entity public class Post {     @Id @GeneratedValue     @Column(name = \"POST_ID\")     private Long id;      @Column(name = \"TITLE\")     private String title;     //... getter, setter }  @Entity public class Board {     @Id @GeneratedValue     private Long id;     private String title;      @OneToMany(mappedBy = \"board\")     List&lt;Post&gt; posts = new ArrayList&lt;&gt;();     //... getter, setter }   1 2 3 4 5 6 7 8 Post post = new Post(); post.setTitle(\"hello\"); em.persist(post);  Board board = new Board(); board.setTitle(\"Free Board\"); board.getPosts().add(post); em.persist(board);   post를 저장할 때 insert 쿼리가 실행된다. 그 후 board를 저장할 때 board를 insert하는 쿼리가 나간 후에 post를 update하는 쿼리가 실행된다. board.getPosts().add(post); 부분 때문이다.   Board 엔티티는 Board 테이블에 매핑되기 때문에 Board 테이블에 직접 지정할 수 있으나 Post 테이블의 FK를 저장할 방법이 없으므로 조인 및 업데이트 쿼리를 날려야 하는 문제가 있다.   따라서, 일대다 단방향은 다대일 양방향 연관 관계로 매핑하는 것이 추후에 유지보수에 훨씬 수월하다.   일대다 양방향 연관 관계는 공식적으로 존재하지 않는다. 결론은 일대다 단방향, 양방향을 사용할 거면 다대일 양방향을 사용하는 것이 맞다.   일대일   주 테이블에 외래키를 넣을 수도 있고 대상 테이블에 외래키를 넣을 수도 있다. (일대일이기 때문에 테이블 A, B가 있을때 주 테이블이 A면 대상 테이블이 B이다.)   아래 예제는 Post가 하나의 Attach를 가지고 있다고 가정한다.   일대일 단방향           외래 키를 주 테이블이 갖고 있을 때 (Post: 주 테이블, Attach: 대상 테이블)       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Entity  public class Post {      @Id @GeneratedValue      @Column(name = \"POST_ID\")      private Long id;           @Column(name = \"TITLE\")      private String title;      @OneToOne      @JoinColumn(name = \"ATTACH_ID\")      private Attach attach;      //... getter,setter  }  @Entity  public class Attach {      @Id @GeneratedValue      @Column(name = \"ATTACH_ID\")      private Long id;      private String name;    //... getter, setter  }                외래 키를 대상 테이블이 갖고 있을 때: JPA에서는 지원을 하지 않는다.       일대일 양방향           외래키를 주 테이블이 갖고 있을 때       단순하게 똑같이 @OneToOne 설정 후 mappedBy 설정만 해서 읽기 전용으로 만들어주면 양방향도 간단하다.       1 2 3 4 5 6 7 8 9 10 11  @Entity  public class Attach {      @Id @GeneratedValue      @Column(name = \"ATTACH_ID\")      private Long id;      private String name;           @OneToOne(mappedBy = \"attach\")      private Post post;    //... getter, setter  }                외래키를 대상 테이블이 갖고 있을 때       이럴때는 어차피 양 쪽이 일대일이기 때문에 위에서 정의한 대로 처리하면 된다. 하지만 논란의 여지가 있다. 외래키를 Post에서 관리하는 것이 좋은 지 Attach에서 관리하는 것이 좋은 지 생각해봐야 한다.       비즈니스가 변경되어 하나의 Post가 Attach를 여러개 가질 수 있다고 가정하자. 그렇다면 외래 키는 다쪽인 Attach에 있는게 비즈니스 변경에 유리하다. 그렇다고 무조건 다가 될 확률이 높은 테이블에 외래 키를 놓는 것이 좋은게 아니다. Post 쪽에 외래 키를 두면 성능상 이득이 있기 때문이다.       결론은 종합적으로 판단하고 결정해야 한다.       다대다   실무에서 사용하면 안된다. 다대다는 일대다 - 다대일로 풀어서 만드는 것 (중간 테이블을 Entity로 만드는 것)이 추후 변경에도 유연하게 대처할 수 있다.  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/JPA-JPA-Mapping/",
        "teaser": ""
      },{
        "title": "정적 팩토리 메서드",
        "excerpt":"정적 팩토리 메서드란?   정적(static), 팩토리(factory), 메서드(method)   여기서 팩토리라는 용어가 조금 생소할 수 있다. GoF 디자인 패턴 중 팩토리 패턴에서 유래한 이 단어는 객체를 생성하는 역할을 분리하겠다는 취지가 담겨있다.   다시 말해, 정적 팩토리 메서드란 객체 생성의 역할을 하는 클래스 메서드라는 의미로 요약할 수 있다.   자바에서 객체를 생성할 때 new 키워드를 사용한다. 정적 팩토리 메서드는 new를 직접적으로 사용하지 않을 뿐, 정적 팩토리 메서드라는 클래스 내에 선언되어있는 메서드를 내부의 new를 이용해 객체를 생성해 반환하는 것이다. 즉, 정적 팩토리 메서드를 통해 new를 간접적으로 사용한다.   생성자를 통한 객체 생성(new 사용)   1 String str1 = new String(\"hello\");   정적 팩토리 메서드를 통한 객체 생성   1 String str2 = String.valueOf(\"hello\");   두 경우 모두 String 타입 객체를 반환해준다.   생성자와 정적 패토리 메서드   생성자를 통해 객체를 생성하는 방식과 정적 팩토리 메서드로 객체를 만드는 방식이 하는 일은 비슷해보인다. 하지만 다른 점이 있다.   정적 팩토리 메서드 장점      이름을 가질 수 있다.            정적 팩토리 메서드를 사용하면 메서드 네이밍에 따라 반환될 객체의 특성을 묘사할 수 있다. 즉, 코드의 가독성이 상승한다.           호출할 때 마다 새로운 객체를 생성할 필요가 없다.            enum이 대표적인 예시이다.       사용되는 값들의 개수가 정해져 있으면 해당 값을 미리 생성해놓고 조회(캐싱) 할 수 있는 구조로 만들 수 있다.           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  public class Day {           private static final Map&lt;String, Day&gt; days = new HashMap&lt;&gt;();           static {          days.put(\"mon\", new Day(\"Monday\"));          days.put(\"tue\", new Day(\"Tuesday\"));          days.put(\"wen\", new Day(\"Wednesday\"));          days.put(\"thu\", new Day(\"Thursday\"));          days.put(\"fri\", new Day(\"Friday\"));          days.put(\"sat\", new Day(\"Saturday\"));          days.put(\"sun\", new Day(\"Sunday\"));      }           public static Day from(String day) {          return days.get(day);      }           private final String day;           private Day(String day) {          this.day = day;      }           public String getDay() {          return day;      }  }       public static void main(String[] args) {      Day day = Day.from(\"mon\");      System.out.println(day.getDay());  }                  각 요일을 static을 통해 미리 생성. 미리 생성된 Day 객체를 찾아 반환만 하면 된다.           하위 자료형 객체를 반환할 수 있다.            상속을 사용 할 때 확인 할 수 있다. 정적 팩토리 메서드가 반환값을 반환할 때, 상황에 따라 하위 클래스 타입의 객체를 반환 해줄 수 있다.           입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.            반환 타입의 하위 타입이기만 하면 어느 타입이든 객체를 반환해도 상관없다.       만약, 특정 인터페이스들을 상속 받은 구현체들이 있을 때, 객체 생성 시 상황에 따라서 유동적으로 해당하는 구현체 타입으로 반환 한다고 생각 됨           정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.   정적 팩토리 메서드의 단점      상속에는 public 혹은 protected 생성자가 필요하므로 정적 팩토리 메서드만 제공할 경우, 상속이 불가능하다.   정적 팩토리 메서드를 다른 개발자들이 찾기 어렵다. → 정적 팩토리 메서드 컨벤션, API 문서를 잘 작성하면 해결할 수 있다.   Lombok으로 정적 팩토리 메서드 정의   Lombok의 RequiredArgsConstructor를 사용하면 정적 팩토리 메서드를 쉽게 만들 수 있다.   1 2 3 4 5 6 7 8 9 @RequiredArgsConstructor(staticName = \"of\") public class Order {     private final Long id;     private final String name;      public static void main(String[] args) {         Order order = Order.of(1L, \"hello\");     } }  ","categories": ["DesignPattern"],
        "tags": ["DesignPattern","Java"],
        "url": "/designpattern/DesignPattern-StaticFactoryMethod/",
        "teaser": ""
      },{
        "title": "Mock 이란?",
        "excerpt":"Mock 이란?   가짜를 뜻한다. 진짜 객체와 비슷하게 동작하지만 프로그래머가 직접 그 객체의 행동을 관리하는 객체이다.   메소드가 return을 하기까지 어떠한 로직을 걸치는데 그 로직을 전부 구현하기에는 무리가 있을 때, 메소드가 return 하는 타입의 어떤 예측한 값이 나온다고 가정해서 전체적인 흐름을 테스트 할 때, mock이 사용된다.   Mockito 란?   Mock을 다루는 프레임워크의 종류로 Mock 객체를 쉽게 만들고 검증할 수 있는 방법을 제공한다.   유닛 테스트를 위한 Java Mocking Framework. Mockito를 사용하면 대부분의 로직을 검증 할 수 있다.      참고 Unit 테스트를 해야하는가? controller 테스트를 하기 위해 나머지 service 와 repository 를 목(mock)으로 만들고 유닛테스트를 진행해야하는가에 대해 의견이 서로 다르다. 그냥 같이 일하는 팀에 맞추면 된다.     dependency 추가   스프링부트는 프로젝트 생성 시 spring-boot-starter-test에서 자동으로 mockito를 추가해 준다. 만약, 스프링부트를 쓰지 않으면 의존성 직접 추가하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.mockito&lt;/groupId&gt;     &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;     &lt;version&gt;3.12.4&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.mockito&lt;/groupId&gt;     &lt;artifactId&gt;mockito-junit-jupiter&lt;/artifactId&gt;     &lt;version&gt;3.12.4&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;   Mock을 사용하는 이유   Mock을 사용하는 이유를 설명하기 위해 StudyService를 테스트하는 테스트 코드를 작성한다고 가정하자.      StudyService에는 MemberService와 StudyRepository가 주입되어 있다.   MemberService와 StudyRepository는 인터페이스이고 구현체가 정의되어 있지 않다.   1 2 3 4 public interface MemberService {      Optional&lt;Member&gt; findById(Long memberId); }   1 2 public interface StudyRepository extends JpaRepository&lt;Study, Long&gt; { }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class StudyService {      private final MemberService memberService;      private final StudyRepository repository;      public StudyService(MemberService memberService, StudyRepository repository) {         assert memberService != null;         assert repository != null;         this.memberService = memberService;         this.repository = repository;     }      public Study createNewStudy(Long memberId, Study study) {         Optional&lt;Member&gt; member = memberService.findById(memberId);         study.setOwner(member.orElseThrow(()                 -&gt; new IllegalArgumentException(\"Member doesn't exist for id: '\" + memberId + \"'\")));         return repository.save(study);     } }   이제 StudyService에 대한 테스트 코드를 작성하겠다. 그런데, StudyService를 정의하는 순간부터 막힌다. StudyService는 MemberService, StudyRepository가 있어야 만들 수 있다.   하지만, MemberService, StudyRepository는 인터페이스이기 때문에 Mock 없이 테스트 코드를 작성한다면 오버라이드된 모든 메서드들을 정의하여 사용해야 한다.   Mock 없이 테스트 코드를 작성   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test void createStudyService() {     MemberService memberService = new MemberService() {         @Override         public Optional&lt;Member&gt; findById(Long memberId) {             return Optional.empty();         }     };              StudyRepository studyRepository = new StudyRepository() {         @Override         public List&lt;Study&gt; findAll() {             return null;         }          @Override         public List&lt;Study&gt; findAll(Sort sort) {             return null;         }          ... // 이하 생략.     };              StudyService studyService = new StudyService(memberService, studyRepository); }   Mock을 사용하면 구현체가 없어도 목 객체를 주입하여 사용할 수 있다.   Mock을 사용하여 테스트 코드 작성   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @ExtendWith(MockitoExtension.class) class StudyServiceTest {      @Mock     MemberService memberService;      @Mock     StudyRepository studyRepository;      @Test     void createStudyService() {         // 생성자 주입         StudyService studyService = new StudyService(memberService, studyRepository);         assertNotNull(studyService);     } }   Mock 객체 만들기   구현체는 없지만 인터페이스는 있을때 목(Mock)을 작성하기 매우 좋다. 코드가 제대로 동작하는지 확인하려면 목킹을 하면 된다.   [방법1] Mockito.mock() 메소드 사용   1 2 3 4 5 6 7 class StudyServiceTest {      MemberService memberService = mock(MemberService.class);     StudyRepository studyRepository = mock(StudyRepository.class);      ... }   [방법2] 목 애노테이션 사용      JUnit5 extension으로 MockitoExtension을 사용한다.   1 2 3 4 5 6 7 8 9 10 11 @ExtendWith(MockitoExtension.class) class StudyServiceTest {      @Mock     MemberService memberService;      @Mock     StudyRepository studyRepository;      ... }   Mock 객체 Stubbing   Stubbing이란 행동을 조작하는 것을 말한다. Mock 인스턴스에게 실제 메서드를 호출한 것과 같은 가짜 동작을 넣어줄  수 있다.   Mock 객체 조작 (Stubbing)      특정한 매개변수를 받은 경우 특정한 값을 리턴하거나 예외를 던지도록 만들 수 있다.   void 메소드 특정 매개변수를 받거나 호출된 경우 예외를 발생 시킬 수 있다.   메소드가 동일한 매개변수로 여러번 호출될 때 각기 다르게 행동하도록 조작할 수도 있다.   when().thenReturn()   A를 호출하면 B를 반환하겠다고 행동을 조작한 것이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @ExtendWith(MockitoExtension.class) class StudyServiceTest {      @Mock     MemberService memberService;      @Mock     StudyRepository studyRepository;      @Test     void createNewStudy() {         StudyService studyService = new StudyService(memberService, studyRepository);         assertNotNull(studyService);          Member member = new Member();         member.setId(1L);         member.setEmail(\"yessm621@gmail.com\");          // stubbing (조작)         when(memberService.findById(1L)).thenReturn(Optional.of(member)); //        when(memberService.findById(2L)).thenReturn(Optional.of(member));          Optional&lt;Member&gt; findById = memberService.findById(1L);         assertEquals(\"yessm621@gmail.com\", findById.get().getEmail());     } }   when(memberService.findById(1L)).thenReturn(Optional.of(member)); 이 코드는 1L에 대해서만 유효하다. 만약 다른 파라미터 값을 넣으면 오류가 발생할 것이다. 이때 사용할 수 있는게 any() 이다.   any()   any()는 어떠한 값을 파라미터로 넣어도 무조건 Optional.of(member)를 반환 받는다. 즉, any()로 정의하면 파라미터 1L으로 호출하던, 2L으로 호출하던 같은 객체를 받게 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test void createNewStudy() {     StudyService studyService = new StudyService(memberService, studyRepository);     assertNotNull(studyService);      Member member = new Member();     member.setId(1L);     member.setEmail(\"yessm621@gmail.com\");      when(memberService.findById(any())).thenReturn(Optional.of(member));      assertEquals(\"yessm621@gmail.com\", memberService.findById(1L).get().getEmail());     assertEquals(\"yessm621@gmail.com\", memberService.findById(2L).get().getEmail()); }   any()와 같이 이러한 작업을 하는 요소를 Argument matchers라 한다.   doThrow().when()   예외를 던지고 싶을때 doThrow() 메소드를 활용한다.           반환형이 있는 경우       1  when(memberService.findById(1L)).thenThrow(new RuntimeException());                반환형이 void 인 경우       1 2 3 4 5  // memberService의 validate()가 호출되면 IllegalArgumentException 예외를 던지겠다.  doThrow(new IllegalArgumentException()).when(memberService).validate(1L);  assertThrows(IllegalArgumentException.class, () -&gt; {      memberService.validate(1L);  });           여러번 stubbing 할 때, 다르게 조작   호출되는 순서가 지정되어 있어 같은 매개변수라도 매번 다른 값을 행동하도록 조작할 수 있다. 체이닝 기법을 이용한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Test void createNewStudyException2() {     StudyService studyService = new StudyService(memberService, studyRepository);     assertNotNull(studyService);      Member member = new Member();     member.setId(1L);     member.setEmail(\"yessm621@gmail.com\");      when(memberService.findById(any()))             .thenReturn(Optional.of(member)) // 첫번째 조작             .thenThrow(new RuntimeException()) // 두번째 조작             .thenReturn(Optional.empty()); // 세번째 조작      // 첫번째 조작에 대한 테스트     Optional&lt;Member&gt; byId = memberService.findById(1L);     assertEquals(\"yessm621@gmail.com\", byId.get().getEmail());      // 두번째 조작에 대한 테스트     assertThrows(RuntimeException.class, () -&gt; {         memberService.findById(1L);     });      // 세번째 조작에 대한 테스트     assertEquals(Optional.empty(), memberService.findById(1L)); }   Mock 객체 검증   createNewStudy에서 study가 저장되면 memberService.notify()를 호출한다고 가정하자.   1 2 3 4 5 public interface MemberService {     Optional&lt;Member&gt; findById(Long memberId);     void validate(Long memberId);     void notify(Study newStudy); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class StudyService {      private final MemberService memberService;     private final StudyRepository repository;      ...      public Study createNewStudy(Long memberId, Study study) {         Optional&lt;Member&gt; member = memberService.findById(memberId);          study.setOwner(member.orElseThrow(()                 -&gt; new IllegalArgumentException(\"Member doesn't exist for id: '\" + memberId + \"'\")));          Study newStudy = repository.save(study);          // study가 저장되면 알림이 오도록 설정         memberService.notify(newStudy);          return newStudy;     } }   사실 notify에 대한 테스트 코드를 작성하기 애매하다. 이럴 때 verify()를 사용한다.   verify()   verify()는 Mock 객체의 메서드 호출에 대해서 확인 및 검증 할 수 있는 메서드이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Test void createNewStudyTest() {     StudyService studyService = new StudyService(memberService, studyRepository);     assertNotNull(studyService);      Member member = new Member();     member.setId(1L);     member.setEmail(\"yessm621@gmail.com\");      Study study = new Study(10, \"테스트\");      when(memberService.findById(1L)).thenReturn(Optional.of(member));     when(studyRepository.save(study)).thenReturn(study);      studyService.createNewStudy(1L, study);      assertEquals(member, study.getOwner());      // memberService의 notify가 1번 호출되어야 한다.     verify(memberService, times(1)).notify(any());     // memberService의 validate가 호출되면 안된다.     verify(memberService, never()).validate(any()); }   InOrder   순서대로 호출되는지 확인하고 싶을 때 사용한다.   1 2 3 4 5 6 public interface MemberService {     Optional&lt;Member&gt; findById(Long memberId);     void validate(Long memberId);     void notify(Study newStudy);     void notify(Member member); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class StudyService {      private final MemberService memberService;     private final StudyRepository repository;      ...      public Study createNewStudy(Long memberId, Study study) {         Optional&lt;Member&gt; member = memberService.findById(memberId);          study.setOwner(member.orElseThrow(()                 -&gt; new IllegalArgumentException(\"Member doesn't exist for id: '\" + memberId + \"'\")));          Study newStudy = repository.save(study);          // study가 저장되면 알림이 오도록 설정         memberService.notify(newStudy);         memberService.notify(member.get());          return newStudy;     } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Test void createNewStudyTest() {     StudyService studyService = new StudyService(memberService, studyRepository);     assertNotNull(studyService);      Member member = new Member();     member.setId(1L);     member.setEmail(\"yessm621@gmail.com\");      Study study = new Study(10, \"테스트\");      when(memberService.findById(1L)).thenReturn(Optional.of(member));     when(studyRepository.save(study)).thenReturn(study);      studyService.createNewStudy(1L, study);      assertEquals(member, study.getOwner());      verify(memberService, times(1)).notify(study);     verify(memberService, times(1)).notify(member);     verify(memberService, never()).validate(any());      // 순서 확인     InOrder inOrder = inOrder(memberService);     inOrder.verify(memberService).notify(study);     inOrder.verify(memberService).notify(member); }   memberService.notify(study)가 먼저 호출된 후, memberService.notify(member)가 호출되는 지 확인하는 테스트 코드이다.   특정 시간 이내에 호출됐는지   거의 사용하지 않음..   100s안에 memberService의 notify()가 1번 호출되어야 한다.   1 verify(memberService, timeout(100).times(1)).notify();   verifyNoMoreInteractions   모든 verify() 검증이 끝났다면 안정성을 위해 verifyNoMoreInteractions()을 호출할 수 있다.   verifyNoMoreInteractions()는 Mock 인스턴스의 메서드를 더 이상 verify() 검증할 필요가 없다는 뜻이다. 더 이상 검증할 것이 남아있지 않을 때 성공을 리턴하고 검증할 내용이 있다면 테스트에 실패하게 된다.   1 verifyNoMoreInteractions(memberService);   BDD 스타일 Mockito API   BDD   애플리케이션이 어떻게 행동해야 하는지에 대한 공통된 이해를 구성하는 방법으로, TDD에서 창안했다.      Given / When / Then   앞서 작성했던 테스트 코드 스타일도 Given / When / Then을 사용했다. 그런데, mock을 사용하면서 약간은 애매한 부분이 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @ExtendWith(MockitoExtension.class) class StudyServiceTest {      @Mock MemberService memberService;     @Mock StudyRepository studyRepository;      @Test     void createNewStudy() {         // Given         StudyService studyService = new StudyService(memberService, studyRepository);         assertNotNull(studyService);          Member member = new Member();         member.setId(1L);         member.setEmail(\"yessm621@gmail.com\");          Study study = new Study(10, \"테스트\");          // 1         when(memberService.findById(1L)).thenReturn(Optional.of(member));         when(studyRepository.save(study)).thenReturn(study);          // When         studyService.createNewStudy(1L, study);          // Then         assertEquals(member, study.getOwner());         // 2         verify(memberService, times(1)).notify(study);         verifyNoMoreInteractions(memberService);     } }   1, 2 번은 메서드 이름 때문인지 given, when, then과 맞지 않아보인다. 이때 Mockito는 BddMockito라는 클래스를 통해 BDD 스타일의 API를 제공한다.      when().thenReturn() → given().willReturn()   verify() → then().should()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import static org.mockito.BDDMockito.given; import static org.mockito.BDDMockito.then;  @ExtendWith(MockitoExtension.class) class StudyServiceTest {      @Mock MemberService memberService;      @Mock StudyRepository studyRepository;      @Test     void createNewStudy() {         // Given         StudyService studyService = new StudyService(memberService, studyRepository);         assertNotNull(studyService);          ...          // 1         given(memberService.findById(1L)).willReturn(Optional.of(member));         given(studyRepository.save(study)).willReturn(study);          // When         studyService.createNewStudy(1L, study);          // Then         assertEquals(member, study.getOwner());         // 2         then(memberService).should(times(1)).notify(study);         then(memberService).shouldHaveNoMoreInteractions();     } }   Mockito 레퍼런스   Mockito - mockito-core 4.4.0 javadoc  ","categories": ["TestCode"],
        "tags": ["TestCode","JAVA"],
        "url": "/testcode/TESTCODE-Mock/",
        "teaser": ""
      },{
        "title": "@Valid, @Validated",
        "excerpt":"@Valid   @Valid는 JSR-303 표준 스펙(자바 표준)으로 빈 검증기(Bean Validator)를 이용해 객체의 제약 조건을 검증하도록 지시하는 어노테이션이다.   Spring에서는 일조의 어댑터인 LocalValidatorFactoryBean가 제약 조건 검증을 처리한다. 이를 이용하려면 LocalValidatorFactoryBean을 빈으로 등록해야 하는데, 스프링 부트에서는 관련된 의존성을 추가하면 자동으로 설정되어 사용할 수 있다.   build.gradle에 의존성 추가   1 implementation 'org.springframework.boot:spring-boot-starter-validation'   예를 들어 name 필드가 null 또는 ’’ 이 아닌지 확인하며 컨트롤러의 메서드에 @Valid를 붙이면 유효성 검증을 진행한다.   1 2 3 4 5 6 7 8 @Getter @Setter public class MemberForm {      @NotEmpty(message = \"회원 이름은 필수 입니다.\")     private String name;      ... }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import javax.validation.Valid;  @Controller @RequiredArgsConstructor public class MemberController {     ...      @PostMapping(\"members/new\")     public String create(@Valid MemberForm form, BindingResult result) {         if (result.hasErrors()) {             return \"members/createMemberForm\";         }         ...     } }   @Valid의 동작원리   모든 요청은 프론트 컨트롤러인 디스패처 서블릿을 통해 컨트롤러로 전달된다. 전달 과정에서는 컨트롤러 메서드의 객체를 만들어주는 ArgumentResolver가 동작하는데 @Valid 역시 ArgumentResolver에 의해 처리가 된다.   대표적으로 @RequestBody는 Json 메시지를 객체로 변환해주는 작업이 ArgumentResolver의 구현체인 RequestResponseBodyMethodProcessor가 처리되며, 이 내부에서 @Valid로 시작하는 어노테이션이 있을 경우에 유효성 검사를 진행한다. 만약 @ModelAttribute를 사용중이라면 ModelAttributeMethodProcessor에 의해 @Valid가 처리된다.   그리고 검증에 오류가 있다면 MethodArgumentNotValidException 예외가 발생하게 되고, 디스패처 서블릿에 기본으로 등록된 예외 리졸버인 DefalutHandlerExceptionResolver에 의해 400 BadRequest 에러가 발생한다.   이러한 이유로 @Valid는 기본적으로 컨트롤러에서만 동작하며 기본적으로 다른 계층에서는 검증되지 않는다. 다른 계층에서 파라미터를 검증하기 위해서는 @Validated와 결합되어야 한다.   @Validated   입력 파라미터의 유효성 검증은 컨트롤러에서 최대한 처리하고 넘겨주는 것이 좋다. 하지만, 개발을 하다보면 불가피하게 다른 곳에서 파라미터를 검증해야 할 수 있다. 스프링은 이를 위해 AOP 기반으로 메소드의 요청을 가로채서 유효성 검증을 진행해주는 @Validated를 제공한다. @Validated는 JSR 표준 기술은 아니고 스프링 프레임워크에서 제공하는 어노테이션 및 기능이다.   다음과 같이 클래스에 @Validated를 붙여주고, 유효성을 검증할 메소드의 파라미터에 @Valid를 붙여주면 유효성 검증이 진행된다.   1 2 3 4 5 6 7 @Service @Validated public class MemberService {     public void signup(@Valid MemberForm memberForm) {         ...     } }   유효성 검증에 실패하면 에러가 발생하는데 로그를 확인해보면 @Valid에서 발생한 MethodArgumentNotValidException 예외가 아닌 ConstraintViolationException 예외가 발생한다. 이는 @Valid와 @Validated의 동작원리가 다르기 때문이다.   @Validated의 동작원리   @Valid는 특정 ArgumentResolver에 의해 유효성 검사가 진행되었다면 @Validated는 AOP 기반으로 메소드 요청을 인터셉터하여 처리된다. @Validated를 클래스 레벨에 선언하면 해당 클래스에 유효성 검증을 위한 AOP의 어드바이스 또는 인터셉터가 등록된다. 그리고 해당 클래스의 메소드들이 호출될 때 AOP의 포인트 컷으로써 요청을 가로채서 유효성 검증을 진행한다.   이러한 이유로 @Validated를 사용하면 컨트롤러, 서비스, 리포지토리 등 계층에 무관하게 스프링 빈이라면 유효성 검증을 진행할 수 있다. 유효성 검증 AOP가 적용되도록 클래스에는 @Validated를 검증을 진행한 메소드에는 @Valid를 선언하면 된다.   @Valid와 @Validated는 동작원리의 차이로 발생하는 예외가 달라진다는 것을 기억하자.   @Validated의 또 다른 기능   @Validated의 또 다른 기능은 그룹 지정 기능이다. (거의 사용하지 않는다. 이런게 있다 정도로 이해하자.)   예를 들어 일반 사용자의 요청과 관리자의 요청이 1개의 클래스로 처리될 때, 다른 제약 조건이 적용되어야 하는 경우가 있다. 동일한 클래스에 대한 제약조건이 요청에 따라 달라질 수 있는데 이처럼 제약 조건이 적용될 검증 그룹을 지정할 수 있는 기능을 @Validated가 제공한다.   검증 그룹을 지정하기 위해서 마커 인터페이스를 정의해야 한다. 앞선 예를 코드로 적용하면 다음과 같다.   1 2 public interface UserValidationGroup {} public interface AdminValidationGroup {}      참고 마커 인터페이스 일반적인 인터페이스와 동일하지만 사실상 아무 메소드도 선언하지 않은 인터페이스를 말한다.     그리고 해당 제약 조건이 적용될 그룹을 groups로 지정할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* DTO의 경우 */ // 제약 조건이 적용될 그룹이 여러 개일 경우 @NotEmpty(groups = {UserValidationGroup.class, AdminValidationGroup.class} )  private String name;   @NotEmpty(groups = UserValidationGroup.class)  private String userId;   @NotEmpty(groups = AdminValidationGroup.class)  private String adminId;  /* Controller의 경우 */ @PostMapping(\"members/new\") public String create(@Validated(UserValidationGroup.class) MemberForm form) {     ... }   다양한 제약 조건 어노테이션   JSR 표준 스펙은 다양한 제약 조건 어노테이션을 제공한다.      @NotNull: null이 아닌지 검증한다.   @NotEmpty: null, 빈 스트링(””)이 아닌지 검증한다.   @NotBlank: null, 빈 스트링(””), 공백(” “)이 아닌지 검증한다.   @AssertTrue: true인지 검증한다.   @Size: 값이 주어진 값 사이에 해당하는지 검증한다.   @Min: 값이 주어진 값보다 작은지 검증한다.   @Max: 값이 주어진 값보다 큰지 검증한다.   @Pattern: 값이 주어진 패턴과 일치하는지 검증한다.   이것 외에도 다양한 어노테이션을 지원하므로 공식 문서(링크)를 참고하자.   @Valid, @Validated 차이   @Valid는 자바 표준 스펙이며 컨트롤러에서만 유효성 검증이 가능하다. 유효성 검증에 실패하면 MethodArgumentNotValidException이 발생한다.   @Validated는 자바 표준 스펙이 아닌 스프링 프레임워크가 제공하는 기능이다. 계층에 무관하게 스프링 빈이라면 유효성 검증을 진행할 수 있다. 클래스에는 @Validated를 메서드에는 @Valid를 붙여준다. 유효성 검증에 실패하면 ConstraintViolationException이 발생한다.  ","categories": ["Spring"],
        "tags": ["Spring"],
        "url": "/spring/Spring-Valid-Validated/",
        "teaser": ""
      },{
        "title": "변경 감지와 병합",
        "excerpt":" ✨ 결론부터 말하면 병합(merge)은 사용하지 말고 변경 감지(Dirth Checking)를 사용하자.    변경 감지와 병합에 대해 알아보기 전에 먼저 준영속 엔티티에 대해 알아보자.   준영속 엔티티   준영속 엔티티란 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다. 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 엔티티이다.   여기서는 itemService.saveItem(book)에서 수정을 시도하는 Book 객체이다. Book 객체는 이미 DB에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.   준영속이라는 단어는 객체를 new 했거나, 안했거나를 기준으로 나누는 것이 아니다. 핵심은 식별자를 기준으로 영속상태가 되어서 DB에 저장된 적이 있는가 를 기준으로 생각해야 한다. 그래서 식별자를 기준으로 이미 한번 영속상태가 되어버린 엔티티가 있는데, 더이상 영속성 컨텍스트가 관리하지 않으면 모두 준영속 상태이다.   1 2 3 4 5 6 7 8 9 10 11 @PostMapping(\"/items/{itemId}/edit\") public String updateItem(@PathVariable Long itemId, @ModelAttribute(\"form\") BookForm form) {     Book book = new Book();     book.setId(form.getId());     book.setName(form.getName());     book.setPrice(form.getPrice());     ...      itemService.saveItem(book);     return \"redirect:/items\"; }   위의 Book은 새로운 객체이다. 하지만, Book에 들어가는 데이터는 이미 DB에 한번 저장되어서 식별자가 존재한다. 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.   준영속 엔티티의 문제점은 JPA가 관리를 하지 않기 때문에 변경 감지가 일어나지 않는다. 그렇다면, 준영속 엔티티를 어떻게 수정해야 할까?   준영속 엔티티를 수정하는 방법   준영속 엔티티를 수정할 수 있는 방법은 변경 감지(Dirty Checking) 기능을 사용하거나 병합(merge)을 사용하는 것이다.      참고 엔티티는 영속 상태로 관리된다. 영속 상태에 있는 엔티티는 값만 바꿔도 JPA가 트랜잭션 커밋 시점에 변경된 내용을 알아서 변경해준다.     변경 감지와 병합(merge)   변경 감지 기능 사용   변경 감지는 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법이다.   트랜잭션 안에서 식별자를 통해 엔티티를 다시 조회한 후, 트랜잭션 커밋 시점(flush())에 JPA가 변경된 내용을 찾아서 DB에 UPDATE SQL 실행한다. 이것이 변경 감지(Dirty Checking)이다.   1 2 3 4 5 6 7 @Transactional public void updateItem(Long itemId, Book param){     Item findItem = itemRepository.findOne(itemId);     findItem.setPrice(param.getPrice());     findItem.setName(param.getName());     findItem.setStockQuantity(param.getStockQuantity()); }      트랜잭션 안에서 itemRepository.findOne(itemId)을 조회하므로 영속 상태의 엔티티를 찾아온다.            트랜잭션 바깥에서 조회하면 영속 상태의 엔티티를 조회하는 것이 아니다.           영속 상태의 데이터를 setter()로 수정한다.   @Transactional 애노테이션으로 인해 커밋이 되면서 flush()를 날리면, 영속성 컨텍스트가 변경이 일어난 엔티티를 찾아 DB에 update 쿼리를 날려준다.   병합(merge)   병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다.   1 2 3 4 @Transactional void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티     Item mergeItem = em.merge(itemParam); }   간단하게 말하면 병합은 변경 감지에서 사용했던 코드를 JPA가 코드 한줄로 처리한 것이다. merge()가 호출되면 파라미터로 넘어온 item의 식별자 값으로 1차 캐시에서 엔티티를 조회한다. 만약, 1차 캐시에 엔티티가 없으면 DB를 조회하고 1차 캐시에 저장한다. 조회한 엔티티는 영속 상태이다. JPA가 파라미터로 넘어온 값(준영속 엔티티)을 영속 상태의 엔티티의 값과 모두 바꿔치기(교체, merge) 한다. (findItem.setPrice(param.getPrice())을 자동으로 해준다.)   결과적으로, 위의 코드에서 파라미터로 넘어온 itemParam은 준영속 상태이고 mergeItem은 영속 상태이다.   왜 변경 감지를 사용해야 할까?   변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 병합 시 값이 없으면 null로 업데이트 할 위험이 있다. (병합은 모든 필드를 교체한다.)   실무에서 데이터 수정은 매우 제한적이다. 모든 필드를 변경하는 경우가 거의 없다. 따라서, 실무에선 가급적 병합(merge)을 쓰지 말고 변경 감지를 사용하자.      참고 영속상태의 엔티티 수정 영속 상태의 엔티티는 변경 감지 기능이 동작해서 트랜잭션을 커밋할 때 자동으로 수정된다. 따라서, 별도의 수정 메서드를 호출할 필요가 없다.     정리   엔티티를 변경할 때는 항상 변경 감지를 사용하자.           컨트롤러에서 어설프게 엔티티를 생성하지 말자.       1 2 3 4 5 6 7 8 9 10 11 12  /* ItemController */  @PostMapping(\"/items/{itemId}/edit\")  public String updateItem(@PathVariable Long itemId, @ModelAttribute(\"form\") BookForm form){      // 엔티티 생성하는 코드      /*Book book = new Book();      book.setId(form.getId());      book.setName(form.getName());      book.setPrice(form.getPrice());      book.setStockQuantity(form.getStockQuantity());*/      itemService.updateItem(itemId, form.getName(), form.getPrice(), form.getStockQuantity());      return \"redirect:/items\";  }           1 2 3 4 5 6 7 8 9 10  /* ItemService */  @Transactional  public void updateItem(Long itemId, String name, int price, int stockQuantity) {      Item findItem = itemRepository.findOne(itemId);      // setter() 사용 피하자.      /*findItem.setName(name);      findItem.setPrice(price);      findItem.setStockQuantity(stockQuantity);*/      findItem.update(itemId, name, price, stockQuantity);  }           파라미터로 전달할 데이터가 많다면 DTO를 사용하는 것도 하나의 방법이다.       1 2 3 4 5 6  /* ItemService */  @Transactional  public void updateItem(Long itemId, UpdateItemDto item) {      Item findItem = itemRepository.findOne(itemId);      ...  }           참고로 setter()를 열어서 사용하는 것보다 변경과 관련된 메서드를 만들어서 사용하는 것이 좋다.       트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달 (파라미터 or dto)   트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경   트랜잭션 커밋 시점에 변경 감지가 실행됨  ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-DirtyChecking-Merge/",
        "teaser": ""
      },{
        "title": "영속성 전이, Cascade",
        "excerpt":"영속성 전이란?   Cascade라고도 한다. 엔티티의 상태 변화를 전파시키는 옵션으로 만약 엔티티에 상태 변화가 있으면 연관되어 있는 엔티티에도 상태 변화를 전이시키는 옵션이다.   사용하는 이유?   Cascade를 사용하는 이유를 설명하기 위해 다음과 같은 예를 들겠다. OrderItem과 Order는 다대일 양방향 연관관계이다.   Cascade를 사용하지 않으면 OrderItem을 저장할 때 모든 엔티티를 각각 persist() 해주어야 한다. 각각 엔티티마다 적용해야 하므로 번거롭고 귀찮다.   1 2 3 4 5 6 //@OneToMany(mappedBy = \"order\") //private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;(); em.persist(orderItemA); em.persist(orderItemB); em.persist(orderItemC); em.persist(order);   Cascade를 사용하면 아래 코드처럼 간단해진다. order만 persist() 해주면 된다.   1 2 3 //@OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL) //private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;(); em.persist(order);   Cascade 옵션   Cascade엔 6가지 옵션이 있다.      ALL   PERSIST   REMOVE   MERGE   REFERESH   DETACH   주로 사용하는 옵션은 ALL과 PERSIST이다. All의 경우 모든 영속성이 전이되는 경우이고 Persist의 경우 엔티티가 저장될 때만 연쇄적으로 저장되게 하는 옵션이다.   어디에 써야 할까?   일대다 연관관계 기준으로 연관관계의 주인은 다 쪽에 있다. 그 반대쪽 엔티티에 사용하면 된다.   언제 써야 할까?      Cascade 되는 엔티티와 Cascade를 설정하는 엔티티의 라이프사이클이 동일하거나 비슷해야 한다.   Cascade 되는 엔티티가 Cascade를 설정하는 엔티티에서만 사용되어야 한다.   예를 들어, Post와 Image가 있다고 가정하자. Image는 Post에서만 사용되고 Post가 삭제되면 Image도 삭제되어야 한다. 결론적으로, Image와 Post가 양방향 연관관계일 경우 Post 엔티티에 정의된 List images에 Cascade.ALL 옵션을 줄 수 있다.   1 2 3 4 public class Post {     @OneToMany(mappedBy = \"post\", cascade = Cascade.ALL)     List&lt;Image&gt; images = new ArrayList&lt;&gt;(); }   1 2 3 4 5 public class Image {     @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"post_id\")     private Post post; }   cascade를 사용할 수 없는 경우도 살펴보자. 예를 들어 Post, Comment, Member가 있다고 가정하자.      Post와 Comment: 일대다 연관관계, Cascade 적용   Member와 Comment: 일대다 연관관계   만약, 게시글이 삭제되면 해당 게시물에 달린 댓글도 삭제된다. 이제 사용자는 더 이상 자신이 작성한 댓글을 확인할 수 없다. 설계 상 올바르게 구현한 것이면 상관없지만 그렇지 않은 경우엔 큰 문제가 생긴다.   결론은 모든 @OneToMany에 cascade 옵션을 걸어 버리면 안된다.   고아 객체 (orphanRemoval)   cascade와 비슷한 orphanRemoval에 대해 알아보겠다.   부모와 연관관계가 끊어진 엔티티를 고아객체라고 하며 이러한 고아객체를 자동으로 삭제해주는 옵션을 활성화 시키는 것이 orphanRemoval = true 옵션을 @OneToMany에 주는 것이다.   orphanRemoval=true 옵션은 라이프 사이클이 동일하고 해당 엔티티에서만 쓰이는 엔티티일 경우 사용해주면 된다. (Cascade와 동일한 맥락)   orphanRemoval=true와 Cascade.REMOVE   차이점   Cascade.REMOVE의 경우 일(Post)에 해당하는 엔티티를 em.remove()를 통해 직접 삭제할 때 다(Image)에 해당하는 엔티티들이 삭제되는 것이다.   orphanRemoval=true는 위의 경우는 물론이고 엔티티의 리스트에서 요소를 삭제하기만 해도 해당 엔티티가 delete되는 기능까지 포함하고 있다고 이해하면 된다.   함께 사용하면?   orphanRemoval=true와 Cascade.ALL을 함께 사용하면 다(Image)에 해당하는 리스트 형태의 엔티티는 일(Post)에 해당하는 엔티티와 라이프 사이클이 완전히 똑같아진다. 또한, 다른 엔티티에서는 사용되지 않는 엔티티일 것이다. 즉, 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다.  ","categories": ["JPA"],
        "tags": ["JPA","Spring"],
        "url": "/jpa/JPA-cascade/",
        "teaser": ""
      }]
