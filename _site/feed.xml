<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-27T17:30:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Seungmi Blog</title><subtitle>BackEnd Developer</subtitle><author><name>노승미</name></author><entry><title type="html">영속성 전이, Cascade</title><link href="http://localhost:4000/jpa/JPA-cascade/" rel="alternate" type="text/html" title="영속성 전이, Cascade" /><published>2023-01-30T00:00:00+09:00</published><updated>2023-01-31T03:05:00+09:00</updated><id>http://localhost:4000/jpa/JPA-cascade</id><content type="html" xml:base="http://localhost:4000/jpa/JPA-cascade/"><![CDATA[<h2 id="영속성-전이란">영속성 전이란?</h2>

<p><code class="language-plaintext highlighter-rouge">Cascade</code>라고도 한다. 엔티티의 상태 변화를 <strong>전파</strong>시키는 옵션으로 만약 엔티티에 상태 변화가 있으면 연관되어 있는 엔티티에도 <strong>상태 변화를 전이</strong>시키는 옵션이다.</p>

<h3 id="사용하는-이유">사용하는 이유?</h3>

<p>Cascade를 사용하는 이유를 설명하기 위해 다음과 같은 예를 들겠다. OrderItem과 Order는 다대일 양방향 연관관계이다.</p>

<p>Cascade를 사용하지 않으면 OrderItem을 저장할 때 모든 엔티티를 각각 persist() 해주어야 한다. 각각 엔티티마다 적용해야 하므로 번거롭고 귀찮다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">//@OneToMany(mappedBy = "order")</span>
<span class="c1">//private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">orderItemA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">orderItemB</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">orderItemC</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Cascade를 사용하면 아래 코드처럼 간단해진다. order만 persist() 해주면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">//@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)</span>
<span class="c1">//private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="cascade-옵션">Cascade 옵션</h3>

<p>Cascade엔 6가지 옵션이 있다.</p>

<ul>
  <li>ALL</li>
  <li>PERSIST</li>
  <li>REMOVE</li>
  <li>MERGE</li>
  <li>REFERESH</li>
  <li>DETACH</li>
</ul>

<p>주로 사용하는 옵션은 <code class="language-plaintext highlighter-rouge">ALL</code>과 <code class="language-plaintext highlighter-rouge">PERSIST</code>이다. All의 경우 <strong>모든 영속성이 전이</strong>되는 경우이고 Persist의 경우 <strong>엔티티가 저장</strong>될 때만 연쇄적으로 저장되게 하는 옵션이다.</p>

<h3 id="어디에-써야-할까">어디에 써야 할까?</h3>

<p>일대다 연관관계 기준으로 연관관계의 주인은 다 쪽에 있다. 그 <strong>반대쪽 엔티티</strong>에 사용하면 된다.</p>

<h3 id="언제-써야-할까">언제 써야 할까?</h3>

<ol>
  <li>Cascade 되는 엔티티와 Cascade를 설정하는 엔티티의 <strong>라이프사이클이 동일하거나 비슷</strong>해야 한다.</li>
  <li>Cascade 되는 엔티티가 Cascade를 설정하는 <strong>엔티티에서만 사용</strong>되어야 한다.</li>
</ol>

<p>예를 들어, Post와 Image가 있다고 가정하자. Image는 Post에서만 사용되고 Post가 삭제되면 Image도 삭제되어야 한다. 결론적으로, Image와 Post가 양방향 연관관계일 경우 Post 엔티티에 정의된 List<Image> images에 Cascade.ALL 옵션을 줄 수 있다.</Image></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"post"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">Cascade</span><span class="o">.</span><span class="na">ALL</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Image</span> <span class="o">{</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"post_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Post</span> <span class="n">post</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>cascade를 사용할 수 없는 경우도 살펴보자. 예를 들어 Post, Comment, Member가 있다고 가정하자.</p>

<ul>
  <li>Post와 Comment: 일대다 연관관계, Cascade 적용</li>
  <li>Member와 Comment: 일대다 연관관계</li>
</ul>

<p>만약, 게시글이 삭제되면 해당 게시물에 달린 댓글도 삭제된다. 이제 사용자는 더 이상 자신이 작성한 댓글을 확인할 수 없다. 설계 상 올바르게 구현한 것이면 상관없지만 그렇지 않은 경우엔 큰 문제가 생긴다.</p>

<p>결론은 모든 @OneToMany에 cascade 옵션을 걸어 버리면 안된다.</p>

<h2 id="고아-객체-orphanremoval">고아 객체 (orphanRemoval)</h2>

<p>cascade와 비슷한 orphanRemoval에 대해 알아보겠다.</p>

<p>부모와 연관관계가 끊어진 엔티티를 <code class="language-plaintext highlighter-rouge">고아객체</code>라고 하며 이러한 고아객체를 자동으로 삭제해주는 옵션을 활성화 시키는 것이 <code class="language-plaintext highlighter-rouge">orphanRemoval = true</code> 옵션을 @OneToMany에 주는 것이다.</p>

<p>orphanRemoval=true 옵션은 라이프 사이클이 동일하고 해당 엔티티에서만 쓰이는 엔티티일 경우 사용해주면 된다. (Cascade와 동일한 맥락)</p>

<h2 id="orphanremovaltrue와-cascaderemove"><strong>orphanRemoval=true와 Cascade.REMOVE</strong></h2>

<h3 id="차이점">차이점</h3>

<p>Cascade.REMOVE의 경우 일(Post)에 해당하는 엔티티를 em.remove()를 통해 직접 삭제할 때 다(Image)에 해당하는 엔티티들이 삭제되는 것이다.</p>

<p>orphanRemoval=true는 위의 경우는 물론이고 엔티티의 리스트에서 요소를 삭제하기만 해도 해당 엔티티가 delete되는 기능까지 포함하고 있다고 이해하면 된다.</p>

<h3 id="함께-사용하면">함께 사용하면?</h3>

<p>orphanRemoval=true와 Cascade.ALL을 함께 사용하면 다(Image)에 해당하는 리스트 형태의 엔티티는 일(Post)에 해당하는 엔티티와 라이프 사이클이 완전히 똑같아진다. 또한, 다른 엔티티에서는 사용되지 않는 엔티티일 것이다. 즉, 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다.</p>]]></content><author><name>노승미</name></author><category term="JPA" /><category term="JPA" /><category term="Spring" /><summary type="html"><![CDATA[영속성 전이란?]]></summary></entry><entry><title type="html">변경 감지와 병합</title><link href="http://localhost:4000/jpa/JPA-DirtyChecking-Merge/" rel="alternate" type="text/html" title="변경 감지와 병합" /><published>2023-01-26T00:00:00+09:00</published><updated>2023-01-27T02:10:00+09:00</updated><id>http://localhost:4000/jpa/JPA-DirtyChecking-Merge</id><content type="html" xml:base="http://localhost:4000/jpa/JPA-DirtyChecking-Merge/"><![CDATA[<aside>
✨ 결론부터 말하면 병합(merge)은 사용하지 말고 변경 감지(Dirth Checking)를 사용하자.

</aside>

<p>변경 감지와 병합에 대해 알아보기 전에 먼저 준영속 엔티티에 대해 알아보자.</p>

<h2 id="준영속-엔티티">준영속 엔티티</h2>

<p><code class="language-plaintext highlighter-rouge">준영속 엔티티</code>란 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다. 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 <strong>분리(detached)</strong>된 엔티티이다.</p>

<p>여기서는 itemService.saveItem(book)에서 수정을 시도하는 Book 객체이다. Book 객체는 이미 DB에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.</p>

<p>준영속이라는 단어는 객체를 new 했거나, 안했거나를 기준으로 나누는 것이 아니다. <strong>핵심은 식별자를 기준으로 영속상태가 되어서 DB에 저장된 적이 있는가</strong> 를 기준으로 생각해야 한다. 그래서 식별자를 기준으로 이미 한번 영속상태가 되어버린 엔티티가 있는데, 더이상 영속성 컨텍스트가 관리하지 않으면 모두 준영속 상태이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/items/{itemId}/edit"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nd">@ModelAttribute</span><span class="o">(</span><span class="s">"form"</span><span class="o">)</span> <span class="nc">BookForm</span> <span class="n">form</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">();</span>
    <span class="n">book</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">form</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
    <span class="n">book</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">form</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">book</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">form</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
    <span class="o">...</span>

    <span class="n">itemService</span><span class="o">.</span><span class="na">saveItem</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"redirect:/items"</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위의 Book은 새로운 객체이다. 하지만, Book에 들어가는 데이터는 이미 DB에 한번 저장되어서 식별자가 존재한다. 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 <code class="language-plaintext highlighter-rouge">준영속 엔티티</code>로 볼 수 있다.</p>

<p>준영속 엔티티의 문제점은 JPA가 관리를 하지 않기 때문에 변경 감지가 일어나지 않는다. 그렇다면, 준영속 엔티티를 어떻게 수정해야 할까?</p>

<h3 id="준영속-엔티티를-수정하는-방법">준영속 엔티티를 수정하는 방법</h3>

<p>준영속 엔티티를 수정할 수 있는 방법은 <strong>변경 감지(Dirty Checking)</strong> 기능을 사용하거나 <strong>병합(merge)</strong>을 사용하는 것이다.</p>

<blockquote>
  <p><strong>참고</strong>
엔티티는 영속 상태로 관리된다. 영속 상태에 있는 엔티티는 값만 바꿔도 JPA가 트랜잭션 커밋 시점에 변경된 내용을 알아서 변경해준다.</p>

</blockquote>

<h2 id="변경-감지와-병합merge">변경 감지와 병합(merge)</h2>

<h3 id="변경-감지-기능-사용">변경 감지 기능 사용</h3>

<p><code class="language-plaintext highlighter-rouge">변경 감지</code>는 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법이다.</p>

<p><strong>트랜잭션 안</strong>에서 식별자를 통해 엔티티를 다시 조회한 후, 트랜잭션 커밋 시점(flush())에 JPA가 변경된 내용을 찾아서 DB에 UPDATE SQL 실행한다. 이것이 변경 감지(Dirty Checking)이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nc">Book</span> <span class="n">param</span><span class="o">){</span>
    <span class="nc">Item</span> <span class="n">findItem</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
    <span class="n">findItem</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
    <span class="n">findItem</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">findItem</span><span class="o">.</span><span class="na">setStockQuantity</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getStockQuantity</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>트랜잭션 안에서 itemRepository.findOne(itemId)을 조회하므로 영속 상태의 엔티티를 찾아온다.
    <ul>
      <li>트랜잭션 바깥에서 조회하면 영속 상태의 엔티티를 조회하는 것이 아니다.</li>
    </ul>
  </li>
  <li>영속 상태의 데이터를 setter()로 수정한다.</li>
  <li>@Transactional 애노테이션으로 인해 커밋이 되면서 flush()를 날리면, 영속성 컨텍스트가 변경이 일어난 엔티티를 찾아 DB에 update 쿼리를 날려준다.</li>
</ul>

<h3 id="병합merge">병합(merge)</h3>

<p>병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nd">@Transactional</span>
<span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="nc">Item</span> <span class="n">itemParam</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//itemParam: 파리미터로 넘어온 준영속 상태의 엔티티</span>
    <span class="nc">Item</span> <span class="n">mergeItem</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">itemParam</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>간단하게 말하면 병합은 변경 감지에서 사용했던 코드를 JPA가 코드 한줄로 처리한 것이다. merge()가 호출되면 파라미터로 넘어온 item의 식별자 값으로 1차 캐시에서 엔티티를 조회한다. 만약, 1차 캐시에 엔티티가 없으면 DB를 조회하고 1차 캐시에 저장한다. 조회한 엔티티는 영속 상태이다. JPA가 파라미터로 넘어온 값(준영속 엔티티)을 영속 상태의 엔티티의 값과 모두 바꿔치기(교체, merge) 한다. (findItem.setPrice(param.getPrice())을 자동으로 해준다.)</p>

<p>결과적으로, 위의 코드에서 파라미터로 넘어온 itemParam은 준영속 상태이고 mergeItem은 영속 상태이다.</p>

<h3 id="왜-변경-감지를-사용해야-할까">왜 변경 감지를 사용해야 할까?</h3>

<p>변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 병합 시 값이 없으면 null로 업데이트 할 위험이 있다. (병합은 모든 필드를 교체한다.)</p>

<p>실무에서 데이터 수정은 매우 제한적이다. 모든 필드를 변경하는 경우가 거의 없다. 따라서, 실무에선 가급적 병합(merge)을 쓰지 말고 <code class="language-plaintext highlighter-rouge">변경 감지</code>를 사용하자.</p>

<blockquote>
  <p><strong>참고</strong> 영속상태의 엔티티 수정
영속 상태의 엔티티는 변경 감지 기능이 동작해서 트랜잭션을 커밋할 때 자동으로 수정된다. 따라서, 별도의 수정 메서드를 호출할 필요가 없다.</p>

</blockquote>

<h2 id="정리">정리</h2>

<p><strong>엔티티를 변경할 때는 항상 변경 감지를 사용하자.</strong></p>

<ol>
  <li>
    <p>컨트롤러에서 어설프게 엔티티를 생성하지 말자.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> <span class="cm">/* ItemController */</span>
 <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/items/{itemId}/edit"</span><span class="o">)</span>
 <span class="kd">public</span> <span class="nc">String</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nd">@ModelAttribute</span><span class="o">(</span><span class="s">"form"</span><span class="o">)</span> <span class="nc">BookForm</span> <span class="n">form</span><span class="o">){</span>
     <span class="c1">// 엔티티 생성하는 코드</span>
     <span class="cm">/*Book book = new Book();
     book.setId(form.getId());
     book.setName(form.getName());
     book.setPrice(form.getPrice());
     book.setStockQuantity(form.getStockQuantity());*/</span>
     <span class="n">itemService</span><span class="o">.</span><span class="na">updateItem</span><span class="o">(</span><span class="n">itemId</span><span class="o">,</span> <span class="n">form</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">form</span><span class="o">.</span><span class="na">getPrice</span><span class="o">(),</span> <span class="n">form</span><span class="o">.</span><span class="na">getStockQuantity</span><span class="o">());</span>
     <span class="k">return</span> <span class="s">"redirect:/items"</span><span class="o">;</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> <span class="cm">/* ItemService */</span>
 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">stockQuantity</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">Item</span> <span class="n">findItem</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
     <span class="c1">// setter() 사용 피하자.</span>
     <span class="cm">/*findItem.setName(name);
     findItem.setPrice(price);
     findItem.setStockQuantity(stockQuantity);*/</span>
     <span class="n">findItem</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">itemId</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">stockQuantity</span><span class="o">);</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>파라미터로 전달할 데이터가 많다면 DTO를 사용하는 것도 하나의 방법이다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> <span class="cm">/* ItemService */</span>
 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nc">UpdateItemDto</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">Item</span> <span class="n">findItem</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
     <span class="o">...</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>참고로 setter()를 열어서 사용하는 것보다 변경과 관련된 메서드를 만들어서 사용하는 것이 좋다.</p>
  </li>
  <li>트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달 (파라미터 or dto)</li>
  <li>트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경</li>
  <li>트랜잭션 커밋 시점에 변경 감지가 실행됨</li>
</ol>]]></content><author><name>노승미</name></author><category term="JPA" /><category term="JPA" /><category term="Spring" /><summary type="html"><![CDATA[✨ 결론부터 말하면 병합(merge)은 사용하지 말고 변경 감지(Dirth Checking)를 사용하자.]]></summary></entry><entry><title type="html">@Valid, @Validated</title><link href="http://localhost:4000/spring/Spring-Valid-Validated/" rel="alternate" type="text/html" title="@Valid, @Validated" /><published>2023-01-25T00:00:00+09:00</published><updated>2023-01-26T19:30:00+09:00</updated><id>http://localhost:4000/spring/Spring-Valid-Validated</id><content type="html" xml:base="http://localhost:4000/spring/Spring-Valid-Validated/"><![CDATA[<h2 id="valid">@Valid</h2>

<p><code class="language-plaintext highlighter-rouge">@Valid</code>는 <strong>JSR-303 표준</strong> 스펙(자바 표준)으로 빈 검증기(Bean Validator)를 이용해 객체의 <strong>제약 조건을 검증</strong>하도록 지시하는 어노테이션이다.</p>

<p>Spring에서는 일조의 어댑터인 LocalValidatorFactoryBean가 제약 조건 검증을 처리한다. 이를 이용하려면 LocalValidatorFactoryBean을 빈으로 등록해야 하는데, 스프링 부트에서는 관련된 의존성을 추가하면 자동으로 설정되어 사용할 수 있다.</p>

<p><strong>build.gradle에 의존성 추가</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>implementation 'org.springframework.boot:spring-boot-starter-validation'
</pre></td></tr></tbody></table></code></pre></div></div>

<p>예를 들어 name 필드가 null 또는 ’’ 이 아닌지 확인하며 컨트롤러의 메서드에 @Valid를 붙이면 유효성 검증을 진행한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberForm</span> <span class="o">{</span>

    <span class="nd">@NotEmpty</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"회원 이름은 필수 입니다."</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">javax.validation.Valid</span><span class="o">;</span>

<span class="nd">@Controller</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"members/new"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">create</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nc">MemberForm</span> <span class="n">form</span><span class="o">,</span> <span class="nc">BindingResult</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">hasErrors</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"members/createMemberForm"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="valid의-동작원리">@Valid의 동작원리</h3>

<p>모든 요청은 <strong>프론트 컨트롤러</strong>인 <code class="language-plaintext highlighter-rouge">디스패처 서블릿</code>을 통해 컨트롤러로 전달된다. 전달 과정에서는 컨트롤러 메서드의 객체를 만들어주는 ArgumentResolver가 동작하는데 <code class="language-plaintext highlighter-rouge">@Valid</code> 역시 <strong>ArgumentResolver에 의해 처리</strong>가 된다.</p>

<p>대표적으로 @RequestBody는 Json 메시지를 객체로 변환해주는 작업이 ArgumentResolver의 구현체인 RequestResponseBodyMethodProcessor가 처리되며, 이 내부에서 @Valid로 시작하는 어노테이션이 있을 경우에 유효성 검사를 진행한다. 만약 @ModelAttribute를 사용중이라면 ModelAttributeMethodProcessor에 의해 @Valid가 처리된다.</p>

<p>그리고 검증에 오류가 있다면 MethodArgumentNotValidException 예외가 발생하게 되고, 디스패처 서블릿에 기본으로 등록된 예외 리졸버인 DefalutHandlerExceptionResolver에 의해 400 BadRequest 에러가 발생한다.</p>

<p>이러한 이유로 @Valid는 기본적으로 <strong>컨트롤러에서만 동작</strong>하며 기본적으로 다른 계층에서는 검증되지 않는다. 다른 계층에서 파라미터를 검증하기 위해서는 <code class="language-plaintext highlighter-rouge">@Validated</code>와 결합되어야 한다.</p>

<h2 id="validated">@Validated</h2>

<p>입력 파라미터의 <strong>유효성 검증은 컨트롤러</strong>에서 최대한 처리하고 넘겨주는 것이 좋다. 하지만, 개발을 하다보면 불가피하게 다른 곳에서 파라미터를 검증해야 할 수 있다. 스프링은 이를 위해 <strong>AOP 기반</strong>으로 메소드의 요청을 가로채서 유효성 검증을 진행해주는 <code class="language-plaintext highlighter-rouge">@Validated</code>를 제공한다. @Validated는 JSR 표준 기술은 아니고 스프링 프레임워크에서 제공하는 어노테이션 및 기능이다.</p>

<p>다음과 같이 클래스에 @Validated를 붙여주고, 유효성을 검증할 메소드의 파라미터에 @Valid를 붙여주면 유효성 검증이 진행된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nd">@Service</span>
<span class="nd">@Validated</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">signup</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nc">MemberForm</span> <span class="n">memberForm</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>유효성 검증에 실패하면 에러가 발생하는데 로그를 확인해보면 @Valid에서 발생한 MethodArgumentNotValidException 예외가 아닌 ConstraintViolationException 예외가 발생한다. 이는 @Valid와 @Validated의 동작원리가 다르기 때문이다.</p>

<h3 id="validated의-동작원리">@Validated의 동작원리</h3>

<p>@Valid는 특정 ArgumentResolver에 의해 유효성 검사가 진행되었다면 @Validated는 AOP 기반으로 메소드 요청을 인터셉터하여 처리된다. @Validated를 클래스 레벨에 선언하면 해당 클래스에 유효성 검증을 위한 AOP의 어드바이스 또는 인터셉터가 등록된다. 그리고 해당 클래스의 메소드들이 호출될 때 AOP의 포인트 컷으로써 요청을 가로채서 유효성 검증을 진행한다.</p>

<p>이러한 이유로 @Validated를 사용하면 컨트롤러, 서비스, 리포지토리 등 계층에 무관하게 스프링 빈이라면 유효성 검증을 진행할 수 있다. 유효성 검증 AOP가 적용되도록 클래스에는 @Validated를 검증을 진행한 메소드에는 @Valid를 선언하면 된다.</p>

<p>@Valid와 @Validated는 동작원리의 차이로 발생하는 예외가 달라진다는 것을 기억하자.</p>

<h3 id="validated의-또-다른-기능">@Validated의 또 다른 기능</h3>

<p>@Validated의 또 다른 기능은 그룹 지정 기능이다. (거의 사용하지 않는다. 이런게 있다 정도로 이해하자.)</p>

<p>예를 들어 일반 사용자의 요청과 관리자의 요청이 1개의 클래스로 처리될 때, 다른 제약 조건이 적용되어야 하는 경우가 있다. 동일한 클래스에 대한 제약조건이 요청에 따라 달라질 수 있는데 이처럼 <strong>제약 조건이 적용될 검증 그룹을 지정</strong>할 수 있는 기능을 @Validated가 제공한다.</p>

<p>검증 그룹을 지정하기 위해서 마커 인터페이스를 정의해야 한다. 앞선 예를 코드로 적용하면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserValidationGroup</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AdminValidationGroup</span> <span class="o">{}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p><strong>참고</strong> 마커 인터페이스
일반적인 인터페이스와 동일하지만 사실상 아무 메소드도 선언하지 않은 인터페이스를 말한다.</p>

</blockquote>

<p>그리고 해당 제약 조건이 적용될 그룹을 groups로 지정할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="cm">/* DTO의 경우 */</span>
<span class="c1">// 제약 조건이 적용될 그룹이 여러 개일 경우</span>
<span class="nd">@NotEmpty</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="o">{</span><span class="nc">UserValidationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">AdminValidationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">}</span> <span class="o">)</span> 
<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span> 

<span class="nd">@NotEmpty</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">UserValidationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> 
<span class="kd">private</span> <span class="nc">String</span> <span class="n">userId</span><span class="o">;</span> 

<span class="nd">@NotEmpty</span><span class="o">(</span><span class="n">groups</span> <span class="o">=</span> <span class="nc">AdminValidationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> 
<span class="kd">private</span> <span class="nc">String</span> <span class="n">adminId</span><span class="o">;</span>

<span class="cm">/* Controller의 경우 */</span>
<span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"members/new"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">create</span><span class="o">(</span><span class="nd">@Validated</span><span class="o">(</span><span class="nc">UserValidationGroup</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="nc">MemberForm</span> <span class="n">form</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="다양한-제약-조건-어노테이션">다양한 제약 조건 어노테이션</h2>

<p>JSR 표준 스펙은 다양한 제약 조건 어노테이션을 제공한다.</p>

<ul>
  <li>@NotNull: null이 아닌지 검증한다.</li>
  <li>@NotEmpty: null, 빈 스트링(””)이 아닌지 검증한다.</li>
  <li>@NotBlank: null, 빈 스트링(””), 공백(” “)이 아닌지 검증한다.</li>
  <li>@AssertTrue: true인지 검증한다.</li>
  <li>@Size: 값이 주어진 값 사이에 해당하는지 검증한다.</li>
  <li>@Min: 값이 주어진 값보다 작은지 검증한다.</li>
  <li>@Max: 값이 주어진 값보다 큰지 검증한다.</li>
  <li>@Pattern: 값이 주어진 패턴과 일치하는지 검증한다.</li>
</ul>

<p>이것 외에도 다양한 어노테이션을 지원하므로 공식 문서(<a href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html">링크</a>)를 참고하자.</p>

<h2 id="valid-validated-차이">@Valid, @Validated 차이</h2>

<p><strong>@Valid</strong>는 자바 표준 스펙이며 컨트롤러에서만 유효성 검증이 가능하다. 유효성 검증에 실패하면 MethodArgumentNotValidException이 발생한다.</p>

<p><strong>@Validated</strong>는 자바 표준 스펙이 아닌 스프링 프레임워크가 제공하는 기능이다. 계층에 무관하게 스프링 빈이라면 유효성 검증을 진행할 수 있다. 클래스에는 @Validated를 메서드에는 @Valid를 붙여준다. 유효성 검증에 실패하면 ConstraintViolationException이 발생한다.</p>]]></content><author><name>노승미</name></author><category term="Spring" /><category term="Spring" /><summary type="html"><![CDATA[@Valid]]></summary></entry><entry><title type="html">Mock 이란?</title><link href="http://localhost:4000/testcode/TESTCODE-Mock/" rel="alternate" type="text/html" title="Mock 이란?" /><published>2023-01-24T00:00:00+09:00</published><updated>2023-01-24T12:00:00+09:00</updated><id>http://localhost:4000/testcode/TESTCODE-Mock</id><content type="html" xml:base="http://localhost:4000/testcode/TESTCODE-Mock/"><![CDATA[<h2 id="mock-이란">Mock 이란?</h2>

<p><code class="language-plaintext highlighter-rouge">가짜</code>를 뜻한다. 진짜 객체와 비슷하게 동작하지만 프로그래머가 직접 그 <strong>객체의 행동을 관리</strong>하는 객체이다.</p>

<p>메소드가 return을 하기까지 어떠한 로직을 걸치는데 그 로직을 전부 구현하기에는 무리가 있을 때, 메소드가 return 하는 타입의 어떤 예측한 값이 나온다고 가정해서 전체적인 흐름을 테스트 할 때, mock이 사용된다.</p>

<h2 id="mockito-란">Mockito 란?</h2>

<p>Mock을 다루는 프레임워크의 종류로 Mock 객체를 쉽게 만들고 검증할 수 있는 방법을 제공한다.</p>

<p>유닛 테스트를 위한 Java Mocking Framework. Mockito를 사용하면 대부분의 로직을 검증 할 수 있다.</p>

<blockquote>
  <p><strong>참고</strong> Unit 테스트를 해야하는가?
controller 테스트를 하기 위해 나머지 service 와 repository 를 목(mock)으로 만들고 유닛테스트를 진행해야하는가에 대해 의견이 서로 다르다. 그냥 같이 일하는 팀에 맞추면 된다.</p>

</blockquote>

<h3 id="dependency-추가">dependency 추가</h3>

<p>스프링부트는 프로젝트 생성 시 <code class="language-plaintext highlighter-rouge">spring-boot-starter-test</code>에서 자동으로 mockito를 추가해 준다. 만약, 스프링부트를 쓰지 않으면 의존성 직접 추가하자.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c">&lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.mockito<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>mockito-core<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.12.4<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.mockito<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>mockito-junit-jupiter<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.12.4<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="mock을-사용하는-이유">Mock을 사용하는 이유</h2>

<p>Mock을 사용하는 이유를 설명하기 위해 StudyService를 테스트하는 테스트 코드를 작성한다고 가정하자.</p>

<ul>
  <li>StudyService에는 MemberService와 StudyRepository가 주입되어 있다.</li>
  <li>MemberService와 StudyRepository는 <code class="language-plaintext highlighter-rouge">인터페이스</code>이고 구현체가 정의되어 있지 않다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberService</span> <span class="o">{</span>

    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">StudyRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Study</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StudyRepository</span> <span class="n">repository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">StudyService</span><span class="o">(</span><span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">,</span> <span class="nc">StudyRepository</span> <span class="n">repository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">memberService</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">assert</span> <span class="n">repository</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">memberService</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">repository</span> <span class="o">=</span> <span class="n">repository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Study</span> <span class="nf">createNewStudy</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">Study</span> <span class="n">study</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
        <span class="n">study</span><span class="o">.</span><span class="na">setOwner</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span>
                <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Member doesn't exist for id: '"</span> <span class="o">+</span> <span class="n">memberId</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)));</span>
        <span class="k">return</span> <span class="n">repository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이제 StudyService에 대한 테스트 코드를 작성하겠다. 그런데, StudyService를 정의하는 순간부터 막힌다. StudyService는 MemberService, StudyRepository가 있어야 만들 수 있다.</p>

<p>하지만, MemberService, StudyRepository는 인터페이스이기 때문에 Mock 없이 테스트 코드를 작성한다면 오버라이드된 모든 메서드들을 정의하여 사용해야 한다.</p>

<p><strong>Mock 없이 테스트 코드를 작성</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createStudyService</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberService</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">};</span>
        
    <span class="nc">StudyRepository</span> <span class="n">studyRepository</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyRepository</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Study</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Study</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Sort</span> <span class="n">sort</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="o">...</span> <span class="c1">// 이하 생략.</span>
    <span class="o">};</span>
        
    <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Mock을 사용하면 구현체가 없어도 목 객체를 주입하여 사용할 수 있다.</p>

<p><strong>Mock을 사용하여 테스트 코드 작성</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Mock</span>
    <span class="nc">StudyRepository</span> <span class="n">studyRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">createStudyService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 생성자 주입</span>
        <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="mock-객체-만들기">Mock 객체 만들기</h2>

<p>구현체는 없지만 <strong>인터페이스</strong>는 있을때 <code class="language-plaintext highlighter-rouge">목(Mock)</code>을 작성하기 매우 좋다. 코드가 제대로 동작하는지 확인하려면 <code class="language-plaintext highlighter-rouge">목킹</code>을 하면 된다.</p>

<p><strong>[방법1] Mockito.mock() 메소드 사용</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">StudyRepository</span> <span class="n">studyRepository</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">StudyRepository</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>[방법2] 목 애노테이션 사용</strong></p>

<ul>
  <li>JUnit5 extension으로 <code class="language-plaintext highlighter-rouge">MockitoExtension</code>을 사용한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Mock</span>
    <span class="nc">StudyRepository</span> <span class="n">studyRepository</span><span class="o">;</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="mock-객체-stubbing">Mock 객체 Stubbing</h2>

<p><code class="language-plaintext highlighter-rouge">Stubbing</code>이란 <strong>행동을 조작</strong>하는 것을 말한다. Mock 인스턴스에게 실제 메서드를 호출한 것과 같은 <strong>가짜 동작</strong>을 넣어줄  수 있다.</p>

<h3 id="mock-객체-조작-stubbing">Mock 객체 조작 (Stubbing)</h3>

<ol>
  <li>특정한 매개변수를 받은 경우 특정한 값을 리턴하거나 예외를 던지도록 만들 수 있다.</li>
  <li>void 메소드 특정 매개변수를 받거나 호출된 경우 예외를 발생 시킬 수 있다.</li>
  <li>메소드가 동일한 매개변수로 여러번 호출될 때 각기 다르게 행동하도록 조작할 수도 있다.</li>
</ol>

<h3 id="whenthenreturn">when().thenReturn()</h3>

<p><strong>A를 호출하면 B를 반환하겠다</strong>고 행동을 조작한 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Mock</span>
    <span class="nc">StudyRepository</span> <span class="n">studyRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">createNewStudy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

        <span class="c1">// stubbing (조작)</span>
        <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
<span class="c1">//        when(memberService.findById(2L)).thenReturn(Optional.of(member));</span>

        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">findById</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">,</span> <span class="n">findById</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>when(memberService.findById(<strong>1L</strong>)).thenReturn(Optional.of(member)); 이 코드는 1L에 대해서만 유효하다. 만약 다른 파라미터 값을 넣으면 오류가 발생할 것이다. 이때 사용할 수 있는게 any() 이다.</p>

<h3 id="any">any()</h3>

<p><code class="language-plaintext highlighter-rouge">any()</code>는 어떠한 값을 파라미터로 넣어도 무조건 Optional.of(member)를 반환 받는다. 즉, any()로 정의하면 파라미터 1L으로 호출하던, 2L으로 호출하던 같은 객체를 받게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createNewStudy</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

    <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>

    <span class="n">assertEquals</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">,</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">).</span><span class="na">get</span><span class="o">().</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">,</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">2L</span><span class="o">).</span><span class="na">get</span><span class="o">().</span><span class="na">getEmail</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>any()와 같이 이러한 작업을 하는 요소를 Argument matchers라 한다.</p>

<h3 id="dothrowwhen">doThrow().when()</h3>

<p>예외를 던지고 싶을때 doThrow() 메소드를 활용한다.</p>

<ol>
  <li>
    <p>반환형이 있는 경우</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre> <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">thenThrow</span><span class="o">(</span><span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">());</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>반환형이 void 인 경우</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> <span class="c1">// memberService의 validate()가 호출되면 IllegalArgumentException 예외를 던지겠다.</span>
 <span class="n">doThrow</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">()).</span><span class="na">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">validate</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
 <span class="n">assertThrows</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="n">memberService</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
 <span class="o">});</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ol>

<h3 id="여러번-stubbing-할-때-다르게-조작">여러번 stubbing 할 때, 다르게 조작</h3>

<p>호출되는 순서가 지정되어 있어 같은 매개변수라도 매번 다른 값을 행동하도록 조작할 수 있다. 체이닝 기법을 이용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createNewStudyException2</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

    <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">any</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">))</span> <span class="c1">// 첫번째 조작</span>
            <span class="o">.</span><span class="na">thenThrow</span><span class="o">(</span><span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">())</span> <span class="c1">// 두번째 조작</span>
            <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">());</span> <span class="c1">// 세번째 조작</span>

    <span class="c1">// 첫번째 조작에 대한 테스트</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">byId</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">,</span> <span class="n">byId</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getEmail</span><span class="o">());</span>

    <span class="c1">// 두번째 조작에 대한 테스트</span>
    <span class="n">assertThrows</span><span class="o">(</span><span class="nc">RuntimeException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="o">});</span>

    <span class="c1">// 세번째 조작에 대한 테스트</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">(),</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">));</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="mock-객체-검증">Mock 객체 검증</h2>

<p>createNewStudy에서 study가 저장되면 memberService.notify()를 호출한다고 가정하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">notify</span><span class="o">(</span><span class="nc">Study</span> <span class="n">newStudy</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StudyRepository</span> <span class="n">repository</span><span class="o">;</span>

    <span class="o">...</span>

    <span class="kd">public</span> <span class="nc">Study</span> <span class="nf">createNewStudy</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">Study</span> <span class="n">study</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>

        <span class="n">study</span><span class="o">.</span><span class="na">setOwner</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span>
                <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Member doesn't exist for id: '"</span> <span class="o">+</span> <span class="n">memberId</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)));</span>

        <span class="nc">Study</span> <span class="n">newStudy</span> <span class="o">=</span> <span class="n">repository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

        <span class="c1">// study가 저장되면 알림이 오도록 설정</span>
        <span class="n">memberService</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="n">newStudy</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">newStudy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>사실 notify에 대한 테스트 코드를 작성하기 애매하다. 이럴 때 verify()를 사용한다.</p>

<h3 id="verify">verify()</h3>

<p><code class="language-plaintext highlighter-rouge">verify()</code>는 Mock 객체의 메서드 <strong>호출에 대해서 확인 및 검증</strong> 할 수 있는 메서드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createNewStudyTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

    <span class="nc">Study</span> <span class="n">study</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Study</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="s">"테스트"</span><span class="o">);</span>

    <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
    <span class="n">when</span><span class="o">(</span><span class="n">studyRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

    <span class="n">studyService</span><span class="o">.</span><span class="na">createNewStudy</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">study</span><span class="o">);</span>

    <span class="n">assertEquals</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="n">study</span><span class="o">.</span><span class="na">getOwner</span><span class="o">());</span>

    <span class="c1">// memberService의 notify가 1번 호출되어야 한다.</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">(</span><span class="n">any</span><span class="o">());</span>
    <span class="c1">// memberService의 validate가 호출되면 안된다.</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">never</span><span class="o">()).</span><span class="na">validate</span><span class="o">(</span><span class="n">any</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="inorder">InOrder</h3>

<p>순서대로 호출되는지 확인하고 싶을 때 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">notify</span><span class="o">(</span><span class="nc">Study</span> <span class="n">newStudy</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">notify</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StudyRepository</span> <span class="n">repository</span><span class="o">;</span>

    <span class="o">...</span>

    <span class="kd">public</span> <span class="nc">Study</span> <span class="nf">createNewStudy</span><span class="o">(</span><span class="nc">Long</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">Study</span> <span class="n">study</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>

        <span class="n">study</span><span class="o">.</span><span class="na">setOwner</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span>
                <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Member doesn't exist for id: '"</span> <span class="o">+</span> <span class="n">memberId</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)));</span>

        <span class="nc">Study</span> <span class="n">newStudy</span> <span class="o">=</span> <span class="n">repository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

        <span class="c1">// study가 저장되면 알림이 오도록 설정</span>
        <span class="n">memberService</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="n">newStudy</span><span class="o">);</span>
        <span class="n">memberService</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

        <span class="k">return</span> <span class="n">newStudy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createNewStudyTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

    <span class="nc">Study</span> <span class="n">study</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Study</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="s">"테스트"</span><span class="o">);</span>

    <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
    <span class="n">when</span><span class="o">(</span><span class="n">studyRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

    <span class="n">studyService</span><span class="o">.</span><span class="na">createNewStudy</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">study</span><span class="o">);</span>

    <span class="n">assertEquals</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="n">study</span><span class="o">.</span><span class="na">getOwner</span><span class="o">());</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">never</span><span class="o">()).</span><span class="na">validate</span><span class="o">(</span><span class="n">any</span><span class="o">());</span>

    <span class="c1">// 순서 확인</span>
    <span class="nc">InOrder</span> <span class="n">inOrder</span> <span class="o">=</span> <span class="n">inOrder</span><span class="o">(</span><span class="n">memberService</span><span class="o">);</span>
    <span class="n">inOrder</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">notify</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>
    <span class="n">inOrder</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">notify</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>memberService.notify(study)가 먼저 호출된 후, memberService.notify(member)가 호출되는 지 확인하는 테스트 코드이다.</p>

<h3 id="특정-시간-이내에-호출됐는지">특정 시간 이내에 호출됐는지</h3>

<p>거의 사용하지 않음..</p>

<p>100s안에 memberService의 notify()가 1번 호출되어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">timeout</span><span class="o">(</span><span class="mi">100</span><span class="o">).</span><span class="na">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="verifynomoreinteractions">verifyNoMoreInteractions</h3>

<p>모든 verify() 검증이 끝났다면 안정성을 위해 verifyNoMoreInteractions()을 호출할 수 있다.</p>

<p>verifyNoMoreInteractions()는 Mock 인스턴스의 메서드를 더 이상 verify() 검증할 필요가 없다는 뜻이다. 더 이상 검증할 것이 남아있지 않을 때 성공을 리턴하고 검증할 내용이 있다면 테스트에 실패하게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">verifyNoMoreInteractions</span><span class="o">(</span><span class="n">memberService</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="bdd-스타일-mockito-api">BDD 스타일 Mockito API</h2>

<h3 id="bdd">BDD</h3>

<p>애플리케이션이 어떻게 <code class="language-plaintext highlighter-rouge">행동</code>해야 하는지에 대한 공통된 이해를 구성하는 방법으로, TDD에서 창안했다.</p>

<ul>
  <li>Given / When / Then</li>
</ul>

<p>앞서 작성했던 테스트 코드 스타일도 Given / When / Then을 사용했다. 그런데, mock을 사용하면서 약간은 애매한 부분이 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>
    <span class="nd">@Mock</span> <span class="nc">StudyRepository</span> <span class="n">studyRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">createNewStudy</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Given</span>
        <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"yessm621@gmail.com"</span><span class="o">);</span>

        <span class="nc">Study</span> <span class="n">study</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Study</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="s">"테스트"</span><span class="o">);</span>

        <span class="c1">// 1</span>
        <span class="n">when</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
        <span class="n">when</span><span class="o">(</span><span class="n">studyRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

        <span class="c1">// When</span>
        <span class="n">studyService</span><span class="o">.</span><span class="na">createNewStudy</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">study</span><span class="o">);</span>

        <span class="c1">// Then</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="n">study</span><span class="o">.</span><span class="na">getOwner</span><span class="o">());</span>
        <span class="c1">// 2</span>
        <span class="n">verify</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>
        <span class="n">verifyNoMoreInteractions</span><span class="o">(</span><span class="n">memberService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>1, 2 번은 메서드 이름 때문인지 given, when, then과 맞지 않아보인다. 이때 Mockito는 <code class="language-plaintext highlighter-rouge">BddMockito</code>라는 클래스를 통해 BDD 스타일의 API를 제공한다.</p>

<ul>
  <li>when().thenReturn() → given().willReturn()</li>
  <li>verify() → then().should()</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">mockito</span><span class="o">.</span><span class="na">BDDMockito</span><span class="o">.</span><span class="na">given</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">mockito</span><span class="o">.</span><span class="na">BDDMockito</span><span class="o">.</span><span class="na">then</span><span class="o">;</span>

<span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">StudyServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Mock</span> <span class="nc">StudyRepository</span> <span class="n">studyRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">createNewStudy</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Given</span>
        <span class="nc">StudyService</span> <span class="n">studyService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StudyService</span><span class="o">(</span><span class="n">memberService</span><span class="o">,</span> <span class="n">studyRepository</span><span class="o">);</span>
        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">studyService</span><span class="o">);</span>

        <span class="o">...</span>

        <span class="c1">// 1</span>
        <span class="n">given</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="mi">1L</span><span class="o">)).</span><span class="na">willReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
        <span class="n">given</span><span class="o">(</span><span class="n">studyRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">study</span><span class="o">)).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>

        <span class="c1">// When</span>
        <span class="n">studyService</span><span class="o">.</span><span class="na">createNewStudy</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">study</span><span class="o">);</span>

        <span class="c1">// Then</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="n">study</span><span class="o">.</span><span class="na">getOwner</span><span class="o">());</span>
        <span class="c1">// 2</span>
        <span class="n">then</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">should</span><span class="o">(</span><span class="n">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notify</span><span class="o">(</span><span class="n">study</span><span class="o">);</span>
        <span class="n">then</span><span class="o">(</span><span class="n">memberService</span><span class="o">).</span><span class="na">shouldHaveNoMoreInteractions</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Mockito 레퍼런스</strong></p>

<p><a href="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html">Mockito - mockito-core 4.4.0 javadoc</a></p>]]></content><author><name>노승미</name></author><category term="TestCode" /><category term="TestCode" /><category term="JAVA" /><summary type="html"><![CDATA[Mock 이란?]]></summary></entry><entry><title type="html">정적 팩토리 메서드</title><link href="http://localhost:4000/designpattern/DesignPattern-StaticFactoryMethod/" rel="alternate" type="text/html" title="정적 팩토리 메서드" /><published>2023-01-19T00:00:00+09:00</published><updated>2023-01-19T19:20:00+09:00</updated><id>http://localhost:4000/designpattern/DesignPattern-StaticFactoryMethod</id><content type="html" xml:base="http://localhost:4000/designpattern/DesignPattern-StaticFactoryMethod/"><![CDATA[<h2 id="정적-팩토리-메서드란">정적 팩토리 메서드란?</h2>

<p>정적(static), 팩토리(factory), 메서드(method)</p>

<p>여기서 팩토리라는 용어가 조금 생소할 수 있다. GoF 디자인 패턴 중 팩토리 패턴에서 유래한 이 단어는 객체를 생성하는 역할을 분리하겠다는 취지가 담겨있다.</p>

<p>다시 말해, 정적 팩토리 메서드란 객체 생성의 역할을 하는 클래스 메서드라는 의미로 요약할 수 있다.</p>

<p>자바에서 객체를 생성할 때 new 키워드를 사용한다. 정적 팩토리 메서드는 new를 직접적으로 사용하지 않을 뿐, 정적 팩토리 메서드라는 클래스 내에 선언되어있는 메서드를 내부의 new를 이용해 객체를 생성해 반환하는 것이다. 즉, 정적 팩토리 메서드를 통해 new를 간접적으로 사용한다.</p>

<p><strong>생성자를 통한 객체 생성(new 사용)</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>정적 팩토리 메서드를 통한 객체 생성</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>두 경우 모두 String 타입 객체를 반환해준다.</p>

<h2 id="생성자와-정적-패토리-메서드">생성자와 정적 패토리 메서드</h2>

<p>생성자를 통해 객체를 생성하는 방식과 정적 팩토리 메서드로 객체를 만드는 방식이 하는 일은 비슷해보인다. 하지만 다른 점이 있다.</p>

<h3 id="정적-팩토리-메서드-장점">정적 팩토리 메서드 장점</h3>

<ol>
  <li>이름을 가질 수 있다.
    <ul>
      <li>정적 팩토리 메서드를 사용하면 메서드 네이밍에 따라 반환될 객체의 특성을 묘사할 수 있다. 즉, 코드의 가독성이 상승한다.</li>
    </ul>
  </li>
  <li>호출할 때 마다 새로운 객체를 생성할 필요가 없다.
    <ul>
      <li>enum이 대표적인 예시이다.</li>
      <li>사용되는 값들의 개수가 정해져 있으면 해당 값을 미리 생성해놓고 조회(캐싱) 할 수 있는 구조로 만들 수 있다.</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Day</span> <span class="o">{</span>
    
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Day</span><span class="o">&gt;</span> <span class="n">days</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    
     <span class="kd">static</span> <span class="o">{</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mon"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Monday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"tue"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Tuesday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"wen"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Wednesday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"thu"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Thursday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"fri"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Friday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"sat"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Saturday"</span><span class="o">));</span>
         <span class="n">days</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"sun"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Day</span><span class="o">(</span><span class="s">"Sunday"</span><span class="o">));</span>
     <span class="o">}</span>
    
     <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Day</span> <span class="nf">from</span><span class="o">(</span><span class="nc">String</span> <span class="n">day</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">days</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">day</span><span class="o">);</span>
     <span class="o">}</span>
    
     <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">day</span><span class="o">;</span>
    
     <span class="kd">private</span> <span class="nf">Day</span><span class="o">(</span><span class="nc">String</span> <span class="n">day</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">day</span> <span class="o">=</span> <span class="n">day</span><span class="o">;</span>
     <span class="o">}</span>
    
     <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getDay</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">day</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">Day</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Day</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">"mon"</span><span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">day</span><span class="o">.</span><span class="na">getDay</span><span class="o">());</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <ul>
      <li>각 요일을 static을 통해 미리 생성. 미리 생성된 Day 객체를 찾아 반환만 하면 된다.</li>
    </ul>
  </li>
  <li>하위 자료형 객체를 반환할 수 있다.
    <ul>
      <li>상속을 사용 할 때 확인 할 수 있다. 정적 팩토리 메서드가 반환값을 반환할 때, 상황에 따라 하위 클래스 타입의 객체를 반환 해줄 수 있다.</li>
    </ul>
  </li>
  <li>입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    <ul>
      <li>반환 타입의 하위 타입이기만 하면 어느 타입이든 객체를 반환해도 상관없다.</li>
      <li>만약, 특정 인터페이스들을 상속 받은 구현체들이 있을 때, 객체 생성 시 상황에 따라서 유동적으로 해당하는 구현체 타입으로 반환 한다고 생각 됨</li>
    </ul>
  </li>
  <li>정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</li>
</ol>

<h3 id="정적-팩토리-메서드의-단점">정적 팩토리 메서드의 단점</h3>

<ul>
  <li>상속에는 public 혹은 protected 생성자가 필요하므로 정적 팩토리 메서드만 제공할 경우, 상속이 불가능하다.</li>
  <li>정적 팩토리 메서드를 다른 개발자들이 찾기 어렵다. → 정적 팩토리 메서드 컨벤션, API 문서를 잘 작성하면 해결할 수 있다.</li>
</ul>

<h2 id="lombok으로-정적-팩토리-메서드-정의">Lombok으로 정적 팩토리 메서드 정의</h2>

<p>Lombok의 RequiredArgsConstructor를 사용하면 정적 팩토리 메서드를 쉽게 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nd">@RequiredArgsConstructor</span><span class="o">(</span><span class="n">staticName</span> <span class="o">=</span> <span class="s">"of"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="nc">Order</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name>노승미</name></author><category term="DesignPattern" /><category term="DesignPattern" /><category term="Java" /><summary type="html"><![CDATA[정적 팩토리 메서드란?]]></summary></entry><entry><title type="html">연관관계 편의 메서드</title><link href="http://localhost:4000/jpa/JPA-Convenience-Method/" rel="alternate" type="text/html" title="연관관계 편의 메서드" /><published>2023-01-15T00:00:00+09:00</published><updated>2023-01-16T02:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA-Convenience-Method</id><content type="html" xml:base="http://localhost:4000/jpa/JPA-Convenience-Method/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">연관관계 편의 메서드</code>는 <strong>양방향 연관관계</strong>일 경우에 해당된다.</p>

<p>연관관계 편의 메서드에 설명하기 위해 Member 객체와 Order 객체가 있고 이 둘은 양방향 연관관계라고 가정하자. Order 입장에선 다대일 관계이고 Member 입장에선 일대다 관계이다.</p>

<p>양방향 연관관계의 경우 각각 객체에 다른 객체를 참조할 수 있는 참조용 필드를 정의한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="c1">// Member 엔티티</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"member_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="o">...</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>

<span class="c1">// Order 엔티티</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="no">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"member_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>양방향 연관관계는 양 쪽 객체를 모두 신경써야 한다. 만약, Member 객체와 Order 객체를 저장한다고 하면 아래 코드와 같이 입력해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
<span class="n">order</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"order"</span><span class="o">)</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"memberA"</span><span class="o">);</span>

<span class="c1">// 양방향 연관관계 시 양쪽에 연관관계 설정</span>
<span class="n">member</span><span class="o">.</span><span class="na">getOrders</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
<span class="n">order</span><span class="o">.</span><span class="na">setMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>JPA 입장에서는 연관관계 설정을 위해 주인 쪽에만 연관관계를 설정하면 된다. 하지만, 객체 입장에서 보면 양쪽에 연관관계를 모두 넣어주는게 좋다. 따라서, 순수 객체 상태를 고려하여 항상 <strong>양쪽</strong>에 값을 넣어주자.</p>

<p>하지만, 개발을 하다보면 까먹는 경우가 생길 수 밖에 없다. 따라서, <code class="language-plaintext highlighter-rouge">연관관계 편의 메서드</code>(createMember())를 새로 정의하여 한번만 호출해도 두 줄의 코드를 수행할 수 있게 만든다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">createMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">;</span>
    <span class="n">member</span><span class="o">.</span><span class="na">getOrders</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 여기서 this는 현재 인스턴스를 의미한다.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p><strong>참고</strong> 
연관관계 편의 메서드를 정의하는 곳은 핵심 로직을 가진 쪽에 정의하는 것이 좋다.</p>

</blockquote>

<blockquote>
  <p><strong>참고</strong> 연관관계 편의 메서드 삭제
양방향 연관관계인 경우 삭제할 때도 연관관계 편의 메서드를 만들어야 할까? 이론적인 관점에서 보면 삭제를 위한 연관관계 편의 메서드를 정의하는 것이 맞으나 실용적인 관점에서 생각하면 삭제한 이후 삭제한 객체를 활용하는 로직이 대부분 없기 때문에 편의 메서드는 생략해도 상관없다.
또한, 실무에선 삭제를 하는 경우는 거의 없고 삭제 yn 필드를 변경하는 방식을 사용하기 때문에 이러한 고민을 크게 하지 않는다.</p>

</blockquote>]]></content><author><name>노승미</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[연관관계 편의 메서드는 양방향 연관관계일 경우에 해당된다.]]></summary></entry><entry><title type="html">연관 관계 매핑</title><link href="http://localhost:4000/jpa/JPA-JPA-Mapping/" rel="alternate" type="text/html" title="연관 관계 매핑" /><published>2023-01-15T00:00:00+09:00</published><updated>2023-01-16T01:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA-JPA-Mapping</id><content type="html" xml:base="http://localhost:4000/jpa/JPA-JPA-Mapping/"><![CDATA[<p>연관 관계를 매핑할 때 생각해야 할 것 3가지</p>

<ol>
  <li>방향: 단방향, 양방향</li>
  <li>연관 관계의 주인: 양방향일 때, 연관 관계에서 관리 주체</li>
  <li>다중성: 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)</li>
</ol>

<h2 id="단방향-양방향">단방향, 양방향</h2>

<p>DB 테이블은 <strong>외래 키</strong> 하나로 양 쪽 테이블 조인이 가능하다. 따라서, DB는 단방향, 양방향을 나눌 필요가 없다.</p>

<p>그러나, 객체는 <strong>참조용 필드</strong>가 있는 객체만 다른 객체를 참조하는 것이 가능하다. 따라서, 한쪽만 참조하면 <code class="language-plaintext highlighter-rouge">단방향</code> 관계, 양쪽이 서로 참조하면 <code class="language-plaintext highlighter-rouge">양방향</code> 관계이다. 엄밀하게 말하면 양방향 관계는 없고 두 객체가 단방향 참조를 각각 가져서 양방향 관계처럼 사용하고 말하는 것이다.</p>

<p>JPA를 사용해서 DB와의 <strong>패러다임</strong>을 맞추기 위해서 객체는 단방향 연관 관계를 가질지, 양방향 연관 관계를 가질지 선택해야 한다.</p>

<p>선택은 비즈니스 로직에서 두 객체가 참조가 필요한지 여부를 고민하면 된다. 비즈니스 로직에 맞게 선택했을 때 두 객체가 서로 단방향 참조를 했다면 양방향 연관 관계가 된다.</p>

<h3 id="무조건-양방향-관계로-하면-좋을까">무조건 양방향 관계로 하면 좋을까?</h3>

<p>객체 입장에서 양방향 매칭을 했을 때 오히려 복잡해진다. 예를 들어 일반적인 비스니스 애플리케이션에서 User 엔티티는 다양한 엔티티와 연관 관계를 갖는다. 이런 경우 모든 엔티티를 양방향으로 설정하면 User 클래스가 복잡해지고, 불필요한 연관 관계 매핑으로 인해 <strong>복잡성</strong>이 증가할 수 있다. 따라서, 양방향으로 할지 단방향으로 할지 구분해줘야 한다.</p>

<p>기본적으로 <strong>단방향 매핑으로 설계</strong>하고 추후에 역방향 객체 탐색이 <strong>필요하면 추가</strong>하는 것이 좋다.</p>

<h2 id="연관-관계의-주인자세한-내용">연관 관계의 주인<a href="https://yessm621.github.io/jpa/JPA-MappedBy/">(자세한 내용)</a></h2>

<p>양방향 연관 관계의 경우 <code class="language-plaintext highlighter-rouge">연관 관계의 주인</code>을 정해야 한다. 연관 관계의 주인을 지정하는 것은 두 단방향 관계 중 <strong>제어의 권한</strong>을 갖는 실질적인 관계가 어떤 것인지 JPA에게 알려주는 것이라고 생각하면 된다.</p>

<p>연관 관계의 주인은 연관 관계를 갖는 두 객체 사이에서 조회, 저장, 수정, 삭제를 할 수 있지만, 연관 관계의 주인이 아니면 조회만 가능하다. 연관 관계의 주인이 아닌 객체에서 mappedBy 속성을 사용해서 주인을 지정해줘야 한다. 보통 <code class="language-plaintext highlighter-rouge">외래 키</code>가 있는 곳을 <strong>연관 관계의 주인</strong>으로 정한다.</p>

<h3 id="왜-연관-관계의-주인을-정해야할까">왜 연관 관계의 주인을 정해야할까?</h3>

<p>예를 들어 Member 객체와 Order 객체가 있고 양방향 연관 관계라고 가정하자.</p>

<p>사용자의 주문을 수정하려고 할 때 Member 객체에서 setOrder() 같은 메서드를 이용해서 수정하는게 좋을지 Order 객체에서 getMember() 같은 메서드를 이용해서 수정하는게 좋은지 헷갈릴 수 있다.</p>

<p>두 객체 입장에서는 두 방법 다 맞는 방법이지만, JPA 입장에서는 혼란이 온다. 즉, Member에서 Order를 수정할때 FK를 수정할 지, Order에서 Member를 수정할 때 FK를 수정할 지를 결정하기 어렵다. 때문에 두 객체 사이의 <strong>연관 관계의 주인</strong>을 정해서 명확하게 정하는 것이다.</p>

<h3 id="연관-관계의-주인만-제어하면-되나">연관 관계의 주인만 제어하면 되나?</h3>

<p>DB에 외래 키가 있는 테이블을 수정하려면 연관 관계의 주인만 변경하면 된다. 그러나, 객체를 생각했을 때는 두 군데에서 변경하는 것이 좋다. (이 부분은 <a href="https://www.notion.so/726e23bc27de4c9a8d2f7afee8ab5a18"><code class="language-plaintext highlighter-rouge">연관관계 편의 메서드</code></a>를 사용하면 편리하다.)</p>

<h2 id="다중성">다중성</h2>

<p>DB를 기준으로 다중성을 결정한다.</p>

<h3 id="다대일">다대일</h3>

<p>게시판(Post)과 게시글(Board)을 예로 들면, 게시글이 N이고 게시판이 1이다. 외래 키를 게시글이 관리하는 일반적인 형태이다.</p>

<p><strong>다대일 단방향 연관 관계</strong></p>

<p>다대일 단방향에선 다 쪽인 Post에서 @ManyToOne만 추가해줬다. 반대로 Board에서는 참조하지 않았다. (단방향)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"POST_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TITLE"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Board</span> <span class="n">board</span><span class="o">;</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>다대일 양방향 연관 관계</strong></p>

<p>다대일 양방향은 1 쪽에 @OneToMany를 추가하고 연관관계의 주인을 설정하기 위해 주인이 아닌 쪽에 mappedBy를 지정한다. mappedBy로 지정할 때 값은 대상이 되는 변수명을 따라 지정하면 된다. 여기서는 Post 객체의 board라는 이름의 변수이기 때문에 똑같이 board로 지정했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"POST_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TITLE"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Board</span> <span class="n">board</span><span class="o">;</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"board"</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">posts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="일대다">일대다</h3>

<p>일대다와 다대일은 다르다. 다대일의 기준은 연관관계의 주인 다(N)쪽에 둔 것이고 이번에 언급할 일대다의 기준은 연관관계의 주인을 1 쪽에 둔 것이다.</p>

<p><strong>일대다 단방향 연관 관계</strong></p>

<blockquote>
  <p><strong>참고</strong>
실무에서는 일대다 단방향은 거의 쓰지 않는다.</p>

</blockquote>

<p>DB 입장에서는 무조건 다쪽에서 외래키를 관리한다. 하지만 일대다 단방향은 1쪽 객체에서 다쪽 객체를 조작(생성, 수정, 삭제)하는 방법이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"POST_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TITLE"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"board"</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="n">posts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">//... getter, setter</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nc">Post</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Post</span><span class="o">();</span>
<span class="n">post</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>

<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
<span class="n">board</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="s">"Free Board"</span><span class="o">);</span>
<span class="n">board</span><span class="o">.</span><span class="na">getPosts</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>post를 저장할 때 insert 쿼리가 실행된다. 그 후 board를 저장할 때 board를 insert하는 쿼리가 나간 후에 post를 update하는 쿼리가 실행된다. board.getPosts().add(post); 부분 때문이다.</p>

<p>Board 엔티티는 Board 테이블에 매핑되기 때문에 Board 테이블에 직접 지정할 수 있으나 Post 테이블의 FK를 저장할 방법이 없으므로 조인 및 업데이트 쿼리를 날려야 하는 문제가 있다.</p>

<p>따라서, 일대다 단방향은 다대일 양방향 연관 관계로 매핑하는 것이 추후에 유지보수에 훨씬 수월하다.</p>

<p>일대다 양방향 연관 관계는 공식적으로 존재하지 않는다. 결론은 일대다 단방향, 양방향을 사용할 거면 <code class="language-plaintext highlighter-rouge">다대일 양방향</code>을 사용하는 것이 맞다.</p>

<h3 id="일대일">일대일</h3>

<p>주 테이블에 외래키를 넣을 수도 있고 대상 테이블에 외래키를 넣을 수도 있다. (일대일이기 때문에 테이블 A, B가 있을때 주 테이블이 A면 대상 테이블이 B이다.)</p>

<p>아래 예제는 Post가 하나의 Attach를 가지고 있다고 가정한다.</p>

<p><strong>일대일 단방향</strong></p>

<ol>
  <li>
    <p>외래 키를 주 테이블이 갖고 있을 때 (Post: 주 테이블, Attach: 대상 테이블)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre> <span class="nd">@Entity</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
     <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
     <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"POST_ID"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    
     <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TITLE"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
     <span class="nd">@OneToOne</span>
     <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ATTACH_ID"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">Attach</span> <span class="n">attach</span><span class="o">;</span>
     <span class="c1">//... getter,setter</span>
 <span class="o">}</span>
 <span class="nd">@Entity</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Attach</span> <span class="o">{</span>
     <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
     <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ATTACH_ID"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
     <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
   <span class="c1">//... getter, setter</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>외래 키를 대상 테이블이 갖고 있을 때: JPA에서는 지원을 하지 않는다.</p>
  </li>
</ol>

<p><strong>일대일 양방향</strong></p>

<ol>
  <li>
    <p>외래키를 주 테이블이 갖고 있을 때</p>

    <p>단순하게 똑같이 @OneToOne 설정 후 mappedBy 설정만 해서 읽기 전용으로 만들어주면 양방향도 간단하다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> <span class="nd">@Entity</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Attach</span> <span class="o">{</span>
     <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
     <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ATTACH_ID"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
     <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    
     <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"attach"</span><span class="o">)</span>
     <span class="kd">private</span> <span class="nc">Post</span> <span class="n">post</span><span class="o">;</span>
   <span class="c1">//... getter, setter</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>외래키를 대상 테이블이 갖고 있을 때</p>

    <p>이럴때는 어차피 양 쪽이 일대일이기 때문에 위에서 정의한 대로 처리하면 된다. 하지만 논란의 여지가 있다. 외래키를 Post에서 관리하는 것이 좋은 지 Attach에서 관리하는 것이 좋은 지 생각해봐야 한다.</p>

    <p>비즈니스가 변경되어 하나의 Post가 Attach를 여러개 가질 수 있다고 가정하자. 그렇다면 외래 키는 다쪽인 Attach에 있는게 비즈니스 변경에 유리하다. 그렇다고 무조건 다가 될 확률이 높은 테이블에 외래 키를 놓는 것이 좋은게 아니다. Post 쪽에 외래 키를 두면 성능상 이득이 있기 때문이다.</p>

    <p>결론은 종합적으로 판단하고 결정해야 한다.</p>
  </li>
</ol>

<h3 id="다대다">다대다</h3>

<p>실무에서 사용하면 안된다. 다대다는 일대다 - 다대일로 풀어서 만드는 것 (중간 테이블을 Entity로 만드는 것)이 추후 변경에도 유연하게 대처할 수 있다.</p>]]></content><author><name>노승미</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[연관 관계를 매핑할 때 생각해야 할 것 3가지]]></summary></entry><entry><title type="html">JUnit Assertions, AssertJ</title><link href="http://localhost:4000/testcode/TESTCODE-Junit-AssertJ/" rel="alternate" type="text/html" title="JUnit Assertions, AssertJ" /><published>2023-01-12T00:00:00+09:00</published><updated>2023-01-12T22:45:00+09:00</updated><id>http://localhost:4000/testcode/TESTCODE-Junit-AssertJ</id><content type="html" xml:base="http://localhost:4000/testcode/TESTCODE-Junit-AssertJ/"><![CDATA[<h2 id="junit-assertions와-assertj">JUnit Assertions와 AssertJ</h2>

<p>테스트 코드를 작성할 때 사용하는 Assertions는 <code class="language-plaintext highlighter-rouge">JUnit</code>이 구현한 클래스도 있고 <code class="language-plaintext highlighter-rouge">AssertJ</code>의 Assertions가 있다.</p>

<p>JUnit에서 제공하는 공식 기능인 Jupiter보다 <strong>AssertJ를 선호</strong>하는데 그 이유는 무엇일까?</p>

<h3 id="jupiter의-단점">Jupiter의 단점</h3>

<p>공식 가이드에서 제공하는 메서드를 보면 단순하다. 기대값과 실제값을 넣고 일치하는지, 아니면 조건이 True 인지 False 만 판단하는 기능만 구성되어 있다. 무엇을 검사하는지 파악하기 힘들다.</p>

<p>또한, 메서드 체이닝이 없어서 AssertJ에 비해 사용하기 불편하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">// JUnit</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">actual</span><span class="o">);</span>
<span class="c1">// AssertJ (메서드 체이닝)</span>
<span class="n">assertThat</span><span class="o">(</span><span class="n">actual</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">expected</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="assertj-란">AssertJ 란?</h2>

<p><strong>테스트</strong>에 관련된 많은 기능을 제공하고 가독성이 높은 테스트 코드 작성을 지원하는 오픈 라이브러리이다.</p>

<p>JUnit의 Assertions와 같은 클래스 명을 가지므로 <strong>주의해서 import</strong> 해야 한다.</p>

<ul>
  <li>JUnit Assertions → <code class="language-plaintext highlighter-rouge">import org.junit.jupiter.api.Assertions;</code></li>
  <li>AssertJ → <code class="language-plaintext highlighter-rouge">import org.assertj.core.api.Assertions;</code></li>
</ul>

<p>assertThat(검증 대상)로 시작하며 메서드 체이닝을 이용하여 검증 메서드를 연쇄적으로 사용할 수 있다.</p>

<blockquote>
  <p><strong>참고</strong> 메서드 체이닝
<br />
말 그대로 메소드를 고리처럼 엮어서 메소드를 계속해서 사용할 수 있게끔 하는 방법이다.</p>

</blockquote>]]></content><author><name>노승미</name></author><category term="TestCode" /><category term="TestCode" /><category term="JAVA" /><summary type="html"><![CDATA[JUnit Assertions와 AssertJ]]></summary></entry><entry><title type="html">@BeforeEach, @BeforeAll 차이</title><link href="http://localhost:4000/testcode/TESTCODE-BeforeAll-BeforeEach/" rel="alternate" type="text/html" title="@BeforeEach, @BeforeAll 차이" /><published>2023-01-12T00:00:00+09:00</published><updated>2023-01-12T20:15:00+09:00</updated><id>http://localhost:4000/testcode/TESTCODE-BeforeAll-BeforeEach</id><content type="html" xml:base="http://localhost:4000/testcode/TESTCODE-BeforeAll-BeforeEach/"><![CDATA[<p>@BeforeEach, @BeforeAll 애노테이션은 JUnit5에서 나온 애노테이션들이다.</p>

<p>@BeforeEach, @BeforeAll 애노테이션을 사용하려면 dependency에 아래 라이브러리를 추가해야 한다.</p>

<p>build.gradle</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>testImplementation('org.junit.jupiter:junit-jupiter:5.5.0')
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="beforeeach">@BeforeEach</h2>

<p>@BeforeEach는 각각의 테스트 메소드가 실행될 때 호출되는 메소드이다. 각각의 메소드가 실행 전에 호출되어 처리된다.</p>

<ul>
  <li>리턴 타입으로는 반드시 void</li>
  <li>접근 제한자로 pirvate 사용 금지</li>
  <li>static으로 선언 금지</li>
</ul>

<blockquote>
  <p><strong>참고</strong> @AfterEach 애노테이션
각각의 테스트 메소드가 실행된 후 종료되어야 할 리소스를 처리하는 부분으로 사용된다.</p>

</blockquote>

<h2 id="beforeall">@BeforeAll</h2>

<p>@BeforeAll은 모든 테스트 메소드가 실행되기 전에 한 번 실행된다.</p>

<ul>
  <li>리턴 타입으로는 반드시 void</li>
  <li>접근 제한자로 pirvate 사용 금지</li>
  <li>반드시 static으로 선언</li>
</ul>

<blockquote>
  <p><strong>참고</strong> @AfterAll 애노테이션
모든 테스트 메소드가 실행된 후 한 번 실행된다.</p>

</blockquote>

<h2 id="beforeeach-beforeall-예제">@BeforeEach, @BeforeAll 예제</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LifecycleTest</span> <span class="o">{</span>

    <span class="nd">@BeforeAll</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LifecycleTest.init"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">LifecycleTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"new LifecycleTest"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@BeforeEach</span>
    <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setUp"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@AfterEach</span>
    <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"tearDown"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@AfterAll</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LifecycleTest.close"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre># 실행 결과
LifecycleTest.init
new LifecycleTest
setUp
A
tearDown
new LifecycleTest
setUp
B
tearDown
LifecycleTest.close
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name>노승미</name></author><category term="TestCode" /><category term="TestCode" /><category term="JAVA" /><summary type="html"><![CDATA[@BeforeEach, @BeforeAll 애노테이션은 JUnit5에서 나온 애노테이션들이다.]]></summary></entry><entry><title type="html">프로세스와 스레드</title><link href="http://localhost:4000/cs/CS-ProcessandThread/" rel="alternate" type="text/html" title="프로세스와 스레드" /><published>2022-12-21T00:00:00+09:00</published><updated>2022-12-21T23:10:00+09:00</updated><id>http://localhost:4000/cs/CS-ProcessandThread</id><content type="html" xml:base="http://localhost:4000/cs/CS-ProcessandThread/"><![CDATA[<h2 id="들어가기-전에">들어가기 전에</h2>

<h3 id="키워드">키워드</h3>

<ol>
  <li>
    <p>실행 단위: cpu core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념</p>

    <p>→ 실행단위는 프로세스와 스레드 모두를 포괄한 개념이다. 따라서, 실행단위라고 했을 때 프로세스일 수도 있고 스레드일 수도 있다.</p>
  </li>
  <li>
    <p>(부연 설명이 없는) 프로세스: 하나의 스레드만 가지고 있는 단일 스레드 프로세스</p>

    <p>→ 프로세스와 스레드가 완전히 다른 무언가가 아니다.</p>
  </li>
  <li>
    <p>동시성: 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보이는 것이다.</p>
  </li>
</ol>

<h3 id="프로그램과-프로세스">프로그램과 프로세스</h3>

<ul>
  <li>프로그램: <code class="language-plaintext highlighter-rouge">코드 파일</code>, 프로그램: 실행시키기 전에는 코드가 구현되어 있는 파일일 뿐이다.</li>
  <li>프로세스: 프로그램이 실행 되어서 사용할 수 있는 무언가가 되는데 그게 <code class="language-plaintext highlighter-rouge">프로세스</code>이다.</li>
</ul>

<h3 id="미리-알면-좋은-process-지식">미리 알면 좋은 Process 지식</h3>

<p>프로그램이 프로세스가 되면서 2가지 일이 일어난다.</p>

<p>일단 프로세스가 필요로 하는 재료들이 메모리에 올라간다. 메모리 영역은 4가지 영역(Code, Data, Heap, Stack)이 있다.</p>

<ul>
  <li>Code: 실행 명령을 포함하는 코드들</li>
  <li>Data: Static 변수 혹은 Global 변수</li>
  <li>Head: 동적 메모리 영역</li>
  <li>Stack: 지역변수, 매개변수, 반환 값 등등 일시적인 데이터</li>
</ul>

<p>두번째로 해당 프로세스에 대한 정보를 담고 있는 PCB(Process Control Block) 블럭이 프로세스 생성 시 만들어진다.</p>

<ul>
  <li>Pointer: 프로세스 상태 중에 준비 상태나 대시 상태의 큐를 구현하기 위한 포인터</li>
  <li>Process State: 현재 프로세스 상태를 담는다.</li>
  <li>Process Number(ID): 고유 번호를 담는 PID</li>
  <li>Program Counter: 다음 명령어를 가리키는 프로그램 카운터</li>
</ul>

<p>등등이 있다.</p>

<p><img src="https://user-images.githubusercontent.com/79130276/208826768-f08fac51-b93b-479e-b576-0345aa74c016.png" alt="1" /></p>

<h2 id="process--thread">Process &amp; Thread</h2>

<h3 id="프로세스">프로세스</h3>

<p>개발자는 코딩을 하기 전에 유튜브에서 ‘이노래 뭐지’ 팝송 플레이리스트를 튼다. 그 후 코딩을 하기 위해 Intellij를 연다. 중요한 알람이 올 수 있으므로 slack을 켠다. 그리고 개발 필수템인 크롬을 킨다. 이렇게 대부분의 사람들은 하나의 프로세스를 사용하기 보다 여러가지를 <strong>동시에 사용</strong>한다.</p>

<p>하지만 원래 하나의 <code class="language-plaintext highlighter-rouge">프로세스</code>가 실행되기 위해서 CPU를 점유하고 있으면 다른 프로세스는 실행 상태에 있을 수 없다. 노래를 듣다가 코딩을 하기 위해 Intellij를 키면 노래가 꺼지게 된다. 즉, 여러 프로세스가 동시에 실행되고 관리되는 것처럼 보이지만 실제론 여러개의 프로세스를 <code class="language-plaintext highlighter-rouge">시분할</code>, 즉 <strong>짧은 텀</strong>을 반복하면서 <strong>전환</strong>해서 실행 시키는 것이다.</p>

<p>동시에 실행시키고 싶은 프로세스 A와 B가 있다고 가정하자. A를 실행시키기 위해 실행 상태로 전환하고 CPU에 적재된다. B는 준비상태에 있다. 이제 B를 실행시키기 위해서는 A를 먼저 준비상태로 전환하고 B가 CPU에 적재 되어야 한다. 이 과정을 반복하게 될때 발생하는 것이 <code class="language-plaintext highlighter-rouge">컨텍스트 스위칭</code>이다.</p>

<p><img src="https://user-images.githubusercontent.com/79130276/208826774-968f8152-3430-4325-b5b0-26718d8f40ef.png" alt="2" /></p>

<p>컨텍스트 스위칭은 매우 번거로운 작업이다. 이 부분을 개선하기 위해 등장한 것이 <strong>경량화된 프로세스</strong> 버전인 <code class="language-plaintext highlighter-rouge">스레드</code>이다.</p>

<blockquote>
  <p><strong>참고</strong> 컨텍스트 스위칭
컨텍스트 스위칭이란 CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 말한다.</p>

</blockquote>

<h3 id="스레드">스레드</h3>

<p><code class="language-plaintext highlighter-rouge">스레드</code>를 경량화된 프로세스라고 부르는 이유는 하나의 프로세스 안에 다수의 스레드가 있을 때 <strong>공유되는 자원</strong>이 있기 때문이다. 프로세스의 메모리 구조 중 Stack을 제외한 나머지 Code, Data, Heap을 모두 공유한다. 공유되는 자원이 있기 때문에 이전 처럼 컨텍스트 스위칭이 일어날 때 <strong>캐싱 적중률</strong>이 올라간다.</p>

<p><img src="https://user-images.githubusercontent.com/79130276/208826776-3ca71156-b56a-40dd-a91d-c313259a9d99.png" alt="3" /></p>

<h3 id="프로세스와-스레드-예">프로세스와 스레드 예</h3>

<p>예를 들어 <strong>공용 회의실</strong>이 있고 그 안에는 티비, 스피커, 리모컨이 있다고 가정하자. A팀이 먼저 회의실을 예약하여 사용했다. 이때 프로세스라면 A팀이 회의를 마치고 티비, 스피커, 리모컨을 가지고 나간다. 그 다음 팀인 B팀이 회의실을 사용하려면 티비, 스피커, 리모컨을 가지고 와야 회의실을 이용할 수 있다. 그러나, 스레드를 사용하면 공용자원인 티비, 스피커, 리모컨은 그대로 두고 자신들의 개인 노트북만 가지고 와서 연결하여 사용하면 된다.</p>

<h2 id="multi-process-vs-multi-thread">Multi-process vs Multi-thread</h2>

<p>멀티 프로세스와 멀티 스레드는 두가지 개념이 모두 <strong>처리 방식</strong>의 일종이다. 한 어플리케이션에 대한 처리 방식이라고 생각하면 편하다.</p>

<p>한 어플리케이션이 여러가지 일을 처리할 때가 있다. 예를 들어 여러 사용자가 로그인을 요청하는 상황이 있다고 가정한다. 한 프로세스는 매번 하나의 로그인을 처리하기 때문에 동시에 처리할 수가 없다. 그래서 부모 프로세스가 <code class="language-plaintext highlighter-rouge">fork()</code>해서 자식 프로세스를 만들어서 일을 처리한다. 이때 자식 프로세스는 부모와 <strong>별개의 메모리 영역</strong>을 확보하게 된다.</p>

<p>반면, 스레드는 한 프로세스 내에서 구분이 지어진 실행 단위이다. 한 어플리케이션에 대한 작업의 단위가 나눠질 때가 많다. (Intellij를 사용하는데 테스트도 실행하면서 동시에 코드를 수정하는 경우) 이때 각각의 스레드가 그 작업들을 담당한다.</p>

<h3 id="차이점">차이점</h3>

<p>멀티 프로세스는 각 프로세스에 독립적이므로 IPC를 사용해 통신해야 한다. 자원 소모적이며 <strong>개별 메모리</strong> 차지한다. 따라서, 컨텍스트 스위칭 <strong>비용이 크다</strong>. 하지만 독립적으로 존재하기 때문에 <strong>동기화 작업이 필요</strong>없다.</p>

<p>반면, 멀티 스레드는 스레드끼리 긴밀하게 연결되어 있다. 따라서, 공유된 자원으로 통신 비용이 절감되고 메모리를 효율적으로 사용할 수 있어 컨텍스트 스위칭 <strong>비용이 적다</strong>. 단, <strong>공유 자원 관리</strong>를 해야한다. (<strong>동기화 작업</strong>)</p>

<p><img src="https://user-images.githubusercontent.com/79130276/208826778-1627ae86-ea8c-4be7-b6bd-ee3243de1b26.png" alt="4" /></p>

<p>이렇게 보면 멀티 프로세스보다 멀티 스레드가 훨씬 좋아보이는데 왜 멀티 프로세스를 이용할까?</p>

<p>그 이유에 대한 예시는 크롬과 IE를 얘기할 수 있다.</p>

<p>크롬은 멀티 프로세스 사용, IE는 멀티 스레드 사용한다.</p>

<p>IE를 사용하면서 다수의 탭을 사용하고 있다가 경고 메시지가 나오며 창 전체가 꺼지는 경험을 한적이 있을 것이다. 멀티 스레드를 이용했기 때문에 발생하는 문제이다. 긴밀하게 연결되어 있기 때문에 한 스레드(1개의 탭)에 문제가 생기면 전체 프로세스에 영향이 있다. 반면, 구글 크롬은 다소 비효율적인 부분이 있을 수 있지만 멀티 프로세스를 사용하기 때문에 멀티탭 간에 영향을 덜 받는다.</p>

<h2 id="multi-core">Multi-core</h2>

<p>멀티 프로세스와 멀티 스레드는 처리방식의 일종이기 때문에 소프트웨어 분야에 가깝고 멀티 코어는 하드웨어 측면에 가깝다. 멀티 코어와 관련된 키워드는 <strong>동시성</strong>과 <strong>병렬처리</strong>이다.</p>

<p><code class="language-plaintext highlighter-rouge">동시성</code>이란 하나의 코어에서 하나 이상의 프로세스(혹은 스레드)가 번갈아가면서 진행되지만 동시에 진행되는 것처럼 보이는 것이다. (동시성은 짧은 순간에 CPU의 시간을 분할해서 동시에 하는 것처럼 보이게 한다.)</p>

<p>하지만 멀티코어는 <code class="language-plaintext highlighter-rouge">병렬처리</code> 즉, 물리적으로 여러 코어를 사용해서 다수의 실행 단위를 한 순간에 동시에 처리할 수 있게 해준다. (병렬처리란 둘 이상의 코어에서 동시에 하나 이상의 프로세스(혹은 스레드)가 한꺼번에 진행되는 것)</p>

<blockquote>
  <p><strong>참고</strong> 리눅스에서 프로세스와 스레드</p>

  <p><code class="language-plaintext highlighter-rouge">리눅스 커널</code>에서는 프로세스와 스레드를 동일하게 본다.</p>

  <p>스레드는 <strong>사용자 스레드</strong>와 <strong>커널 스레드</strong>로 나뉜다. 이름에서 알 수 있듯이 각 스레드를 담당하는 레벨이 하나는 사용자 레벨이고 하나는 커널 레벨이다. 사용자 스레드와 커널 스레드는 어떠한 연관관계가 있다.</p>

  <p>리눅스는 일대일 모델이다. 하나의 사용자 스레드당 커널 스레드 하나가 매칭된다. 그래서 리눅스 커널 입장에서 보면 ‘각각의 스레드가 하나의 프로세스다’ 라고 표현한다. 그런데 여기서의 프로세스는 이전에 설명했던 프로세스가 각각 다른 메모리를 가진 것과는 다르게 메모리를 공유한다. 그래서 이것들을 <code class="language-plaintext highlighter-rouge">light weight process</code>라고 구분해서 부른다. 이전에 설명했던 프로세스는 프로세스 고유번호(PID)를 가지고 있다. 그렇다면 리눅스는 스레드가 각각 다른 PID를 가지고 있을까? 그건 아니다. 확인해보면 한 프로세스의 생성된 스레드는 모두 같은 PID를 가지고 있다.</p>

  <p>더 자세히 보면 TGID라는 스레드 그룹 아이디를 가지고 있고 TID라는 스레드 아이디도 있다. 그래서 사용자 레벨입장에서 보면 스레드 그룹 아이디가 PID로 보여지고 커널 입장에서 보면 TID가 PID로 인식이 된다. 그래서 관점을 다르게 해서 이해 해야 한다. 그래서 커널 입장에서는 각각이 다른 프로세스로 보이게 된다.</p>

  <p><img src="https://user-images.githubusercontent.com/79130276/208826786-e1dfb8aa-4749-4c4b-89fb-5f25700522f1.png" alt="5" /></p>

</blockquote>

<p>[참조] 이 글은 해당 영상(<a href="https://www.youtube.com/watch?v=1grtWKqTn50">링크</a>)을 참고하여 작성한 글입니다.</p>]]></content><author><name>노승미</name></author><category term="CS" /><category term="CS" /><summary type="html"><![CDATA[들어가기 전에]]></summary></entry></feed>